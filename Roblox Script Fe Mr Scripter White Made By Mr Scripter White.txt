local Library = loadstring(game:HttpGet("https://raw.githubusercontent.com/xHeptc/Kavo-UI-Library/main/source.lua"))()

local Window = Library.CreateLib("Mr Scripter White Hub v2.6", "Ocean")

local Tab = Window:NewTab("Best Script")

local Section = Tab:NewSection("Script")

Section:NewButton("Xester", "Xester only r6", function()
    game:GetService("StarterGui"):SetCore("SendNotification", { 
	Title = "Mr Scripter White";
	Text = "Loading, enjoy!";
	Icon = "rbxthumb://type=Asset&id=7969699183&w=150&h=150"})
Duration = 16;
wait(0.1)
HumanDied = false
local CountSCIFIMOVIELOL = 1
function SCIFIMOVIELOL(Part0,Part1,Position,Angle)
	local AlignPos = Instance.new('AlignPosition', Part1); AlignPos.Name = "AliP_"..CountSCIFIMOVIELOL
	AlignPos.ApplyAtCenterOfMass = true;
	AlignPos.MaxForce = 5772000--67752;
	AlignPos.MaxVelocity = math.huge/9e110;
	AlignPos.ReactionForceEnabled = false;
	AlignPos.Responsiveness = 200;
	AlignPos.RigidityEnabled = false;
	local AlignOri = Instance.new('AlignOrientation', Part1); AlignOri.Name = "AliO_"..CountSCIFIMOVIELOL
	AlignOri.MaxAngularVelocity = math.huge/9e110;
	AlignOri.MaxTorque = 5772000
	AlignOri.PrimaryAxisOnly = false;
	AlignOri.ReactionTorqueEnabled = false;
	AlignOri.Responsiveness = 200;
	AlignOri.RigidityEnabled = false;
	local AttachmentA=Instance.new('Attachment',Part1); AttachmentA.Name = "Ath_"..CountSCIFIMOVIELOL
	local AttachmentB=Instance.new('Attachment',Part0); AttachmentB.Name = "Ath_"..CountSCIFIMOVIELOL
	AttachmentA.Orientation = Angle or Vector3.new(0,0,0)
	AttachmentA.Position = Position or Vector3.new(0,0,0)
	AlignPos.Attachment1 = AttachmentA;
	AlignPos.Attachment0 = AttachmentB;
	AlignOri.Attachment1 = AttachmentA;
	AlignOri.Attachment0 = AttachmentB;
	CountSCIFIMOVIELOL = CountSCIFIMOVIELOL + 1
	return {AlignPos,AlignOri,AttachmentA,AttachmentB}
end

if _G.netted ~= true then
	_G.netted = true
	coroutine.wrap(function()
		settings().Physics.PhysicsEnvironmentalThrottle = Enum.EnviromentalPhysicsThrottle.Disabled
		settings().Physics.AllowSleep = false
		game:GetService("RunService").RenderStepped:Connect(function()
			game:FindFirstChildOfClass("Players").LocalPlayer.MaximumSimulationRadius=math.pow(math.huge,math.huge)
			sethiddenproperty(game:FindFirstChildOfClass("Players").LocalPlayer,"SimulationRadius",math.huge*math.huge)
		end)
	end)()
end

game:FindFirstChildOfClass("Players").LocalPlayer["Character"].Archivable = true
local hatnameclone = {}
for _,v in next, game:FindFirstChildOfClass("Players").LocalPlayer["Character"]:GetChildren() do
	if v:IsA("Accessory") then
		if hatnameclone[v.Name] then
			if hatnameclone[v.Name] == "s" then
				hatnameclone[v.Name] = {}
			end
			table.insert(hatnameclone[v.Name],v)
		else
			hatnameclone[v.Name] = "s"
		end
	end
end
for _,v in pairs(hatnameclone) do
	if type(v) == "table" then
		local num = 1
		for _,w in pairs(v) do
			w.Name = w.Name..num
			num = num + 1
		end
	end
end
hatnameclone = nil

local DeadChar = game:FindFirstChildOfClass("Players").LocalPlayer.Character

local fldr = Instance.new("Folder",game:FindFirstChildOfClass("Players").LocalPlayer["Character"])
fldr.Name = "DMYF"
local CloneChar = DeadChar:Clone()
local ANIMATIONHERE
if CloneChar:FindFirstChild("Animate") then
	ANIMATIONHERE = CloneChar:FindFirstChild("Animate"):Clone()
	CloneChar:FindFirstChild("Animate"):Destroy()
end
if CloneChar:FindFirstChildOfClass("Folder") then CloneChar:FindFirstChildOfClass("Folder"):Destroy() end
if CloneChar.Torso:FindFirstChild("Neck") then
	local Clonessss = CloneChar.Torso:FindFirstChild("Neck"):Clone()
	Clonessss.Part0 = nil
	Clonessss.Part1 = DeadChar.Head
	Clonessss.Parent = DeadChar.Torso
end
CloneChar.Parent = fldr
CloneChar.HumanoidRootPart.CFrame = DeadChar.HumanoidRootPart.CFrame
CloneChar.Humanoid.BreakJointsOnDeath = false
CloneChar.Name = "non"
CloneChar.Humanoid.DisplayDistanceType = "None"

for _,v in next, DeadChar:GetChildren() do
	if v:IsA("Accessory") then
		local topacc = false
		if v.Handle:FindFirstChildOfClass("Weld") then v.Handle:FindFirstChildOfClass("Weld"):Destroy() end
		v.Handle.Massless = true
		v.Handle.CanCollide = false
		if v.Handle:FindFirstChildOfClass("Attachment") then
			local ath__ = v.Handle:FindFirstChildOfClass("Attachment")
			if ath__.Name == "HatAttachment" or ath__.Name == "HairAttachment" or ath__.Name == "FaceFrontAttachment" or ath__.Name == "FaceCenterAttachment" then
				topacc = ath__.Name
			end
		end
        local bv = Instance.new("BodyVelocity",v.Handle)
		bv.Velocity = Vector3.new(0,0,0)
		coroutine.wrap(function()
			if topacc then
				local allthings = SCIFIMOVIELOL(v.Handle,DeadChar.Torso,Vector3.new(0,1.5,0)+ (DeadChar.Head[topacc].Position + (v.Handle[topacc].Position*-1)),Vector3.new(0,0,0))
				local normaltop = allthings[1].Attachment1
				local alipos = allthings[1]
				local alirot = allthings[2]
				local p0 = v.Handle
				local p1 = DeadChar.Head
				alipos.Parent = CloneChar:FindFirstChild(v.Name).Handle
				alirot.Parent = CloneChar:FindFirstChild(v.Name).Handle
				while true do
					game:GetService("RunService").RenderStepped:wait()
					if HumanDied then break end
					coroutine.wrap(function()
						if alipos.Attachment1 == normaltop then
							p0.CFrame = p0.CFrame:lerp((((DeadChar.Torso.CFrame * CFrame.new(0,1.5,0)) * p1[topacc].CFrame) * p0[topacc].CFrame:inverse()),1)
						else
							v.Handle.CFrame = v.Handle.CFrame:lerp(alipos.Attachment1.Parent.CFrame * CFrame.new(alipos.Attachment1.Position) * CFrame.Angles(math.rad(alipos.Attachment1.Rotation.X),math.rad(alipos.Attachment1.Rotation.Y),math.rad(alipos.Attachment1.Rotation.Z)),1)
						end
					end)()
				end
			else
				SCIFIMOVIELOL(v.Handle,CloneChar[v.Name].Handle,Vector3.new(0,0,0),Vector3.new(0,0,0))
			end
		end)()
    end
end

local a = DeadChar.Torso
local b = DeadChar.HumanoidRootPart
local c = DeadChar.Humanoid
a.Parent = game:FindFirstChildOfClass("Workspace")
c.Parent = game:FindFirstChildOfClass("Workspace")
local told = a:Clone()
local told1 = c:Clone()
b["RootJoint"].Part0 = told
b["RootJoint"].Part1 = DeadChar.Head
a.Name = "torso"
a.Neck:Destroy()
c.Name = "Mizt Hub Best"
told.Parent = DeadChar
told1.Parent = DeadChar
DeadChar.PrimaryPart = told
told1.Health = 0
b:Destroy()
a.Parent = DeadChar
c.Parent = DeadChar
told:Destroy()
told1:Destroy()
a.Name = "Torso"

if CloneChar.Head:FindFirstChildOfClass("Decal") then CloneChar.Head:FindFirstChildOfClass("Decal").Transparency = 1 end
if DeadChar:FindFirstChild("Animate") then DeadChar:FindFirstChild("Animate"):Destroy() end

local Collider
function UnCollide()
    if HumanDied then Collider:Disconnect(); return end
    --[[for _,Parts in next, CloneChar:GetChildren() do
        if Parts:IsA("BasePart") then
            Parts.CanCollide = false 
        end 
    end]]
    for _,Parts in next, DeadChar:GetChildren() do
        if Parts:IsA("BasePart") then
        Parts.CanCollide = false
        end 
    end 
end
Collider = game:GetService("RunService").Stepped:Connect(UnCollide)

local resetBindable = Instance.new("BindableEvent")
resetBindable.Event:connect(function()
    game:GetService("StarterGui"):SetCore("ResetButtonCallback", true)
	resetBindable:Destroy()
	HumanDied = true
    pcall(function()
		game:FindFirstChildOfClass("Players").LocalPlayer.Character = DeadChar
		DeadChar.Head:Destroy()
		DeadChar:FindFirstChildOfClass("Humanoid"):Destroy()
		game:FindFirstChildOfClass("Players").LocalPlayer.Character = CloneChar
		if DeadChar:FindFirstChildOfClass("Folder") then DeadChar:FindFirstChildOfClass("Folder"):Destroy() end
	end)
end)
game:GetService("StarterGui"):SetCore("ResetButtonCallback", resetBindable)

coroutine.wrap(function()
    while true do
        game:GetService("RunService").RenderStepped:wait()
        if not CloneChar or not CloneChar:FindFirstChild("Head") or not CloneChar:FindFirstChildOfClass("Humanoid") or CloneChar:FindFirstChildOfClass("Humanoid").Health <= 0 and not DeadChar or not DeadChar:FindFirstChild("Head") or not DeadChar:FindFirstChildOfClass("Humanoid") or DeadChar:FindFirstChildOfClass("Humanoid").Health <= 0 then 
            HumanDied = true
            pcall(function()
				game:FindFirstChildOfClass("Players").LocalPlayer.Character = DeadChar
				DeadChar.Head:Destroy()
				DeadChar:FindFirstChildOfClass("Humanoid"):Destroy()
				game:FindFirstChildOfClass("Players").LocalPlayer.Character = CloneChar
				if DeadChar:FindFirstChildOfClass("Folder") then DeadChar:FindFirstChildOfClass("Folder"):Destroy() end
			end)
            if resetBindable then
                game:GetService("StarterGui"):SetCore("ResetButtonCallback", true)
                resetBindable:Destroy()
            end
            break
        end		
    end
end)()


SCIFIMOVIELOL(DeadChar["Head"],CloneChar["Head"])
SCIFIMOVIELOL(DeadChar["Torso"],CloneChar["Torso"])
SCIFIMOVIELOL(DeadChar["Left Arm"],CloneChar["Left Arm"])
SCIFIMOVIELOL(DeadChar["Right Arm"],CloneChar["Right Arm"])
SCIFIMOVIELOL(DeadChar["Left Leg"],CloneChar["Left Leg"])
SCIFIMOVIELOL(DeadChar["Right Leg"],CloneChar["Right Leg"])

for _,v in pairs(DeadChar:GetChildren()) do
	if v:IsA("BasePart") and v.Name ~= "Head" then
		--[[local bv = Instance.new("BodyVelocity",v)
		bv.Velocity = Vector3.new(0,0,0)
		coroutine.wrap(function()
			while true do
				game:GetService("RunService").RenderStepped:wait()
				if HumanDied then break end
				v.CFrame = CloneChar[v.Name].CFrame
			end
		end)()]]
	elseif v:IsA("BasePart") and v.Name == "Head" then
		local bv = Instance.new("BodyVelocity",v)
		bv.Velocity = Vector3.new(0,0,0)
		coroutine.wrap(function()
			while true do
				game:GetService("RunService").RenderStepped:wait()
				if HumanDied then break end
				v.CFrame = DeadChar.Torso.CFrame * CFrame.new(0,1.5,0)
			end
		end)()
	end
end

for _,BodyParts in next, CloneChar:GetDescendants() do
if BodyParts:IsA("BasePart") or BodyParts:IsA("Part") then
BodyParts.Transparency = 1 end end
game:GetService("RunService").RenderStepped:wait()
game:FindFirstChildOfClass("Players").LocalPlayer.Character = CloneChar
game:FindFirstChildOfClass("Workspace"):FindFirstChildOfClass("Camera").CameraSubject = CloneChar.Humanoid

for _,v in next, DeadChar:GetChildren() do
	if v:IsA("Accessory") then
		if v.Handle:FindFirstChildOfClass("Weld") then v.Handle:FindFirstChildOfClass("Weld"):Destroy() end
	end
end

if ANIMATIONHERE then ANIMATIONHERE.Parent = CloneChar end

wait(0.2)



-----------/XESTER THE CARD MASTER\\-----------
--[[Movelist
Q = The disappearing act.
E = Full house
R = Cardnado
T = Teleport
Y = Big card(Click to smash.)
U = Black hole
P = Card shield(Click to bounce people off, press p again to shred.)
F = Transform(You can switch between modes any time.)
-----------/SECOND FORM MOVES\-----------
T = Laugh
G = Fire ball
H = Huge fire ball
J = Dragon's breath(The longer you hold, the more insaner it gets.)
K = Beam(The longer you hold down the key, the stronger it gets/longer it lasts.)
---------]]

--"Now you see me 2" is a good movie, which is why i've made this.--
--Sadly, this got logged, one of my best work just being thrown out like this is a real shame.--
--This was made before FE so using this may or may not lag the server--
--Keep in mind that THIS was never even finished at all, i stopped working on this when skidcentric leaked it, who knows how big this script could've been?--

Player=game:GetService("Players").LocalPlayer
Character=Player.Character
Character.Humanoid.Name = "noneofurbusiness"
hum = Character.noneofurbusiness
LeftArm=Character["Left Arm"]
LeftLeg=Character["Left Leg"]
RightArm=Character["Right Arm"]
RightLeg=Character["Right Leg"]
Root=Character["HumanoidRootPart"]
Head=Character["Head"]
Torso=Character["Torso"]
Neck=Torso["Neck"]
walking = false
jumping = false
allowgrassy = false
zxc = false
matte = nil
colori = nil
bigball = false
attacking = false
laughing = false
running = false
downpress = false
taim = nil
change = 0
ws = 10
appi = false
tauntdebounce = false
position = nil
staybooming = false
MseGuide = true
levitate = false
firsttime5 = false
notallowedtransform = false
settime = 0
firsttime2 = false
sine = 0
t = 0
combo1 = true
dgs = 75
combo2 = false
firsttime3 = false
combo3 = false
local bl = {907530553,907527750,907527912}
colortable = {"Really black","Really red"}
colors = #colortable
blz = #bl
local aces = {1880203893,1881287656,1881287420,1881288034}
ace = #aces
local laughs = {2011349649,2011349983,2011351501,2011352223,2011355991,2011356475}
laugh = #laughs
mouse = Player:GetMouse()
RunSrv = game:GetService("RunService")
RenderStepped = game:GetService("RunService").RenderStepped
removeuseless = game:GetService("Debris")
damageall={}
Repeater={}
Repeater2={}
magictable={}
nonmeshRepeater={}
nonmeshRepeater2={}
dmgii={}
DamageAll2={}
SlowlyFade={}
th1={}
lolzor={}
lolzor2={}
th2={}
keyYsize={}
blocktrail={}
keyYtransparency={}
th3={}
laughingtable={}
Extreme={}
ExtremeM={}
ExtremeM2={}
m3={}
th4={}
th5={}
UpMover={}
openshocktable={}
LessSize={}
ForwardMover={}
FadeIn={}
signtransparency={}
signmover={}
signrotator={}

screenGui = Instance.new("ScreenGui")
screenGui.Parent = script.Parent

FireBall = Instance.new("Sound",LeftArm)
FireBall.SoundId = "rbxassetid://842332424"
FireBall.Volume = 5
FireBall.Pitch = 2.5

BigFireBall = Instance.new("Sound",LeftArm)
BigFireBall.SoundId = "rbxassetid://842332424"
BigFireBall.Volume = 8
BigFireBall.Pitch = 1.5

local HEADLERP = Instance.new("ManualWeld")
HEADLERP.Parent = Head
HEADLERP.Part0 = Head
HEADLERP.Part1 = Head
HEADLERP.C0 = CFrame.new(0, -1.5, -0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0))

local TORSOLERP = Instance.new("ManualWeld")
TORSOLERP.Parent = Root
TORSOLERP.Part0 = Torso
TORSOLERP.C0 = CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0))

local ROOTLERP = Instance.new("ManualWeld")
ROOTLERP.Parent = Root
ROOTLERP.Part0 = Root
ROOTLERP.Part1 = Torso
ROOTLERP.C0 = CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0))

local RIGHTARMLERP = Instance.new("ManualWeld")
RIGHTARMLERP.Parent = RightArm
RIGHTARMLERP.Part0 = RightArm
RIGHTARMLERP.Part1 = Torso
RIGHTARMLERP.C0 = CFrame.new(-1.5, 0, -0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0))

local LEFTARMLERP = Instance.new("ManualWeld")
LEFTARMLERP.Parent = LeftArm
LEFTARMLERP.Part0 = LeftArm
LEFTARMLERP.Part1 = Torso
LEFTARMLERP.C0 = CFrame.new(1.5, 0, -0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0))

local RIGHTLEGLERP = Instance.new("ManualWeld")
RIGHTLEGLERP.Parent = RightLeg
RIGHTLEGLERP.Part0 = RightLeg
RIGHTLEGLERP.Part1 = Torso
RIGHTLEGLERP.C0 = CFrame.new(-0.5, 2, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0))

local LEFTLEGLERP = Instance.new("ManualWeld")
LEFTLEGLERP.Parent = LeftLeg
LEFTLEGLERP.Part0 = LeftLeg
LEFTLEGLERP.Part1 = Torso
LEFTLEGLERP.C0 = CFrame.new(0.5, 2, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0))

local function weldBetween(a, b)
    local weld = Instance.new("ManualWeld", a)
    weld.Part0 = a
    weld.Part1 = b
    weld.C0 = a.CFrame:inverse() * b.CFrame
    return weld
end

function makeblockytrail()
coroutine.wrap(function()
while true do
for i,v in pairs(blocktrail) do
smke = Instance.new("Part",v)
smke.CFrame = v.CFrame * CFrame.Angles(math.random(-180,180),math.random(-180,180),math.random(-180,180))
smke.Material = "Neon"
smke.Anchored = true
smke.CanCollide = false
removeuseless:AddItem(smke,2)
end
swait()
end
end)()
end

local function ci(x, c, y, n)
so = Instance.new("Sound", x)
so.SoundId = c
so.Volume = y
so.Looped = n
end

function ghost()
fakeeyo2 = Instance.new("Part",Head)
fakeeyo2.BrickColor = BrickColor.new("White")
fakeeyo2.Material = "Neon"
fakeeyo2.Shape = "Ball"
fakeeyo2.Anchored = true
fakeeyo2.CFrame = eyo2.CFrame
fakeeyo2.CanCollide = false
fakeeyo2.Size = Vector3.new(0.33, 0.33, 0.33)
table.insert(ghosttable,fakeeyo2)
removeuseless:AddItem(fakeeyo2,3)

fakeeyo1 = Instance.new("Part",Head)
fakeeyo1.BrickColor = BrickColor.new("White")
fakeeyo1.Material = "Neon"
fakeeyo1.Shape = "Ball"
fakeeyo1.CanCollide = false
fakeeyo1.Anchored = true
fakeeyo1.CFrame = eyo1.CFrame
fakeeyo1.Size = Vector3.new(0.33, 0.33, 0.33)
table.insert(ghosttable,fakeeyo1)
removeuseless:AddItem(fakeeyo1,3)

fakemask = Instance.new("Part",Character)
fakemask.Size = Vector3.new(1,1,1)
fakemask.CFrame = mask.CFrame
fakemask.Material = "Neon"
fakemask.CanCollide = false
fakemask.Anchored = true
fakemask.BrickColor = BrickColor.new("White")
fakemask.Transparency = .5
mfMask = Instance.new("SpecialMesh", fakemask)
mfMask.MeshType = "FileMesh"
mfMask.Scale = Vector3.new(0.13, 0.13, 0.1)
mfMask.MeshId = 'http://www.roblox.com/asset/?id=5158270'
table.insert(ghosttable,fakemask)
removeuseless:AddItem(fakemask,3)


fakejester = Instance.new("Part",Character)
fakejester.Size = Vector3.new(2,2,2)
fakejester.CFrame = jester.CFrame
fakejester.CanCollide = false
fakejester.Transparency = .5
fakejester.Anchored = true
fakejester.BrickColor = BrickColor.new("White")
fakejesterm = Instance.new("SpecialMesh", fakejester)
fakejesterm.MeshType = "FileMesh"
fakejesterm.Scale = Vector3.new(1.1, 1.1, 1.1)
fakejesterm.MeshId = 'rbxassetid://1241662062'
table.insert(ghosttable,fakejester)
removeuseless:AddItem(fakejester,3)


fakehead = Instance.new("Part",Character)
fakehead.Size = Vector3.new(1.01,1.01,1.01)
fakehead.Anchored = true
fakehead.CanCollide = false
fakehead.Transparency = .5
fakehead.BrickColor = BrickColor.new("White")
fakehead.Material = "Neon"
fakehead.CFrame = Head.CFrame
fakeheadmesh = Instance.new("SpecialMesh",fakehead)
fakeheadmesh.MeshType = "Head"
fakeheadmesh.Scale = Vector3.new(1.255,1.255,1.255)
table.insert(ghosttable,fakehead)
removeuseless:AddItem(fakehead,3)


fakelarm = Instance.new("Part",Character)
fakelarm.CFrame = LeftArm.CFrame
fakelarm.Size = Vector3.new(1,2,1)
fakelarm.CanCollide = false
fakelarm.Transparency = .5
fakelarm.Material = "Neon"
fakelarm.Anchored = true
table.insert(ghosttable,fakelarm)
removeuseless:AddItem(fakelarm,3)


fakerarm = Instance.new("Part",Character)
fakerarm.CFrame = RightArm.CFrame
fakerarm.Size = Vector3.new(1,2,1)
fakerarm.Transparency = .5
fakerarm.CanCollide = false
fakerarm.Material = "Neon"
fakerarm.Anchored = true
table.insert(ghosttable,fakerarm)
removeuseless:AddItem(fakerarm,3)


fakelleg = Instance.new("Part",Character)
fakelleg.CFrame = LeftLeg.CFrame
fakelleg.Size = Vector3.new(1,2,1)
fakelleg.Transparency = .5
fakelleg.CanCollide = false
fakelleg.Material = "Neon"
fakelleg.Anchored = true
table.insert(ghosttable,fakelleg)
removeuseless:AddItem(fakelleg,3)


fakerleg = Instance.new("Part",Character)
fakerleg.CFrame = RightLeg.CFrame
fakerleg.Size = Vector3.new(1,2,1)
fakerleg.Transparency = .5
fakerleg.CanCollide = false
fakerleg.Material = "Neon"
fakerleg.Anchored = true
table.insert(ghosttable,fakerleg)
removeuseless:AddItem(fakerleg,3)


fakeTorso = Instance.new("Part",Character)
fakeTorso.CFrame = Torso.CFrame
fakeTorso.Size = Vector3.new(2,2,1)
fakeTorso.Transparency = .5
fakeTorso.CanCollide = false
fakeTorso.Material = "Neon"
fakeTorso.Anchored = true
table.insert(ghosttable,fakeTorso)
removeuseless:AddItem(fakeTorso,3)
end

ghosttable={}
coroutine.wrap(function()
while true do
for i,v in pairs(ghosttable) do
v.Transparency = v.Transparency + 0.025
end
wait()
end
end)()

function MAKETRAIL(PARENT,POSITION1,POSITION2,LIFETIME,COLOR)
A = Instance.new("Attachment", PARENT)
A.Position = POSITION1
A.Name = "A"
B = Instance.new("Attachment", PARENT)
B.Position = POSITION2
B.Name = "B"
tr1 = Instance.new("Trail", PARENT)
tr1.Attachment0 = A
tr1.Attachment1 = B
tr1.Enabled = true
tr1.Lifetime = LIFETIME
tr1.TextureMode = "Static"
tr1.LightInfluence = 0
tr1.Color = COLOR
tr1.Transparency = NumberSequence.new(0, 1)
end

function clean()
damageall={}
Repeater={}
Repeater2={}
nonmeshRepeater={}
nonmeshRepeater2={}
dmgii={}
DamageAll2={}
SlowlyFade={}
th1={}
th2={}
th3={}
Extreme={}
ExtremeM={}
ExtremeM2={}
m3={}
th4={}
th5={}
UpMover={}
openshocktable={}
LessSize={}
ForwardMover={}
FadeIn={}
signtransparency={}
signmover={}
signrotator={}
end

coroutine.wrap(function()
while wait() do
hum.WalkSpeed = ws
LeftArm.BrickColor = BrickColor.new("Really black")
RightArm.BrickColor = BrickColor.new("Really black")
Head.BrickColor = BrickColor.new("Really black")
end
end)()
godmode = coroutine.wrap(function()
for i,v in pairs(Character:GetChildren()) do
if v:IsA("BasePart") and v ~= Root then
v.Anchored = false
end
end
while true do
hum.MaxHealth = math.huge
wait(0.0000001)
hum.Health = math.huge
wait()
end
end)
godmode()
ff = Instance.new("ForceField", Character)
ff.Visible = false

coroutine.wrap(function()
for i,v in pairs(Character:GetChildren()) do
if v.Name == "Animate" then v:Remove()
end
end
end)()

function damagealll(Radius,Position)		
	local Returning = {}		
	for _,v in pairs(workspace:GetChildren()) do		
		if v~=Character and v:FindFirstChildOfClass('Humanoid') and v:FindFirstChild('Torso') or v:FindFirstChild('UpperTorso') then
if v:FindFirstChild("Torso") then		
			local Mag = (v.Torso.Position - Position).magnitude		
			if Mag < Radius then		
				table.insert(Returning,v)		
			end
elseif v:FindFirstChild("UpperTorso") then	
			local Mag = (v.UpperTorso.Position - Position).magnitude		
			if Mag < Radius then		
				table.insert(Returning,v)		
			end
end	
		end		
	end		
	return Returning		
end

ArtificialHB = Instance.new("BindableEvent", script)
ArtificialHB.Name = "Heartbeat"
script:WaitForChild("Heartbeat")

frame = 1 / 60
tf = 0
allowframeloss = false
tossremainder = false


lastframe = tick()
script.Heartbeat:Fire()


game:GetService("RunService").Heartbeat:connect(function(s, p)
	tf = tf + s
	if tf >= frame then
		if allowframeloss then
			script.Heartbeat:Fire()
			lastframe = tick()
		else
			for i = 1, math.floor(tf / frame) do
				script.Heartbeat:Fire()
			end
			lastframe = tick()
		end
		if tossremainder then
			tf = 0
		else
			tf = tf - frame * math.floor(tf / frame)
		end
	end
end)

function swait(num)
	if num == 0 or num == nil then
		game:service("RunService").Stepped:wait(0)
	else
		for i = 0, num do
			game:service("RunService").Stepped:wait(0)
		end
	end
end

doomtheme = Instance.new("Sound", Torso)
doomtheme.Volume = 3
doomtheme.Name = "doomtheme"
doomtheme.Looped = true
doomtheme.SoundId = "rbxassetid://1843358057"
doomtheme:Play()

Torso.ChildRemoved:connect(function(removed)
if removed.Name == "doomtheme" then
if levitate then
doomtheme = Instance.new("Sound", Torso)
doomtheme.Volume = 3
doomtheme.Name = "doomtheme"
doomtheme.Looped = true
doomtheme.SoundId = "rbxassetid://1382488262"
doomtheme:Play()
doomtheme.TimePosition = 20.7
else
doomtheme = Instance.new("Sound", Torso)
doomtheme.Volume = 3
doomtheme.Name = "doomtheme"
doomtheme.Looped = true
doomtheme.SoundId = "rbxassetid://1843358057"
doomtheme:Play()
end
end
end)

for _,n in pairs(Character:GetChildren()) do
if n:IsA("Accessory") then n:Remove() end
end
for _,x in pairs(Character:GetChildren()) do
if x:IsA("Decal") then x:Remove() end
end

glow = Instance.new("Part",Head)
glow.Size = Vector3.new(.488,.3,.1)
glow.CanCollide = false
glow.Material = "Neon"
glow.Transparency = 1
glow.BrickColor = BrickColor.new("Really white")
glowweld = weldBetween(glow,Head)
glowweld.C0 = CFrame.new(0,.2,.565)

leftlocation = Instance.new("Part",LeftArm)
leftlocation.Size = Vector3.new(1,1,1)
leftlocation.Transparency = 1
leftlocationweld = weldBetween(leftlocation,LeftArm)
leftlocationweld.C0 = CFrame.new(0,1.2,0)
rightlocation = Instance.new("Part",RightArm)
rightlocation.Size = Vector3.new(1,1,1)
rightlocation.Transparency = 1
rightlocationweld = weldBetween(rightlocation,RightArm)
rightlocationweld.C0 = CFrame.new(0,1.2,0)

shirt = Instance.new("Shirt", Character)
shirt.Name = "Shirt"
pants = Instance.new("Pants", Character)
pants.Name = "Pants"
Character.Shirt.ShirtTemplate = "rbxassetid://676428254"----lol
Character.Pants.PantsTemplate = "rbxassetid://676428351"

fakehed = Instance.new("Part",Character)
fakehed.Size = Vector3.new(1.01,1.01,1.01)
fakehed.Anchored = false
fakehed.CanCollide = false
fakehed.Transparency = 0
fakehed.BrickColor = BrickColor.new("Really black")
fakehed.Material = "Neon"
fakehed.CFrame = Head.CFrame
fakehedweld = weldBetween(fakehed,Head)
fakehedmesh = Instance.new("SpecialMesh",fakehed)
fakehedmesh.MeshType = "Head"
fakehedmesh.Scale = Vector3.new(1.255,1.255,1.255)

jester = Instance.new("Part",Character)
jester.Size = Vector3.new(2,2,2)
jester.CFrame = Head.CFrame
jester.CanCollide = false
jesterWeld = Instance.new("Weld",jester)
jesterWeld.Part0 = jester
jesterWeld.Part1 = Head
jesterWeld.C0 = jester.CFrame:inverse() * Head.CFrame * CFrame.new(0,-.3,0) * CFrame.Angles(math.rad(0),math.rad(90),0)
mjester = Instance.new("SpecialMesh", jester)
mjester.MeshType = "FileMesh"
mjester.Scale = Vector3.new(1.1, 1.1, 1.1)
mjester.MeshId,mjester.TextureId = 'rbxassetid://1241662062','rbxassetid://1241662395'

mask = Instance.new("Part",Character)
mask.Size = Vector3.new(1,1,1)
mask.CFrame = Head.CFrame
mask.CanCollide = false
maskweld = weldBetween(mask,Head)
maskweld.C0 = CFrame.new(0,-.555,0) * CFrame.Angles(math.rad(90),0,0)
mMask = Instance.new("SpecialMesh", mask)
mMask.MeshType = "FileMesh"
mMask.Scale = Vector3.new(0.13, 0.13, 0.1)
mMask.MeshId,mMask.TextureId = 'http://www.roblox.com/asset/?id=5158270','http://www.roblox.com/asset/?id=9543585'

eyo1 = Instance.new("Part",Head)
eyo1.BrickColor = BrickColor.new("White")
eyo1.Material = "Neon"
eyo1.Shape = "Ball"
eyo1.Name = "eyo1"
eyo1.CanCollide = false
eyo1.Size = Vector3.new(0.33, 0.33, 0.33)
eyo1weld = weldBetween(eyo1,Head)
eyo1weld.C0 = CFrame.new(.215,-.05,.52)

light = Instance.new("PointLight", eyo1)
light.Color = Color3.new(1,1,1)
light.Range = 3
light.Brightness = 4
light.Enabled = true

eyo2 = Instance.new("Part",Head)
eyo2.BrickColor = BrickColor.new("White")
eyo2.Material = "Neon"
eyo2.Shape = "Ball"
eyo2.Name = "eyo2"
eyo2.CanCollide = false
eyo2.Size = Vector3.new(0.33, 0.33, 0.33)
eyo2weld = weldBetween(eyo2,Head)
eyo2weld.C0 = CFrame.new(-.215,-.05,.52)

light2 = Instance.new("PointLight", eyo2)
light2.Color = Color3.new(1,1,1)
light2.Range = 3
light2.Brightness = 4
light2.Enabled = true

function SOUND(PARENT,ID,VOL,LOOP,REMOVE)
so = Instance.new("Sound")
so.Parent = PARENT
so.SoundId = "rbxassetid://"..ID
so.Volume = VOL
so.Looped = LOOP
so:Play()
removeuseless:AddItem(so,REMOVE)
end


mouse.KeyDown:connect(function(Press)
Press=Press:lower()
if Press=='r' then
if levitate then return end
if debounce then return end
debounce = true
attacking = true
appi = true
ws = 0
coroutine.wrap(function()
while appi do
wait()
if Root.Velocity.Magnitude < 2 and attacking == true then
position = "Idle2"
end
end
end)()
coroutine.wrap(function()
while appi do
wait()
settime = 0.05
sine = sine + change
if position == "Idle2" and attacking == true and appi == true then
change = .4
LEFTLEGLERP.C1 = LEFTLEGLERP.C1:lerp(CFrame.new(0,0,0) * CFrame.Angles(0,0,0),.1)
RIGHTLEGLERP.C1 = RIGHTLEGLERP.C1:lerp(CFrame.new(0,0,0) * CFrame.Angles(math.rad(0),0,0),.1)
LEFTARMLERP.C0 = LEFTARMLERP.C0:lerp(CFrame.new(1.5,.6,-.5) * CFrame.Angles(math.rad(30),math.rad(-5 + 1 * math.sin(sine/12)),math.rad(-40 + 2 * math.sin(sine/12))), 0.3)
LEFTARMLERP.C1 = LEFTARMLERP.C1:lerp(CFrame.new(.2,1.2,-.3),.3)
ROOTLERP.C0 = ROOTLERP.C0:lerp(CFrame.new(0, -.2 + -.1 * math.sin(sine/12), 0) * CFrame.Angles(math.rad(0),math.rad(25),math.rad(0)),.3)
RIGHTLEGLERP.C0 = RIGHTLEGLERP.C0:lerp(CFrame.new(-0.3, 2 - .1 * math.sin(sine/12), 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(-10)), 0.3)
LEFTLEGLERP.C0 = LEFTLEGLERP.C0:lerp(CFrame.new(0.3, 2.0 - .1 * math.sin(sine/12), 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(10)), 0.3)
end
end
end)()
for i = 1, 20 do
ROOTLERP.C0 = ROOTLERP.C0:lerp(CFrame.new(0, -.2 + -.1 * math.sin(sine/12), 0) * CFrame.Angles(math.rad(0),math.rad(25),math.rad(0)),.3)
RIGHTLEGLERP.C0 = RIGHTLEGLERP.C0:lerp(CFrame.new(-0.3, 2 - .1 * math.sin(sine/12), 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(-10)), 0.3)
LEFTLEGLERP.C0 = LEFTLEGLERP.C0:lerp(CFrame.new(0.3, 2.0 - .1 * math.sin(sine/12), 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(10)), 0.3)
RIGHTARMLERP.C1 = RIGHTARMLERP.C1:lerp(CFrame.new(0,1.5,-.1),.5)
RIGHTARMLERP.C0 = RIGHTARMLERP.C0:lerp(CFrame.new(-1.5,0,0) * CFrame.Angles(math.rad(180),math.rad(10),math.rad(10)),.3)
swait()
end
SOUND(RightArm,342337569,6,false,1)
coroutine.wrap(function()
for i = 1, 9 do
RIGHTARMLERP.C1 = RIGHTARMLERP.C1:lerp(CFrame.new(.1,1.6,-.1),.5)
RIGHTARMLERP.C0 = RIGHTARMLERP.C0:lerp(CFrame.new(-1.5,0,0) * CFrame.Angles(math.rad(180),math.rad(10),math.rad(15)),.3)
swait()
end
for i = 1, 9 do
RIGHTARMLERP.C1 = RIGHTARMLERP.C1:lerp(CFrame.new(0,1.5,-.1),.5)
RIGHTARMLERP.C0 = RIGHTARMLERP.C0:lerp(CFrame.new(-1.5,0,0) * CFrame.Angles(math.rad(180),math.rad(10),math.rad(10)),.3)
swait()
end
end)()
shockwave = Instance.new("Part",Torso)
shockwave.Shape = "Ball"
shockwave.Size = Vector3.new(1,1,1)
shockwave.BrickColor = BrickColor.new("White")
shockwave.Material = "Neon"
shockwave.CFrame = Torso.CFrame
shockwave.CanCollide = false
shockwave.Anchored = true
coroutine.wrap(function()
for i = 1, 20 do
shockwave.Size = shockwave.Size + Vector3.new(1.8,1.8,1.8)
shockwave.Transparency = shockwave.Transparency + 0.05
wait()
end
end)()
SOUND(Torso,1072606965,0,false,10)
coroutine.wrap(function()
for i = 1, 10 do
so.Volume = so.Volume + 0.3
wait()
end
end)()
for i = 1, 35 do
local Hit = damagealll(22,Torso.Position)	
for _,v in pairs(Hit) do			
v:FindFirstChildOfClass("Humanoid"):TakeDamage(math.random(17,35))
vel = Instance.new("BodyVelocity",v:FindFirstChild("Torso") or v:FindFirstChild("UpperTorso")) 
vel.maxForce = Vector3.new(9999999999999,9999999999999,9999999999999)
torso = v:FindFirstChild("Torso") or v:FindFirstChild("UpperTorso")
vel.velocity = CFrame.new(Torso.Position,torso.Position).lookVector*20
removeuseless:AddItem(vel,.1)
end
wave = Instance.new("Part", Torso)
wave.Size = Vector3.new(1, 1, 1)
wave.Transparency = 0
wave.BrickColor = BrickColor.new("White")
wave.Anchored = true
wave.CanCollide = false
wave.CFrame = Root.CFrame * CFrame.new(0, -2.5, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0))
wavemesh = Instance.new("SpecialMesh", wave) 
wavemesh.MeshId = "rbxassetid://20329976" 
wavemesh.Scale = Vector3.new(1, 1, 1)
table.insert(th2,wave)
table.insert(SlowlyFade,wave)
table.insert(th5,wavemesh)
removeuseless:AddItem(wave,2)
CardStorm = Instance.new("Part",Torso)
CardStorm.Size = Vector3.new(.1,.1,.1)
CardStorm.CFrame = Root.CFrame * CFrame.new(0,3.2,0)
CardStorm.Anchored = true
CardStormMesh = Instance.new("SpecialMesh", CardStorm)
CardStormMesh.Scale = Vector3.new(1,1,1)
CardStormMesh.MeshId = "rbxassetid://6512150"
CardStormMesh.TextureId = "rbxassetid://55364685"
table.insert(SlowlyFade,CardStorm)
table.insert(m3,CardStormMesh)
table.insert(th1,CardStorm)
removeuseless:AddItem(CardStorm,3)
wait(.1)
end
coroutine.wrap(function()
for i = 1, 10 do
so.Volume = so.Volume - 0.3
wait()
end
end)()
wait(1)
ws = 10
clean()
attacking = false
debounce = false
appi = false
end
end)

mouse.KeyDown:connect(function(Press)
Press=Press:lower()
if Press=='e' then
if levitate then return end
if debounce then return end
attacking = true
debounce = true
damagedebounce = false
clickdisallowance = true
clickdebounce = false
notallowed = true
appi = true
ws = 0
coroutine.wrap(function()
while appi do
wait()
if Root.Velocity.y > 1 and attacking == true then
position = "Jump2"
elseif Root.Velocity.y < -1 and attacking == true then
position = "Falling2"
elseif Root.Velocity.Magnitude < 2 and attacking == true then
position = "Idle2"
elseif Root.Velocity.Magnitude > 2 and attacking == true then
position = "Walking2"
end
end
end)()
coroutine.wrap(function()
while appi do
wait()
settime = 0.05
sine = sine + change
if position == "Jump2" and attacking == true and appi == true then
change = 1
LEFTLEGLERP.C1 = LEFTLEGLERP.C1:lerp(CFrame.new(0,0,0) * CFrame.Angles(0,0,0),.1)
RIGHTLEGLERP.C1 = RIGHTLEGLERP.C1:lerp(CFrame.new(0,0,0) * CFrame.Angles(math.rad(0),0,0),.1)
RIGHTARMLERP.C1 = RIGHTARMLERP.C1:lerp(CFrame.new(0,0,0) * CFrame.Angles(0,0,0),.4)
ROOTLERP.C0 = ROOTLERP.C0:lerp(CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0)), 0.4)
RIGHTARMLERP.C0 = RIGHTARMLERP.C0:lerp(CFrame.new(-1.4,.1,-.2) * CFrame.Angles(math.rad(20),math.rad(3),math.rad(4)), 0.4)
RIGHTLEGLERP.C0 = RIGHTLEGLERP.C0:lerp(CFrame.new(-0.5, 2, 0) * CFrame.Angles(math.rad(10), math.rad(0), math.rad(0)), 0.4)
LEFTLEGLERP.C0 = LEFTLEGLERP.C0:lerp(CFrame.new(0.5, 1.0, .9) * CFrame.Angles(math.rad(20), math.rad(0), math.rad(0)), 0.4)
elseif position == "Falling2" and attacking == true and appi == true then
change = 1
LEFTLEGLERP.C1 = LEFTLEGLERP.C1:lerp(CFrame.new(0,0,0) * CFrame.Angles(0,0,0),.1)
RIGHTLEGLERP.C1 = RIGHTLEGLERP.C1:lerp(CFrame.new(0,0,0) * CFrame.Angles(math.rad(0),0,0),.1)
RIGHTARMLERP.C1 = RIGHTARMLERP.C1:lerp(CFrame.new(0,0,0) * CFrame.Angles(0,0,0),.4)
RIGHTLEGLERP.C0 = RIGHTLEGLERP.C0:lerp(CFrame.new(-0.5, 2, 0) * CFrame.Angles(math.rad(8), math.rad(4), math.rad(0)), 0.2)
LEFTLEGLERP.C0 = LEFTLEGLERP.C0:lerp(CFrame.new(0.5, 1.0, .9) * CFrame.Angles(math.rad(14), math.rad(-4), math.rad(0)), 0.2)
RIGHTARMLERP.C0 = RIGHTARMLERP.C0:lerp(CFrame.new(-1.6, 0.5, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(-20)), 0.2)
elseif position == "Idle2" and attacking == true and appi == true then
change = .4
LEFTLEGLERP.C1 = LEFTLEGLERP.C1:lerp(CFrame.new(0,0,0) * CFrame.Angles(0,0,0),.1)
RIGHTLEGLERP.C1 = RIGHTLEGLERP.C1:lerp(CFrame.new(0,0,0) * CFrame.Angles(math.rad(0),0,0),.1)
RIGHTARMLERP.C0 = RIGHTARMLERP.C0:lerp(CFrame.new(-1.5,.6,-.5) * CFrame.Angles(math.rad(32),math.rad(5 - 1 * math.sin(sine/12)),math.rad(40 - 2 * math.sin(sine/12))), 0.3)
RIGHTARMLERP.C1 = RIGHTARMLERP.C1:lerp(CFrame.new(-.2,1.2,-.3),.3)
ROOTLERP.C0 = ROOTLERP.C0:lerp(CFrame.new(0, -.2 + -.1 * math.sin(sine/12), 0) * CFrame.Angles(math.rad(0),math.rad(25),math.rad(0)),.3)
RIGHTLEGLERP.C0 = RIGHTLEGLERP.C0:lerp(CFrame.new(-0.3, 2, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(-10)), 0.3)
LEFTLEGLERP.C0 = LEFTLEGLERP.C0:lerp(CFrame.new(0.3, 2.0, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(10)), 0.3)
elseif position == "Walking2" and attacking == true and appi == true then
change = .8
LEFTLEGLERP.C1 = LEFTLEGLERP.C1:lerp(CFrame.new(0,0,0) * CFrame.Angles(0,0,0),.1)
RIGHTLEGLERP.C1 = RIGHTLEGLERP.C1:lerp(CFrame.new(0,0,0) * CFrame.Angles(math.rad(0),0,0),.1)
RIGHTARMLERP.C0 = RIGHTARMLERP.C0:lerp(CFrame.new(-1.5,.6,-.5) * CFrame.Angles(math.rad(32),math.rad(5 - 1 * math.sin(sine/12)),math.rad(40 - 2 * math.sin(sine/12))), 0.3)
RIGHTARMLERP.C1 = RIGHTARMLERP.C1:lerp(CFrame.new(-.2,1.2,-.3),.3)
ROOTLERP.C0 = ROOTLERP.C0:lerp(CFrame.new(0,0,0) * CFrame.Angles(0,0,math.rad(0) + Root.RotVelocity.Y/30,math.sin(25*math.sin(sine/8))),.3)
RIGHTLEGLERP.C0 = RIGHTLEGLERP.C0:lerp(CFrame.new(-0.5, 1.92 - 0.35 * math.sin(sine/8)/2.8, 0.2 - math.sin(sine/8)/3.4) * CFrame.Angles(math.rad(10) + -math.sin(sine/8)/2.3, math.rad(0)*math.sin(sine/1), math.rad(0)  + RightLeg.RotVelocity.Y / 30, math.sin(25 * math.sin(sine/8))), 0.3)
LEFTLEGLERP.C0 = LEFTLEGLERP.C0:lerp(CFrame.new(0.5, 1.92 + 0.35 * math.sin(sine/8)/2.8, 0.2 + math.sin(sine/8)/3.4) * CFrame.Angles(math.rad(10) - -math.sin(sine/8)/2.3, math.rad(0)*math.sin(sine/1), math.rad(0)  + LeftLeg.RotVelocity.Y / 30, math.sin(25 * math.sin(sine/8))), 0.3)
end
end
end)()
coroutine.wrap(function()
for i = 1, 40 do
LEFTARMLERP.C1 = LEFTARMLERP.C1:lerp(CFrame.new(0,0,0),.5)
LEFTARMLERP.C0 = LEFTARMLERP.C0:lerp(CFrame.new(1.2,1.5,0) * CFrame.Angles(math.rad(180 - 7 * math.sin(sine/6)),math.rad(7 * math.sin(sine/6)),math.rad(7*math.sin(sine/6))), 0.5)
swait()
end
end)()
haloh = Instance.new("Part", Torso)
haloh.Size = Vector3.new(1,1,1)
haloh.Anchored = false
haloh.Transparency = 1
haloh.CanCollide = false
halohweld = weldBetween(haloh,Torso)
halohweld.C0 = CFrame.new(0,0,0)
n = 0
x = 0
tab={}
tab2={}
SOUND(Torso,1882057730,6,false,2)
for i = 1, 20 do
n = n + 20
x = x + 5
halo = Instance.new("Part", Torso)
halo.Size = Vector3.new(0.71, 0.07, 0.99)
halo.Transparency = 1
halo.CanCollide = false
halo.Material = "Neon"
halo.BrickColor = BrickColor.new("White")
halow = weldBetween(halo,haloh)
halow.C0 = CFrame.new(-4,0,0) * CFrame.Angles(math.rad(90),math.rad(n),math.rad(0))
table.insert(FadeIn,halo)
table.insert(tab,halow)
table.insert(tab2,halo)
wait()
end
ws = 10
clickdisallowance = false
coroutine.wrap(function()
g1 = Instance.new("BodyGyro", Root)
g1.D = 175
g1.P = 20000
g1.MaxTorque = Vector3.new(0,9000,0)
while notallowed do
ROOTLERP.C0 = ROOTLERP.C0:lerp(CFrame.new(0, -.2, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0)), 0.3)
g1.CFrame = g1.CFrame:lerp(CFrame.new(Root.Position,mouse.Hit.p),.2)
LEFTARMLERP.C0 = LEFTARMLERP.C0:lerp(CFrame.new(1, 1.35, 0.4) * CFrame.Angles(math.rad(-90 - 2 * math.sin(sine/12)), math.rad(3), math.rad(4)), 0.3)
swait()
end
end)()
coroutine.wrap(function()
mouse.Button1Down:connect(function()
if clickdisallowance then return end
if clickdebounce then return end
wait(.2)
clickdebounce = true
notallowed = false
end)
end)()
while notallowed do
for i,v in pairs(tab) do
v.C0 = v.C0 * CFrame.Angles(math.rad(0),math.rad(0 + 1.2),math.rad(0))
end
swait()
end
appi = false
ws = 0
for i = 1, 15 do
RIGHTLEGLERP.C0 = RIGHTLEGLERP.C0:lerp(CFrame.new(-0.3, 2, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(-10)), 0.3)
LEFTLEGLERP.C0 = LEFTLEGLERP.C0:lerp(CFrame.new(0.3, 2.0, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(10)), 0.3)
ROOTLERP.C0 = ROOTLERP.C0:lerp(CFrame.new(0, -.2, 0) * CFrame.Angles(math.rad(0), math.rad(50), math.rad(0)), 0.3)
LEFTARMLERP.C0 = LEFTARMLERP.C0:lerp(CFrame.new(1, 1.35, 0.4) * CFrame.Angles(math.rad(-50 - 2 * math.sin(sine/12)), math.rad(12), math.rad(9)), 0.3)
LEFTARMLERP.C1 = LEFTARMLERP.C1:lerp(CFrame.new(-.65, .6, 1) * CFrame.Angles(0,0,0),.3)
swait()
end
for i,v in pairs(tab) do
v:Remove()
end
for i,v in pairs(tab2) do
removeuseless:AddItem(v,6)
MAKETRAIL(v,Vector3.new(.1,0,0),Vector3.new(-.1,0,0),.8,ColorSequence.new(BrickColor.new("White").Color,BrickColor.new("Really black").Color))
BodyGyro=Instance.new('BodyGyro',v)
BodyGyro.maxTorque=Vector3.new(math.huge,math.huge,math.huge)
BodyGyro.P=2e4
removeuseless:AddItem(BodyGyro,.1)
PB2 = Instance.new("BodyVelocity", v)
PB2.MaxForce = Vector3.new(999999, 999999, 999999)
v.CFrame = CFrame.new(v.Position,mouse.Hit.p)
PB2.Velocity = v.CFrame.lookVector * 80
end
SOUND(Torso,1499747506,3,false,1)
for i,v in pairs(tab2) do
v.Touched:connect(function(hit)
if hit.Parent:IsA("Part") then
elseif hit.Parent:IsA("SpecialMesh") then
elseif hit.Parent.Name == game.Players.LocalPlayer.Name then
elseif hit.Parent:findFirstChildOfClass("Humanoid") then
if damagedebounce == true then return end
damagedebounce = true
Slachtoffer = hit.Parent:findFirstChildOfClass("Humanoid")
tor = hit.Parent:FindFirstChild("Torso") or hit.Parent:FindFirstChild("UpperTorso")
Slachtoffer:TakeDamage(math.random(17,35))
SOUND(tor,694703797,6,false,1)
wait(.1)
damagedebounce = false
end
end)
end
for i = 1, 20 do
RIGHTLEGLERP.C0 = RIGHTLEGLERP.C0:lerp(CFrame.new(-0.3, 2, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(-10)), 0.3)
LEFTLEGLERP.C0 = LEFTLEGLERP.C0:lerp(CFrame.new(0.3, 2.0, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(10)), 0.3)
ROOTLERP.C0 = ROOTLERP.C0:lerp(CFrame.new(0, -.2, 0) * CFrame.Angles(math.rad(0), math.rad(-25), math.rad(0)), 0.3)
LEFTARMLERP.C1 = LEFTARMLERP.C1:lerp(CFrame.new(0,0,0) * CFrame.Angles(0,0,0),.3)
LEFTARMLERP.C0 = LEFTARMLERP.C0:lerp(CFrame.new(1, 1.35, 0.4) * CFrame.Angles(math.rad(-90 - 2 * math.sin(sine/12)), math.rad(-15), math.rad(4)), 0.3)
swait()
end
clean()
g1:Remove()
haloh:Remove()
attacking = false
debounce = false
damagedebounce = false
clickdebounce = false
appi = false
ws = 10
end
end)

mouse.KeyDown:connect(function(Press)
Press=Press:lower()
if Press=='y' then
if levitate then return end
if debounce then return end
clickdisallowance = true
clickdebounce = false
debounce = true
attacking = true
appi = true
ws = 0
coroutine.wrap(function()
while appi do
wait()
if Root.Velocity.y > 1 and attacking == true then
position = "Jump2"
elseif Root.Velocity.y < -1 and attacking == true then
position = "Falling2"
elseif Root.Velocity.Magnitude < 2 and attacking == true then
position = "Idle2"
elseif Root.Velocity.Magnitude > 2 and attacking == true then
position = "Walking2"
end
end
end)()
coroutine.wrap(function()
while appi do
wait()
settime = 0.05
sine = sine + change
if position == "Jump2" and attacking == true and appi == true then
change = 1
LEFTLEGLERP.C1 = LEFTLEGLERP.C1:lerp(CFrame.new(0,0,0) * CFrame.Angles(0,0,0),.1)
RIGHTLEGLERP.C1 = RIGHTLEGLERP.C1:lerp(CFrame.new(0,0,0) * CFrame.Angles(math.rad(0),0,0),.1)
LEFTARMLERP.C1 = LEFTARMLERP.C1:lerp(CFrame.new(0,0,0) * CFrame.Angles(0,0,0),.4)
ROOTLERP.C0 = ROOTLERP.C0:lerp(CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0)), 0.4)
LEFTARMLERP.C0 = LEFTARMLERP.C0:lerp(CFrame.new(1.4,.1,-.2) * CFrame.Angles(math.rad(20),math.rad(-3),math.rad(-4)), 0.4)
RIGHTLEGLERP.C0 = RIGHTLEGLERP.C0:lerp(CFrame.new(-0.5, 2, 0) * CFrame.Angles(math.rad(10), math.rad(0), math.rad(0)), 0.4)
LEFTLEGLERP.C0 = LEFTLEGLERP.C0:lerp(CFrame.new(0.5, 1.0, .9) * CFrame.Angles(math.rad(20), math.rad(0), math.rad(0)), 0.4)
elseif position == "Falling2" and attacking == true and appi == true then
change = 1
LEFTLEGLERP.C1 = LEFTLEGLERP.C1:lerp(CFrame.new(0,0,0) * CFrame.Angles(0,0,0),.1)
RIGHTLEGLERP.C1 = RIGHTLEGLERP.C1:lerp(CFrame.new(0,0,0) * CFrame.Angles(math.rad(0),0,0),.1)
LEFTARMLERP.C1 = LEFTARMLERP.C1:lerp(CFrame.new(0,0,0) * CFrame.Angles(0,0,0),.4)
RIGHTLEGLERP.C0 = RIGHTLEGLERP.C0:lerp(CFrame.new(-0.5, 2, 0) * CFrame.Angles(math.rad(8), math.rad(4), math.rad(0)), 0.2)
LEFTLEGLERP.C0 = LEFTLEGLERP.C0:lerp(CFrame.new(0.5, 1.0, .9) * CFrame.Angles(math.rad(14), math.rad(-4), math.rad(0)), 0.2)
LEFTARMLERP.C0 = LEFTARMLERP.C0:lerp(CFrame.new(1.6, 0.5, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(20)), 0.2)
elseif position == "Idle2" and attacking == true and appi == true then
change = .4
LEFTLEGLERP.C1 = LEFTLEGLERP.C1:lerp(CFrame.new(0,0,0) * CFrame.Angles(0,0,0),.1)
RIGHTLEGLERP.C1 = RIGHTLEGLERP.C1:lerp(CFrame.new(0,0,0) * CFrame.Angles(math.rad(0),0,0),.1)
LEFTARMLERP.C0 = LEFTARMLERP.C0:lerp(CFrame.new(1.5,.6,-.5) * CFrame.Angles(math.rad(30),math.rad(-5 + 1 * math.sin(sine/12)),math.rad(-40 + 2 * math.sin(sine/12))), 0.3)
LEFTARMLERP.C1 = LEFTARMLERP.C1:lerp(CFrame.new(.2,1.2,-.3),.3)
ROOTLERP.C0 = ROOTLERP.C0:lerp(CFrame.new(0, -.2 + -.1 * math.sin(sine/12), 0) * CFrame.Angles(math.rad(0),math.rad(25),math.rad(0)),.3)
RIGHTLEGLERP.C0 = RIGHTLEGLERP.C0:lerp(CFrame.new(-0.3, 2 - .1 * math.sin(sine/12), 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(-10)), 0.3)
LEFTLEGLERP.C0 = LEFTLEGLERP.C0:lerp(CFrame.new(0.3, 2.0 - .1 * math.sin(sine/12), 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(10)), 0.3)
elseif position == "Walking2" and attacking == true and appi == true then
change = .8
LEFTLEGLERP.C1 = LEFTLEGLERP.C1:lerp(CFrame.new(0,0,0) * CFrame.Angles(0,0,0),.1)
RIGHTLEGLERP.C1 = RIGHTLEGLERP.C1:lerp(CFrame.new(0,0,0) * CFrame.Angles(math.rad(0),0,0),.1)
LEFTARMLERP.C0 = LEFTARMLERP.C0:lerp(CFrame.new(1.5,.6,-.5) * CFrame.Angles(math.rad(30),math.rad(-5 + 1 * math.sin(sine/12)),math.rad(-40 + 2 * math.sin(sine/12))), 0.3)
LEFTARMLERP.C1 = LEFTARMLERP.C1:lerp(CFrame.new(.2,1.2,-.3),.3)
ROOTLERP.C0 = ROOTLERP.C0:lerp(CFrame.new(0,0,0) * CFrame.Angles(0,0,math.rad(0) + Root.RotVelocity.Y/30,math.cos(25*math.cos(sine/8))),.3)
RIGHTLEGLERP.C0 = RIGHTLEGLERP.C0:lerp(CFrame.new(-0.5, 1.92 - 0.35 * math.cos(sine/8)/2.8, 0.2 - math.sin(sine/8)/3.4) * CFrame.Angles(math.rad(10) + -math.sin(sine/8)/2.3, math.rad(0)*math.cos(sine/1), math.rad(0)  + RightLeg.RotVelocity.Y / 30, math.cos(25 * math.cos(sine/8))), 0.3)
LEFTLEGLERP.C0 = LEFTLEGLERP.C0:lerp(CFrame.new(0.5, 1.92 + 0.35 * math.cos(sine/8)/2.8, 0.2 + math.sin(sine/8)/3.4) * CFrame.Angles(math.rad(10) - -math.sin(sine/8)/2.3, math.rad(0)*math.cos(sine/1), math.rad(0)  + LeftLeg.RotVelocity.Y / 30, math.cos(25 * math.cos(sine/8))), 0.3)
end
end
end)()
bigcard = Instance.new("Part",Torso)
bigcard.Material = "Neon"
bigcard.Transparency = 1
bigcard.BrickColor = BrickColor.new("White")
bigcard.Size = Vector3.new(15.65, 23.84, 0.3)
bigcard.CFrame = Root.CFrame * CFrame.new(0,18,0)
bigcard.Anchored = true
SOUND(bigcard,236989198,6,false,1)
ace = aces[math.random(1,#aces)]
acer = Instance.new("Decal",bigcard)
acer.Texture = "rbxassetid://"..ace
acer.Transparency = 1
acer.Face = "Front"
ace2 = acer:Clone()
ace2.Parent = bigcard
ace2.Face = "Back"
table.insert(FadeIn,acer)
table.insert(FadeIn,ace2)
table.insert(FadeIn,bigcard)
for i = 1, 30 do
RIGHTARMLERP.C1 = RIGHTARMLERP.C1:lerp(CFrame.new(0,1.5,-.1),.5)
RIGHTARMLERP.C0 = RIGHTARMLERP.C0:lerp(CFrame.new(-1.5,0,0) * CFrame.Angles(math.rad(180),math.rad(10),math.rad(10)),.3)
swait()
end
ws = 10
g1 = Instance.new("BodyGyro", Root)
g1.D = 175
g1.P = 20000
g1.MaxTorque = Vector3.new(0,9000,0)
clickdisallowance = false
coroutine.wrap(function()
mouse.Button1Down:connect(function()
if clickdisallowance then return end
if clickdebounce then return end
wait(.2)
clickdebounce = true
end)
end)()
while not clickdebounce do
g1.CFrame = g1.CFrame:lerp(CFrame.new(Root.Position,mouse.Hit.p),.2)
bigcard.CFrame = Root.CFrame * CFrame.new(0,18,0)
RIGHTARMLERP.C0 = RIGHTARMLERP.C0:lerp(CFrame.new(-1.5,0,0) * CFrame.Angles(math.rad(180),math.rad(10 + 2 *math.sin(sine/12)),math.rad(10 - 2*math.sin(sine/12))),.3)
swait()
end
g1:Remove()
ws = 0
for i = 1, 13 do
bigcard.CFrame = bigcard.CFrame:lerp(Root.CFrame * CFrame.new(0,18,3) * CFrame.Angles(math.rad(10),0,0),.3)
RIGHTARMLERP.C0 = RIGHTARMLERP.C0:lerp(CFrame.new(-1.5,0,0.2) * CFrame.Angles(math.rad(160),math.rad(10),math.rad(10)),.3)
swait()
end
locationpart = Instance.new("Part",bigcard)
locationpart.Size = Vector3.new(1,1,1)
locationpart.Transparency = 1
locationpart.CanCollide = false
locationpart.Anchored = true
locationpart.CFrame = Root.CFrame * CFrame.new(0,-3,-21)
shockwave = Instance.new("Part", Torso)
shockwave.Size = Vector3.new(1,1,1)
shockwave.CanCollide = false
shockwave.Anchored = true
shockwave.Transparency = 0
shockwave.BrickColor = BrickColor.new("White")
shockwave.CFrame = CFrame.new(locationpart.Position)
shockwavemesh = Instance.new("SpecialMesh", shockwave)
shockwavemesh.Scale = Vector3.new(5,2,5)
shockwavemesh.MeshId = "rbxassetid://20329976"
removeuseless:AddItem(shockwave,4)
shockwave2 = Instance.new("Part", Torso)
shockwave2.Size = Vector3.new(1,1,1)
shockwave2.CanCollide = false
shockwave2.Anchored = true
shockwave2.Transparency = 0
shockwave2.BrickColor = BrickColor.new("White")
shockwave2.CFrame = CFrame.new(locationpart.Position)
shockwavemesh2 = Instance.new("SpecialMesh", shockwave2)
shockwavemesh2.Scale = Vector3.new(5,2,5)
shockwavemesh2.MeshId = "rbxassetid://20329976"
removeuseless:AddItem(shockwave2,4)
shockwave3 = Instance.new("Part", Torso)
shockwave3.Size = Vector3.new(1,1,1)
shockwave3.CanCollide = false
shockwave3.Anchored = true
shockwave3.Transparency = 0
shockwave3.BrickColor = BrickColor.new("White")
shockwave3.CFrame = CFrame.new(locationpart.Position)
shockwavemesh3 = Instance.new("SpecialMesh", shockwave3)
shockwavemesh3.Scale = Vector3.new(5,2,5)
shockwavemesh3.MeshId = "rbxassetid://20329976"
removeuseless:AddItem(shockwave3,4)
shockwave4 = Instance.new("Part", Torso)
shockwave4.Size = Vector3.new(1,1,1)
shockwave4.CanCollide = false
shockwave4.Anchored = true
shockwave4.Transparency = 0
shockwave4.BrickColor = BrickColor.new("White")
shockwave4.CFrame = CFrame.new(locationpart.Position)
shockwavemesh4 = Instance.new("SpecialMesh", shockwave4)
shockwavemesh4.Scale = Vector3.new(5,2,5)
shockwavemesh4.MeshId = "rbxassetid://20329976"
removeuseless:AddItem(shockwave4,4)
Hit = damagealll(20,locationpart.Position)
for _,v in pairs(Hit) do			
v:FindFirstChildOfClass("Humanoid"):TakeDamage(math.random(55,85))
vel = Instance.new("BodyVelocity",v:FindFirstChild("Torso") or v:FindFirstChild("UpperTorso")) 
vel.maxForce = Vector3.new(9999999999999,9999999999999,9999999999999)
torso = v:FindFirstChild("Torso") or v:FindFirstChild("UpperTorso")
vel.velocity = CFrame.new(locationpart.Position,torso.Position).lookVector*110
removeuseless:AddItem(vel,.1)
end
coroutine.wrap(function()
for i = 1, 90 do
shockwave.CFrame = shockwave.CFrame * CFrame.Angles(0,math.rad(0+12),0)
shockwavemesh.Scale = shockwavemesh.Scale + Vector3.new(1.5,.1,1.5)
shockwave.Transparency = shockwave.Transparency + 0.025
shockwave2.CFrame = shockwave2.CFrame * CFrame.Angles(0,math.rad(0+6),0)
shockwavemesh2.Scale = shockwavemesh2.Scale + Vector3.new(1.25,.25,1.25)
shockwave2.Transparency = shockwave2.Transparency + 0.04
shockwave3.CFrame = shockwave3.CFrame * CFrame.Angles(0,math.rad(0+12),0)
shockwavemesh3.Scale = shockwavemesh3.Scale + Vector3.new(.75,.75,.75)
shockwave3.Transparency = shockwave3.Transparency + 0.035
shockwave4.CFrame = shockwave3.CFrame * CFrame.Angles(0,math.rad(0+5),0)
shockwavemesh4.Scale = shockwavemesh3.Scale + Vector3.new(2.5,.5,2.5)
shockwave4.Transparency = shockwave3.Transparency + 0.03
swait()
end
end)()
SOUND(locationpart,765590102,6,false,2)
for i = 1, 24 do
bigcard.CFrame = bigcard.CFrame:lerp(Root.CFrame * CFrame.new(0,-3,-21) * CFrame.Angles(math.rad(90),0,0),.25)
RIGHTARMLERP.C1 = RIGHTARMLERP.C1:lerp(CFrame.new(.2,.2,.2) * CFrame.Angles(0,0,0),.5)
RIGHTARMLERP.C0 = RIGHTARMLERP.C0:lerp(CFrame.new(-1, 1.1, 0.4) * CFrame.Angles(math.rad(-75), math.rad(15), math.rad(4)), 0.5)
swait()
end
for i = 1, 40 do
bigcard.Transparency = bigcard.Transparency + 0.2
acer.Transparency = acer.Transparency + .2
ace2.Transparency = ace2.Transparency + .2
swait()
end
attacking = false
debounce = false
appi = false
clickdisallowance = false
clickdebounce = false
ws = 10
bigcard:Remove()
clean()
end
end)

mouse.KeyDown:connect(function(Press)
Press=Press:lower()
if Press=='u' then
if levitate then return end
if mouse.Target ~= nil then end
if debounce then return end
debounce = true
attacking = true
appi = true
ws = 0
appi = true
coroutine.wrap(function()
while appi do
wait()
if Root.Velocity.y > 1 and attacking == true then
position = "Jump2"
elseif Root.Velocity.y < -1 and attacking == true then
position = "Falling2"
elseif Root.Velocity.Magnitude < 2 and attacking == true then
position = "Idle2"
elseif Root.Velocity.Magnitude > 2 and attacking == true then
position = "Walking2"
end
end
end)()
coroutine.wrap(function()
while appi do
wait()
settime = 0.05
sine = sine + change
if position == "Jump2" and attacking == true and appi == true then
change = 1
LEFTLEGLERP.C1 = LEFTLEGLERP.C1:lerp(CFrame.new(0,0,0) * CFrame.Angles(0,0,0),.1)
RIGHTLEGLERP.C1 = RIGHTLEGLERP.C1:lerp(CFrame.new(0,0,0) * CFrame.Angles(math.rad(0),0,0),.1)
LEFTARMLERP.C1 = LEFTARMLERP.C1:lerp(CFrame.new(0,0,0) * CFrame.Angles(0,0,0),.4)
ROOTLERP.C0 = ROOTLERP.C0:lerp(CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0)), 0.4)
LEFTARMLERP.C0 = LEFTARMLERP.C0:lerp(CFrame.new(1.4,.1,-.2) * CFrame.Angles(math.rad(20),math.rad(-3),math.rad(-4)), 0.4)
RIGHTLEGLERP.C0 = RIGHTLEGLERP.C0:lerp(CFrame.new(-0.5, 2, 0) * CFrame.Angles(math.rad(10), math.rad(0), math.rad(0)), 0.4)
LEFTLEGLERP.C0 = LEFTLEGLERP.C0:lerp(CFrame.new(0.5, 1.0, .9) * CFrame.Angles(math.rad(20), math.rad(0), math.rad(0)), 0.4)
elseif position == "Falling2" and attacking == true and appi == true then
change = 1
LEFTLEGLERP.C1 = LEFTLEGLERP.C1:lerp(CFrame.new(0,0,0) * CFrame.Angles(0,0,0),.1)
RIGHTLEGLERP.C1 = RIGHTLEGLERP.C1:lerp(CFrame.new(0,0,0) * CFrame.Angles(math.rad(0),0,0),.1)
LEFTARMLERP.C1 = LEFTARMLERP.C1:lerp(CFrame.new(0,0,0) * CFrame.Angles(0,0,0),.4)
RIGHTLEGLERP.C0 = RIGHTLEGLERP.C0:lerp(CFrame.new(-0.5, 2, 0) * CFrame.Angles(math.rad(8), math.rad(4), math.rad(0)), 0.2)
LEFTLEGLERP.C0 = LEFTLEGLERP.C0:lerp(CFrame.new(0.5, 1.0, .9) * CFrame.Angles(math.rad(14), math.rad(-4), math.rad(0)), 0.2)
LEFTARMLERP.C0 = LEFTARMLERP.C0:lerp(CFrame.new(1.6, 0.5, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(20)), 0.2)
elseif position == "Idle2" and attacking == true and appi == true then
change = .4
LEFTLEGLERP.C1 = LEFTLEGLERP.C1:lerp(CFrame.new(0,0,0) * CFrame.Angles(0,0,0),.1)
RIGHTLEGLERP.C1 = RIGHTLEGLERP.C1:lerp(CFrame.new(0,0,0) * CFrame.Angles(math.rad(0),0,0),.1)
LEFTARMLERP.C0 = LEFTARMLERP.C0:lerp(CFrame.new(1.5,.6,-.5) * CFrame.Angles(math.rad(30),math.rad(-5 + 1 * math.sin(sine/12)),math.rad(-40 + 2 * math.sin(sine/12))), 0.3)
LEFTARMLERP.C1 = LEFTARMLERP.C1:lerp(CFrame.new(.2,1.2,-.3),.3)
ROOTLERP.C0 = ROOTLERP.C0:lerp(CFrame.new(0, -.2 + -.1 * math.sin(sine/12), 0) * CFrame.Angles(math.rad(0),math.rad(25),math.rad(0)),.3)
RIGHTLEGLERP.C0 = RIGHTLEGLERP.C0:lerp(CFrame.new(-0.3, 2 - .1 * math.sin(sine/12), 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(-10)), 0.3)
LEFTLEGLERP.C0 = LEFTLEGLERP.C0:lerp(CFrame.new(0.3, 2.0 - .1 * math.sin(sine/12), 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(10)), 0.3)
elseif position == "Walking2" and attacking == true and appi == true then
change = .8
LEFTLEGLERP.C1 = LEFTLEGLERP.C1:lerp(CFrame.new(0,0,0) * CFrame.Angles(0,0,0),.1)
RIGHTLEGLERP.C1 = RIGHTLEGLERP.C1:lerp(CFrame.new(0,0,0) * CFrame.Angles(math.rad(0),0,0),.1)
LEFTARMLERP.C0 = LEFTARMLERP.C0:lerp(CFrame.new(1.5,.6,-.5) * CFrame.Angles(math.rad(30),math.rad(-5 + 1 * math.sin(sine/12)),math.rad(-40 + 2 * math.sin(sine/12))), 0.3)
LEFTARMLERP.C1 = LEFTARMLERP.C1:lerp(CFrame.new(.2,1.2,-.3),.3)
ROOTLERP.C0 = ROOTLERP.C0:lerp(CFrame.new(0,0,0) * CFrame.Angles(0,0,math.rad(0) + Root.RotVelocity.Y/30,math.cos(25*math.cos(sine/8))),.3)
RIGHTLEGLERP.C0 = RIGHTLEGLERP.C0:lerp(CFrame.new(-0.5, 1.92 - 0.35 * math.cos(sine/8)/2.8, 0.2 - math.sin(sine/8)/3.4) * CFrame.Angles(math.rad(10) + -math.sin(sine/8)/2.3, math.rad(0)*math.cos(sine/1), math.rad(0)  + RightLeg.RotVelocity.Y / 30, math.cos(25 * math.cos(sine/8))), 0.3)
LEFTLEGLERP.C0 = LEFTLEGLERP.C0:lerp(CFrame.new(0.5, 1.92 + 0.35 * math.cos(sine/8)/2.8, 0.2 + math.sin(sine/8)/3.4) * CFrame.Angles(math.rad(10) - -math.sin(sine/8)/2.3, math.rad(0)*math.cos(sine/1), math.rad(0)  + LeftLeg.RotVelocity.Y / 30, math.cos(25 * math.cos(sine/8))), 0.3)
end
end
end)()
g1 = Instance.new("BodyGyro", Root)
g1.D = 175
g1.P = 20000
g1.MaxTorque = Vector3.new(0,9000,0)
g1.CFrame = CFrame.new(Root.Position,mouse.Hit.p)
for i = 1, 15 do
g1.CFrame = g1.CFrame:lerp(CFrame.new(Root.Position,mouse.Hit.p),.2)
RIGHTARMLERP.C1 = RIGHTARMLERP.C1:lerp(CFrame.new(0,1.5,-.1),.5)
RIGHTARMLERP.C0 = RIGHTARMLERP.C0:lerp(CFrame.new(-1.5,0,0) * CFrame.Angles(math.rad(180),math.rad(10),math.rad(10)),.3)
swait()
end
cardportal = Instance.new("Part", Torso)
cardportal.Size = Vector3.new(0.5, 0.5, 0.5)
cardportal.Material = "Neon"
cardportal.BrickColor = BrickColor.new("White")
cardportal.Transparency = 0
cardportal.Anchored = true
cardportal.CanCollide = false
cardportalMESH = Instance.new("SpecialMesh", cardportal)
cardportalMESH.MeshType = "Cylinder"
cardportalMESH.Scale = Vector3.new(.2,0.01,0.01)
cardportal.CFrame = CFrame.new(mouse.Hit.p) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(90))
for i = 1, 10 do
cardportalMESH.Scale = cardportalMESH.Scale + Vector3.new(0,4,4)
swait()
end
bigzcard = Instance.new("Part",Torso)
bigzcard.Material = "Neon"
bigzcard.Transparency = 0
bigzcard.BrickColor = BrickColor.new("White")
bigzcard.Size = Vector3.new(10, 15, 0.3)
bigzcard.CFrame = cardportal.CFrame * CFrame.new(-8,0,0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(90))
bigzcard.Anchored = true
SOUND(bigzcard,1888686669,6,false,1)
acer = Instance.new("Decal",bigzcard)
acer.Texture = "rbxassetid://1881287656"
acer.Transparency = 0
acer.Face = "Front"
ace2 = acer:Clone()
ace2.Parent = bigzcard
ace2.Face = "Back"
spinning = true
coroutine.wrap(function()
while spinning do
bigzcard.CFrame = bigzcard.CFrame * CFrame.Angles(0,math.rad(0+5),0)
swait()
end
end)()
for i = 1, 20 do
bigzcard.CFrame = bigzcard.CFrame * CFrame.new(0,-.9,0)
swait()
end
coroutine.wrap(function()
for i = 1, 10 do
cardportalMESH.Scale = cardportalMESH.Scale - Vector3.new(0,4,4)
swait()
end
cardportal:Remove()
end)()
wait(.7)
ace3 = Instance.new("Decal",bigzcard)
ace3.Texture = "rbxassetid://1880203893"
ace3.Transparency = 1
ace3.Face = "Front"
ace4 = ace3:Clone()
ace4.Parent = bigzcard
ace4.Face = "Back"
bigzcard2 = Instance.new("Part",Torso)
bigzcard2.Material = "Neon"
bigzcard2.Transparency = 1
bigzcard2.BrickColor = BrickColor.new("Really black")
bigzcard2.Size = Vector3.new(10, 15, 0.29)
bigzcard2.CFrame = bigzcard.CFrame
bigzcard2.CanCollide = false
bigzcard2.Anchored = true
coroutine.wrap(function()
while spinning do
bigzcard2.CFrame = bigzcard2.CFrame * CFrame.Angles(0,math.rad(0+5),0)
swait()
end
end)()
blz = bl[math.random(1,#bl)]
woos = Instance.new("Sound",Torso)
woos.SoundId = "rbxassetid://"..blz
woos.Volume = 4
woos:Play()
for i = 1, 20 do
bigzcard2.Transparency = bigzcard2.Transparency - .05
bigzcard.Transparency = bigzcard.Transparency + .05
ace3.Transparency = ace3.Transparency - 0.05
ace4.Transparency = ace4.Transparency - 0.05
acer.Transparency = acer.Transparency + 0.05
ace2.Transparency = ace2.Transparency + 0.05
wait()
end
ace3.Parent = bigzcard2
ace3.Face = "Front"
ace4.Parent = bigzcard2
ace4.Face = "Back"
bigzcard:Remove()
spinning = false
blackholeactive = true
coroutine.wrap(function()
blackhole={}
orbzfade={}
for i = 1, 100 do
orbz = Instance.new("Part", Torso)
orbz.Shape = "Ball"
orbz.Material = "Neon"
orbz.BrickColor = BrickColor.new("Really black")
orbz.Size = Vector3.new(2,2,2)
orbz.Anchored = true
orbz.CanCollide = false
removeuseless:AddItem(orbz,1)
orbz.CFrame = bigzcard2.CFrame * CFrame.new(math.random(-25,25),math.random(-25,25),math.random(-25,25)) * CFrame.Angles(math.rad(-180,180),math.rad(-180,180),math.rad(-180,180))
table.insert(blackhole,orbz)
table.insert(orbzfade,orbz)
for i,v in pairs(blackhole) do
v.CFrame = v.CFrame:lerp(CFrame.new(bigzcard2.Position),.05)
end
for i,v in pairs(orbzfade) do
v.Transparency = v.Transparency + 0.025
end
swait()
end
end)()
coroutine.wrap(function()
while blackholeactive do
local Hit = damagealll(45,bigzcard2.Position)		
for _,v in pairs(Hit) do
coroutine.wrap(function()
wait(.15)
if blackholeactive == false then return end
v:FindFirstChildOfClass("Humanoid"):TakeDamage(math.random(.1,1))
end)()		
torso = v:FindFirstChild("Torso") or v:FindFirstChild("UpperTorso")
torso.CFrame = torso.CFrame:lerp(CFrame.new(bigzcard2.Position),.1)
end
wait()
end
end)()
for i = 1, 100 do
bigzcard2.CFrame = bigzcard2.CFrame * CFrame.Angles(0,math.rad(0+20),0)
cataclysmics = Instance.new("Part", Torso)
cataclysmics.Shape = "Ball"
cataclysmics.Material = "Neon"
cataclysmics.BrickColor = BrickColor.new("Really black")
cataclysmics.Size = Vector3.new(11,11,11)
cataclysmics.Transparency = .3
cataclysmics.Anchored = true
cataclysmics.CanCollide = false
cataclysmics.CFrame = CFrame.new(bigzcard2.Position)
table.insert(LessSize,cataclysmics)
table.insert(keyYtransparency,cataclysmics)
removeuseless:AddItem(cataclysmics,1)
swait()
end
coroutine.wrap(function()
for i = 1, 20 do
for i,v in pairs(orbzfade) do
v.Transparency = v.Transparency + 0.05
end
swait()
end
end)()
explosiontable={}
ringtable={}
ringtable2={}
soundboks = Instance.new("Part",Torso)
soundboks.CanCollide = false
soundboks.Anchored = true
soundboks.Transparency = 1
soundboks.CFrame = bigzcard2.CFrame
removeuseless:AddItem(soundboks,6)
SOUND(soundboks,472579737,6,false,1)
blackholeactive = false
bigzcard2:Remove()
Hit = damagealll(60,soundboks.Position)
for _,v in pairs(Hit) do			
v:FindFirstChildOfClass("Humanoid"):TakeDamage(math.random(36,55))
vel = Instance.new("BodyVelocity",v:FindFirstChild("Torso") or v:FindFirstChild("UpperTorso")) 
vel.maxForce = Vector3.new(9999999999999,9999999999999,9999999999999)
torso = v:FindFirstChild("Torso") or v:FindFirstChild("UpperTorso")
vel.velocity = CFrame.new(soundboks.Position,torso.Position).lookVector*200
removeuseless:AddItem(vel,.1)
end
coroutine.wrap(function()
shockwave = Instance.new("Part", Torso)
shockwave.Size = Vector3.new(1,1,1)
shockwave.CanCollide = false
shockwave.Anchored = true
shockwave.Transparency = 0
shockwave.BrickColor = BrickColor.new("Really black")
shockwave.CFrame = CFrame.new(soundboks.Position) * CFrame.new(0,-6,0)
shockwavemesh = Instance.new("SpecialMesh", shockwave)
shockwavemesh.Scale = Vector3.new(5,2,5)
shockwavemesh.MeshId = "rbxassetid://20329976"
shockwave2 = Instance.new("Part", Torso)
shockwave2.Size = Vector3.new(1,1,1)
shockwave2.CanCollide = false
shockwave2.Anchored = true
shockwave2.Transparency = 0
shockwave2.BrickColor = BrickColor.new("Really black")
shockwave2.CFrame = CFrame.new(soundboks.Position) * CFrame.new(0,-6,0)
shockwavemesh2 = Instance.new("SpecialMesh", shockwave2)
shockwavemesh2.Scale = Vector3.new(5,2,5)
shockwavemesh2.MeshId = "rbxassetid://20329976"
for i = 1, 40 do
shockwave.CFrame = shockwave.CFrame * CFrame.Angles(0,math.rad(0+15),0)
shockwave2.CFrame = shockwave2.CFrame * CFrame.Angles(0,math.rad(0+8),0)
shockwave.Transparency = shockwave.Transparency + 0.025
shockwave2.Transparency = shockwave2.Transparency + 0.025
shockwavemesh.Scale = shockwavemesh.Scale + Vector3.new(9,.9,9)
shockwavemesh2.Scale = shockwavemesh2.Scale + Vector3.new(8,.8,8)
swait()
end
shockwave:Remove()
shockwave2:Remove()
end)()	
for i = 1, 4 do
explosion = Instance.new("Part", Torso)
explosion.Shape = "Ball"
explosion.Size = Vector3.new(1,1,1)
explosion.Transparency = 0
explosion.CanCollide = false
explosion.Anchored = true
explosion.BrickColor = BrickColor.new("Really black")
explosion.Material = "Neon"
explosion.CFrame = CFrame.new(bigzcard2.Position)
table.insert(ExtremeM,explosion)
table.insert(SlowlyFade,explosion)
removeuseless:AddItem(explosion,4)
ring = Instance.new("Part", Torso)
ring.Size = Vector3.new(5, 5, 5)
ring.Transparency = 0
ring.BrickColor = BrickColor.new("Really black")
ring.Anchored = true
ring.CanCollide = false
ring.CFrame = bigzcard2.CFrame * CFrame.Angles(math.rad(math.random(-180,180)), math.rad(math.random(-180,180)), math.rad(math.random(-180,180)))
ringh = Instance.new("SpecialMesh", ring) 
ringh.MeshId = "http://www.roblox.com/asset/?id=3270017" 
ringh.Scale = Vector3.new(2, 2, .1)
table.insert(keyYsize,ringh)
table.insert(keyYtransparency,ring)
removeuseless:AddItem(ring,4)
swait()
end
wait(1.2)
clean()
keyYsize={}
keyYtransparency={}
blackholev = false
appi = false
g1:Remove()
ws = 10
attacking = false
debounce = false
end
end)

mouse.KeyDown:connect(function(Press)
Press=Press:lower()
if Press=='t' then
if levitate then
if tauntdebounce then return end
tauntdebounce = true
laughing = true
coroutine.wrap(function()
while laughing do
local b1 = Instance.new("BillboardGui",Head)
b1.Size = UDim2.new(0,4,0,1.6)
b1.StudsOffset = Vector3.new(0,0,0)
b1.Name = "laff"
b1.AlwaysOnTop = true
b1.Adornee = Head
removeuseless:AddItem(b1,3)
local b2 = Instance.new("TextLabel",b1)
b2.BackgroundTransparency = 1
b2.Text = "HaHaHaHaHaHa..."
b2.Font = "Garamond"
b2.TextSize = 0
b2.Name = "lafftext"
b2.TextStrokeTransparency = 0
b2.TextColor3 = BrickColor.new("Really red").Color
b2.TextStrokeColor3 = Color3.new(0,0,0)
b2.Size = UDim2.new(1,0,.5,0)
table.insert(laughingtable,b2)
removeuseless:AddItem(b1,2)
coroutine.wrap(function()
if zxc then return end
zxc = true
while true do
swait()
for i,v in pairs(Head:GetChildren()) do
if v.Name == "laff" then
v.StudsOffset = v.StudsOffset + Vector3.new(math.random(-2,2),.3,math.random(-2,2))
end
end
for i,v in pairs(laughingtable) do
v.TextTransparency = v.TextTransparency + .025
v.TextStrokeTransparency = v.TextStrokeTransparency + 0.25
v.TextSize = v.TextSize + 2
v.Rotation = v.Rotation + .1
end
end
end)()
swait(10)
end
end)()
laugh = laughs[math.random(1,#laughs)]
laughy = Instance.new("Sound",Head)
laughy.SoundId = "rbxassetid://"..laugh
laughy.Volume = 10
laughy:Play()
wait(1)
wait(laughy.TimeLength)
laughing = false
laughy:Remove()
tauntdebounce = false
else
if mouse.Target ~= nil then
if debounce then return end
attacking = true
ghost()
tps = Instance.new("Sound", Torso)
tps.Volume = 5
tps.SoundId = "rbxassetid://1894958339"
tps:Play()
removeuseless:AddItem(tps,2)
g1 = Instance.new("BodyGyro", Root)
g1.D = 175
g1.P = 20000
g1.MaxTorque = Vector3.new(0,9000,0)
g1.CFrame = CFrame.new(Root.Position,mouse.Hit.p)
removeuseless:AddItem(g1,.05)
Root.CFrame = CFrame.new(mouse.Hit.p) * CFrame.new(0,3.3,0)
wait(.1)
attacking = false
debounce = false
end
end
end
end)

mouse.KeyDown:connect(function(Press)
Press=Press:lower()
if Press=='q' then
if levitate then return end
if mouse.Target ~= nil and mouse.Target.Parent ~= Character and mouse.Target.Parent.Parent ~= Character and mouse.Target.Parent:FindFirstChildOfClass("Humanoid") ~= nil and mouse.Target.Parent:FindFirstChildOfClass("Humanoid").Health ~= 0 then
if debounce then return end
debounce = true
attacking = true
appi = true
ws = 0
coroutine.wrap(function()
while appi do
wait()
if Root.Velocity.y > 1 and attacking == true then
position = "Jump2"
elseif Root.Velocity.y < -1 and attacking == true then
position = "Falling2"
elseif Root.Velocity.Magnitude < 2 and attacking == true then
position = "Idle2"
elseif Root.Velocity.Magnitude > 2 and attacking == true then
position = "Walking2"
end
end
end)()
coroutine.wrap(function()
while appi do
wait()
settime = 0.05
sine = sine + change
if position == "Jump2" and attacking == true and appi == true then
change = 1
LEFTLEGLERP.C1 = LEFTLEGLERP.C1:lerp(CFrame.new(0,0,0) * CFrame.Angles(0,0,0),.1)
RIGHTLEGLERP.C1 = RIGHTLEGLERP.C1:lerp(CFrame.new(0,0,0) * CFrame.Angles(math.rad(0),0,0),.1)
RIGHTARMLERP.C1 = RIGHTARMLERP.C1:lerp(CFrame.new(0,0,0) * CFrame.Angles(0,0,0),.4)
ROOTLERP.C0 = ROOTLERP.C0:lerp(CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0)), 0.4)
RIGHTARMLERP.C0 = RIGHTARMLERP.C0:lerp(CFrame.new(-1.4,.1,-.2) * CFrame.Angles(math.rad(20),math.rad(3),math.rad(4)), 0.4)
RIGHTLEGLERP.C0 = RIGHTLEGLERP.C0:lerp(CFrame.new(-0.5, 2, 0) * CFrame.Angles(math.rad(10), math.rad(0), math.rad(0)), 0.4)
LEFTLEGLERP.C0 = LEFTLEGLERP.C0:lerp(CFrame.new(0.5, 1.0, .9) * CFrame.Angles(math.rad(20), math.rad(0), math.rad(0)), 0.4)
elseif position == "Falling2" and attacking == true and appi == true then
change = 1
LEFTLEGLERP.C1 = LEFTLEGLERP.C1:lerp(CFrame.new(0,0,0) * CFrame.Angles(0,0,0),.1)
RIGHTLEGLERP.C1 = RIGHTLEGLERP.C1:lerp(CFrame.new(0,0,0) * CFrame.Angles(math.rad(0),0,0),.1)
RIGHTARMLERP.C1 = RIGHTARMLERP.C1:lerp(CFrame.new(0,0,0) * CFrame.Angles(0,0,0),.4)
RIGHTLEGLERP.C0 = RIGHTLEGLERP.C0:lerp(CFrame.new(-0.5, 2, 0) * CFrame.Angles(math.rad(8), math.rad(4), math.rad(0)), 0.2)
LEFTLEGLERP.C0 = LEFTLEGLERP.C0:lerp(CFrame.new(0.5, 1.0, .9) * CFrame.Angles(math.rad(14), math.rad(-4), math.rad(0)), 0.2)
RIGHTARMLERP.C0 = RIGHTARMLERP.C0:lerp(CFrame.new(-1.6, 0.5, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(-20)), 0.2)
elseif position == "Idle2" and attacking == true and appi == true then
change = .4
LEFTLEGLERP.C1 = LEFTLEGLERP.C1:lerp(CFrame.new(0,0,0) * CFrame.Angles(0,0,0),.1)
RIGHTLEGLERP.C1 = RIGHTLEGLERP.C1:lerp(CFrame.new(0,0,0) * CFrame.Angles(math.rad(0),0,0),.1)
RIGHTARMLERP.C0 = RIGHTARMLERP.C0:lerp(CFrame.new(-1.5,.6,-.5) * CFrame.Angles(math.rad(32),math.rad(5 - 1 * math.sin(sine/12)),math.rad(40 - 2 * math.sin(sine/12))), 0.3)
RIGHTARMLERP.C1 = RIGHTARMLERP.C1:lerp(CFrame.new(-.2,1.2,-.3),.3)
RIGHTLEGLERP.C0 = RIGHTLEGLERP.C0:lerp(CFrame.new(-0.3, 2, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(-10)), 0.3)
LEFTLEGLERP.C0 = LEFTLEGLERP.C0:lerp(CFrame.new(0.3, 2.0, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(10)), 0.3)
elseif position == "Walking2" and attacking == true and appi == true then
change = .8
LEFTLEGLERP.C1 = LEFTLEGLERP.C1:lerp(CFrame.new(0,0,0) * CFrame.Angles(0,0,0),.1)
RIGHTLEGLERP.C1 = RIGHTLEGLERP.C1:lerp(CFrame.new(0,0,0) * CFrame.Angles(math.rad(0),0,0),.1)
RIGHTARMLERP.C0 = RIGHTARMLERP.C0:lerp(CFrame.new(-1.5,.6,-.5) * CFrame.Angles(math.rad(32),math.rad(5 - 1 * math.sin(sine/12)),math.rad(40 - 2 * math.sin(sine/12))), 0.3)
RIGHTARMLERP.C1 = RIGHTARMLERP.C1:lerp(CFrame.new(-.2,1.2,-.3),.3)
ROOTLERP.C0 = ROOTLERP.C0:lerp(CFrame.new(0,0,0) * CFrame.Angles(0,0,math.rad(0) + Root.RotVelocity.Y/30,math.cos(25*math.cos(sine/8))),.3)
RIGHTLEGLERP.C0 = RIGHTLEGLERP.C0:lerp(CFrame.new(-0.5, 1.92 - 0.35 * math.cos(sine/8)/2.8, 0.2 - math.sin(sine/8)/3.4) * CFrame.Angles(math.rad(10) + -math.sin(sine/8)/2.3, math.rad(0)*math.cos(sine/1), math.rad(0)  + RightLeg.RotVelocity.Y / 30, math.cos(25 * math.cos(sine/8))), 0.3)
LEFTLEGLERP.C0 = LEFTLEGLERP.C0:lerp(CFrame.new(0.5, 1.92 + 0.35 * math.cos(sine/8)/2.8, 0.2 + math.sin(sine/8)/3.4) * CFrame.Angles(math.rad(10) - -math.sin(sine/8)/2.3, math.rad(0)*math.cos(sine/1), math.rad(0)  + LeftLeg.RotVelocity.Y / 30, math.cos(25 * math.cos(sine/8))), 0.3)
end
end
end)()
enemyhum = mouse.Target.Parent:FindFirstChildOfClass("Humanoid")
ETorso = enemyhum.Parent:FindFirstChild("Torso") or enemyhum.Parent:FindFirstChild("LowerTorso")
EHead = enemyhum.Parent:FindFirstChild("Head")
g1 = Instance.new("BodyGyro", Root)
g1.D = 175
g1.P = 20000
g1.MaxTorque = Vector3.new(0,9000,0)
brick = Instance.new("Part",Torso)
brick.Anchored = true
brick.CanCollide = false
brick.Material = "Neon"
brick.Transparency = 1
brick.BrickColor = BrickColor.new("White")
brick.Size = Vector3.new(8,.3,12)
brick.CFrame = Root.CFrame * CFrame.new(math.random(-15,15),-3,math.random(-15,15))
SOUND(brick,1888686669,6,false,1.5)
ace = aces[math.random(1,#aces)]
acer = Instance.new("Decal",brick)
acer.Texture = "rbxassetid://1898092341"
acer.Transparency = 1
acer.Face = "Top"
coroutine.wrap(function()
for i = 1, 20 do
g1.CFrame = g1.CFrame:lerp(CFrame.new(Root.Position,ETorso.Position),.2)
brick.Transparency = brick.Transparency - .05
acer.Transparency = acer.Transparency - .1
swait()
end
end)()
ETorso.Anchored = true
EHead.Anchored = true
for i = 1, 25 do
swait()
g1.CFrame = g1.CFrame:lerp(CFrame.new(Root.Position,ETorso.Position),.2)
ROOTLERP.C0 = ROOTLERP.C0:lerp(CFrame.new(0,-.2,0) * CFrame.Angles(0,0,0),.3)
LEFTARMLERP.C1 = CFrame.new(0,0,0) * CFrame.Angles(0,0,0)
LEFTARMLERP.C0 = LEFTARMLERP.C0:lerp(CFrame.new(1, 1.35, 0.4) * CFrame.Angles(math.rad(-90 - 2 * math.sin(sine/12)), math.rad(3), math.rad(4)), 0.3)
brick.CFrame = brick.CFrame:lerp(CFrame.new(ETorso.Position) * CFrame.new(0,-3,0) * CFrame.Angles(0,math.rad(0+10),0),.2)
end
SOUND(brick,472214107,6,false,2)
coroutine.wrap(function()
for i = 1, 10 do
g1.CFrame = g1.CFrame:lerp(CFrame.new(Root.Position,ETorso.Position),.2)
LEFTARMLERP.C0 = LEFTARMLERP.C0:lerp(CFrame.new(1, .8, 0.4) * CFrame.Angles(math.rad(-60 - 2 * math.sin(sine/12)), math.rad(3), math.rad(4)), 0.3)
swait()
end
end)()
shockwave = Instance.new("Part", Torso)
shockwave.Size = Vector3.new(1,1,1)
shockwave.CanCollide = false
shockwave.Anchored = true
shockwave.Transparency = 0
shockwave.BrickColor = BrickColor.new("White")
shockwave.CFrame = CFrame.new(brick.Position)
shockwavemesh = Instance.new("SpecialMesh", shockwave)
shockwavemesh.Scale = Vector3.new(1,1,1)
shockwavemesh.MeshId = "rbxassetid://20329976"
removeuseless:AddItem(shockwave,4)
shockwave2 = Instance.new("Part", Torso)
shockwave2.Size = Vector3.new(1,1,1)
shockwave2.CanCollide = false
shockwave2.Anchored = true
shockwave2.Transparency = 0
shockwave2.BrickColor = BrickColor.new("White")
shockwave2.CFrame = CFrame.new(brick.Position)
shockwavemesh2 = Instance.new("SpecialMesh", shockwave2)
shockwavemesh2.Scale = Vector3.new(1,1,1)
shockwavemesh2.MeshId = "rbxassetid://20329976"
removeuseless:AddItem(shockwave2,4)
for i = 1, 35 do
swait()
shockwavemesh.Scale = shockwavemesh.Scale + Vector3.new(2,.1,2)
shockwave.CFrame = shockwave.CFrame * CFrame.Angles(0,math.rad(0+12),0)
shockwave.Transparency = shockwave.Transparency + .05
shockwavemesh2.Scale = shockwavemesh2.Scale + Vector3.new(.5,.1,.5)
shockwave2.CFrame = shockwave2.CFrame * CFrame.Angles(0,math.rad(0+4),0)
shockwave2.Transparency = shockwave2.Transparency + .03
EHead.CFrame = EHead.CFrame * CFrame.new(0,-.20,0)
ETorso.CFrame = ETorso.CFrame * CFrame.new(0,-.25,0)
end
for i = 1, 8 do
brick.Size = brick.Size + Vector3.new(1.5,0,2.5)
swait()
end
n = 0
SOUND(brick,54111471,6,false,1)
for i = 1, 40 do
n = n + 6
brick.Transparency = brick.Transparency + .025
acer.Transparency = acer.Transparency + .075
brick.CFrame = brick.CFrame * CFrame.Angles(0,math.rad(n),0)
brick.Size = brick.Size - Vector3.new(1.5,.025,2.5)
swait()
end
ws = 10
brick:Remove()
enemyhum.Parent:Remove()
attacking = false
removeuseless:AddItem(g1,0.001)
debounce = false
appi = false
end
end
end)

mouse.KeyDown:connect(function(Press)
Press=Press:lower()
if Press=='p' then
if levitate then return end
if blocking then
if blockedoff then return end
clickallowance = false
appi = false
attacking = true
blocking = false
throwing = true
ws = 0
n = 0
blockcard.CanCollide = false
for i = 1, 35 do
n = n + 20
blockcard.CFrame = Root.CFrame * CFrame.new(0,3,-5) * CFrame.Angles(0,math.rad(n),0)
ROOTLERP.C0 = ROOTLERP.C0:lerp(CFrame.new(0, -.2, 0) * CFrame.Angles(math.rad(0), math.rad(25), math.rad(0)), 0.3)
LEFTARMLERP.C0 = LEFTARMLERP.C0:lerp(CFrame.new(1, 1.35, 0.4) * CFrame.Angles(math.rad(-50 - 2 * math.sin(sine/12)), math.rad(12), math.rad(9)), 0.3)
LEFTARMLERP.C1 = LEFTARMLERP.C1:lerp(CFrame.new(-.65, .6, 1) * CFrame.Angles(0,0,0),.3)
swait()
end
blockcard.CFrame = Root.CFrame * CFrame.new(0,3,-5 + -1) * CFrame.Angles(0,0,0)
blockcard.CanCollide = false
locater1 = Instance.new("Part",blockcard)
locater1.Size = Vector3.new(1,1,1)
locater1.CanCollide = false
locater1.Anchored = true
locater1.Transparency = 1
locater2 = Instance.new("Part",blockcard)
locater2.Size = Vector3.new(1,1,1)
locater2.CanCollide = false
locater2.Transparency = 1
locater2.Anchored = true
locater3 = Instance.new("Part",blockcard)
locater3.Size = Vector3.new(1,1,1)
locater3.Transparency = 1
locater3.CFrame = blockcard.CFrame * CFrame.Angles(math.rad(90),0,0)
locater3.CanCollide = false
locater3.Anchored = true
fushfush = Instance.new("Sound",blockcard)
fushfush.SoundId = "rbxassetid://288641686"
fushfush.Volume = 8
fushfush:Play()
boosh:Play()
coroutine.wrap(function()
n = 0
for i = 1, 35 do
n = n + 10
shockwave = Instance.new("Part", Torso)
shockwave.Size = Vector3.new(1,1,1)
shockwave.CanCollide = false
shockwave.Anchored = true
shockwave.Transparency = .5
shockwave.BrickColor = BrickColor.new("White")
shockwave.CFrame = locater3.CFrame
shockwavemesh = Instance.new("SpecialMesh", shockwave)
shockwavemesh.Scale = Vector3.new(15,.7,15)
shockwavemesh.MeshId = "rbxassetid://20329976"
shockwave.CFrame = locater3.CFrame * CFrame.Angles(math.rad(0),math.rad(1),0)
removeuseless:AddItem(shockwave,1)
table.insert(lolzor2,shockwave)
for i,v in pairs(lolzor2) do
v.Transparency = v.Transparency + .1
v.CFrame = v.CFrame * CFrame.Angles(math.rad(0),math.rad(n),0)
end
swait()
end
end)()
for i = 1, 35 do
ROOTLERP.C0 = ROOTLERP.C0:lerp(CFrame.new(0, -.2, 0) * CFrame.Angles(math.rad(0), math.rad(-20), math.rad(0)), 0.3)
LEFTARMLERP.C1 = LEFTARMLERP.C1:lerp(CFrame.new(0,0,0) * CFrame.Angles(0,0,0),.3)
LEFTARMLERP.C0 = LEFTARMLERP.C0:lerp(CFrame.new(1, 1.35, 0.4) * CFrame.Angles(math.rad(-90 - 2 * math.sin(sine/12)), math.rad(-20), math.rad(4)), 0.3)
fushfush.Volume = fushfush.Volume - .2
Hit = damagealll(20,blockcard.Position)
for _,v in pairs(Hit) do			
v:FindFirstChildOfClass("Humanoid"):TakeDamage(math.random(7,12))
vel = Instance.new("BodyVelocity",v:FindFirstChild("Torso") or v:FindFirstChild("UpperTorso")) 
vel.maxForce = Vector3.new(9999999999999,9999999999999,9999999999999)
torso = v:FindFirstChild("Torso") or v:FindFirstChild("UpperTorso")
vel.velocity = CFrame.new(blockcard.Position,torso.Position).lookVector*120
removeuseless:AddItem(vel,.1)
end
locater1.CFrame = blockcard.CFrame * CFrame.new(-5,-6,0)
locater3.CFrame = blockcard.CFrame * CFrame.new(0,0,-1) * CFrame.Angles(math.rad(90),0,0)
locater2.CFrame = blockcard.CFrame * CFrame.new(5,-6,0)
grassblocks = Instance.new("Part",Torso)
grassblocks.Size = Vector3.new(4,4,4)
grassblocks.Material = "Grass"
grassblocks.Anchored = true
grassblocks.BrickColor = BrickColor.new("Bright green")
grassblocks.CFrame = locater1.CFrame * CFrame.Angles(math.rad(math.random(-180,180)),math.rad(math.random(-180,180)),math.rad(math.random(-180,180)))
removeuseless:AddItem(grassblocks,5)
grassblocks2 = Instance.new("Part",Torso)
grassblocks2.Size = Vector3.new(4,4,4)
grassblocks2.Material = "Grass"
grassblocks2.Anchored = true
grassblocks2.BrickColor = BrickColor.new("Bright green")
grassblocks2.CFrame = locater2.CFrame * CFrame.Angles(math.rad(math.random(-180,180)),math.rad(math.random(-180,180)),math.rad(math.random(-180,180)))
removeuseless:AddItem(grassblocks2,5)
blockcardshadow = Instance.new("Part",Torso)
blockcardshadow.Transparency = .5
blockcardshadow.Anchored = true
blockcardshadow.Material = "Neon"
blockcardshadow.BrickColor = BrickColor.new("White")
blockcardshadow.Size = Vector3.new(8, 13, 0.3)
blockcardshadow.CanCollide = false
blockcardshadow.CFrame = blockcard.CFrame
removeuseless:AddItem(blockcardshadow,2)
table.insert(lolzor,blockcardshadow)
for i,v in pairs(lolzor) do
v.Transparency = v.Transparency + 0.05
end
blockcard.CFrame = blockcard.CFrame * CFrame.new(0,0,-4)
swait()
end
blockcard.Name = "Getthisshitoutofhere"
for i = 1, 10 do
blockcard.CFrame = blockcard.CFrame * CFrame.new(0,0,-2)
blockcard.Transparency = blockcard.Transparency + .1
acer.Transparency = blockcard.Transparency
ace2.Transparency = blockcard.Transparency
for i,v in pairs(lolzor) do
v.Transparency = v.Transparency + .05
end
for i,v in pairs(lolzor2) do
v.Transparency = v.Transparency + .1
end
swait()
end
lolzor={}
lolzor2={}
attacking = false
debounce = false
blocking = false
throwing = false
fushfush:Remove()
clickallowance = false
appi = false
blockcard:Remove()
g1:Remove()
ws = 10
else
if debounce then return end
if throwing then return end
debounce = true
ws = 10
attacking = true
blocking = true
boosh = Instance.new("Sound",nil)
boosh.SoundId = "rbxassetid://413682983"
boosh.Volume = 6
appi = true
coroutine.wrap(function()
while appi do
wait()
if Root.Velocity.y > 1 and attacking == true then
position = "Jump2"
elseif Root.Velocity.y < -1 and attacking == true then
position = "Falling2"
elseif Root.Velocity.Magnitude < 2 and attacking == true then
position = "Idle2"
elseif Root.Velocity.Magnitude > 2 and attacking == true then
position = "Walking2"
end
end
end)()
coroutine.wrap(function()
while appi do
wait()
settime = 0.05
sine = sine + change
if position == "Jump2" and attacking == true and appi == true then
change = 1
LEFTLEGLERP.C1 = LEFTLEGLERP.C1:lerp(CFrame.new(0,0,0) * CFrame.Angles(0,0,0),.1)
RIGHTLEGLERP.C1 = RIGHTLEGLERP.C1:lerp(CFrame.new(0,0,0) * CFrame.Angles(math.rad(0),0,0),.1)
RIGHTARMLERP.C1 = RIGHTARMLERP.C1:lerp(CFrame.new(0,0,0) * CFrame.Angles(0,0,0),.4)
ROOTLERP.C0 = ROOTLERP.C0:lerp(CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0)), 0.4)
RIGHTARMLERP.C0 = RIGHTARMLERP.C0:lerp(CFrame.new(-1.4,.1,-.2) * CFrame.Angles(math.rad(20),math.rad(3),math.rad(4)), 0.4)
RIGHTLEGLERP.C0 = RIGHTLEGLERP.C0:lerp(CFrame.new(-0.5, 2, 0) * CFrame.Angles(math.rad(10), math.rad(0), math.rad(0)), 0.4)
LEFTLEGLERP.C0 = LEFTLEGLERP.C0:lerp(CFrame.new(0.5, 1.0, .9) * CFrame.Angles(math.rad(20), math.rad(0), math.rad(0)), 0.4)
elseif position == "Falling2" and attacking == true and appi == true then
change = 1
LEFTLEGLERP.C1 = LEFTLEGLERP.C1:lerp(CFrame.new(0,0,0) * CFrame.Angles(0,0,0),.1)
RIGHTLEGLERP.C1 = RIGHTLEGLERP.C1:lerp(CFrame.new(0,0,0) * CFrame.Angles(math.rad(0),0,0),.1)
RIGHTARMLERP.C1 = RIGHTARMLERP.C1:lerp(CFrame.new(0,0,0) * CFrame.Angles(0,0,0),.4)
RIGHTLEGLERP.C0 = RIGHTLEGLERP.C0:lerp(CFrame.new(-0.5, 2, 0) * CFrame.Angles(math.rad(8), math.rad(4), math.rad(0)), 0.2)
LEFTLEGLERP.C0 = LEFTLEGLERP.C0:lerp(CFrame.new(0.5, 1.0, .9) * CFrame.Angles(math.rad(14), math.rad(-4), math.rad(0)), 0.2)
RIGHTARMLERP.C0 = RIGHTARMLERP.C0:lerp(CFrame.new(-1.6, 0.5, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(-20)), 0.2)
elseif position == "Idle2" and attacking == true and appi == true then
change = .4
LEFTLEGLERP.C1 = LEFTLEGLERP.C1:lerp(CFrame.new(0,0,0) * CFrame.Angles(0,0,0),.1)
RIGHTLEGLERP.C1 = RIGHTLEGLERP.C1:lerp(CFrame.new(0,0,0) * CFrame.Angles(math.rad(0),0,0),.1)
RIGHTARMLERP.C0 = RIGHTARMLERP.C0:lerp(CFrame.new(-1.5,.6,-.5) * CFrame.Angles(math.rad(32),math.rad(5 - 1 * math.sin(sine/12)),math.rad(40 - 2 * math.sin(sine/12))), 0.3)
RIGHTARMLERP.C1 = RIGHTARMLERP.C1:lerp(CFrame.new(-.2,1.2,-.3),.3)
RIGHTLEGLERP.C0 = RIGHTLEGLERP.C0:lerp(CFrame.new(-0.3, 2, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(-10)), 0.3)
LEFTLEGLERP.C0 = LEFTLEGLERP.C0:lerp(CFrame.new(0.3, 2.0, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(10)), 0.3)
elseif position == "Walking2" and attacking == true and appi == true then
change = .8
LEFTLEGLERP.C1 = LEFTLEGLERP.C1:lerp(CFrame.new(0,0,0) * CFrame.Angles(0,0,0),.1)
RIGHTLEGLERP.C1 = RIGHTLEGLERP.C1:lerp(CFrame.new(0,0,0) * CFrame.Angles(math.rad(0),0,0),.1)
RIGHTARMLERP.C0 = RIGHTARMLERP.C0:lerp(CFrame.new(-1.5,.6,-.5) * CFrame.Angles(math.rad(32),math.rad(5 - 1 * math.sin(sine/12)),math.rad(40 - 2 * math.sin(sine/12))), 0.3)
RIGHTARMLERP.C1 = RIGHTARMLERP.C1:lerp(CFrame.new(-.2,1.2,-.3),.3)
ROOTLERP.C0 = ROOTLERP.C0:lerp(CFrame.new(0,0,0) * CFrame.Angles(0,0,math.rad(0) + Root.RotVelocity.Y/30,math.cos(25*math.cos(sine/8))),.3)
RIGHTLEGLERP.C0 = RIGHTLEGLERP.C0:lerp(CFrame.new(-0.5, 1.92 - 0.35 * math.cos(sine/8)/2.8, 0.2 - math.sin(sine/8)/3.4) * CFrame.Angles(math.rad(10) + -math.sin(sine/8)/2.3, math.rad(0)*math.cos(sine/1), math.rad(0)), 0.3)
LEFTLEGLERP.C0 = LEFTLEGLERP.C0:lerp(CFrame.new(0.5, 1.92 + 0.35 * math.cos(sine/8)/2.8, 0.2 + math.sin(sine/8)/3.4) * CFrame.Angles(math.rad(10) - -math.sin(sine/8)/2.3, math.rad(0)*math.cos(sine/1), math.rad(0)), 0.3)
end
end
end)()
blockcard = Instance.new("Part",Torso)
blockcard.Material = "Neon"
blockcard.Transparency = 1
blockcard.BrickColor = BrickColor.new("White")
blockcard.Size = Vector3.new(8, 13, 0.3)
blockcard.CFrame = Root.CFrame * CFrame.new(0,2,-5)
blockcard.Anchored = true
boosh.Parent = blockcard
SOUND(blockcard,236989198,6,false,1)
ace = aces[math.random(1,#aces)]
acer = Instance.new("Decal",blockcard)
acer.Texture = "rbxassetid://"..ace
acer.Transparency = 1
acer.Face = "Front"
ace2 = acer:Clone()
ace2.Parent = blockcard
ace2.Face = "Back"
coroutine.wrap(function()
for i = 1, 20 do
blockcard.Transparency = blockcard.Transparency - 0.05
acer.Transparency = blockcard.Transparency
ace2.Transparency = blockcard.Transparency
swait()
end
clickallowance = true
end)()
g1 = Instance.new("BodyGyro", Root)
g1.D = 175
g1.P = 20000
g1.MaxTorque = Vector3.new(0,9000,0)
coroutine.wrap(function()
while blocking do
if not blockedoff then
ROOTLERP.C0 = ROOTLERP.C0:lerp(CFrame.new(0,-.2, 0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),.3)
blockcard.CFrame = Root.CFrame * CFrame.new(0,3,-5)
g1.CFrame = g1.CFrame:lerp(CFrame.new(Root.Position,mouse.Hit.p),.2)
LEFTARMLERP.C1 = LEFTARMLERP.C1:lerp(CFrame.new(0,0,0)*CFrame.Angles(0,0,0),.3)
LEFTARMLERP.C0 = LEFTARMLERP.C0:lerp(CFrame.new(1, 1.35, 0.4) * CFrame.Angles(math.rad(-90 - 2 * math.sin(sine/12)), math.rad(3), math.rad(4)), 0.3)
end
swait()
end
end)()
wait(1)
mouse.Button1Down:connect(function()
if throwing then return end
if not clickallowance then return end
clickallowance = false
blockedoff = true
ws = 0
for i = 1, 15 do
ROOTLERP.C0 = ROOTLERP.C0:lerp(CFrame.new(0, -.2, 0) * CFrame.Angles(math.rad(0), math.rad(25), math.rad(0)), 0.3)
LEFTARMLERP.C0 = LEFTARMLERP.C0:lerp(CFrame.new(1, 1.35, 0.4) * CFrame.Angles(math.rad(-50 - 2 * math.sin(sine/12)), math.rad(12), math.rad(9)), 0.3)
LEFTARMLERP.C1 = LEFTARMLERP.C1:lerp(CFrame.new(-.65, .6, 1) * CFrame.Angles(0,0,0),.3)
swait()
end
boosh:Play()
hitdebounce = false
blockcard.Touched:connect(function(hit)
if hit.Parent:IsA("Part") then
elseif hit.Parent:IsA("SpecialMesh") then
elseif hit.Parent.Name == game.Players.LocalPlayer.Name then
elseif hit.Parent:findFirstChildOfClass("Humanoid") then
for i,v in pairs(hit.Parent:GetChildren()) do
Slachtoffer = v.Parent:FindFirstChildOfClass("Humanoid")
if hitdebounce then return end
hitdebounce = true
vel = Instance.new("BodyVelocity",hit.Parent:FindFirstChild("Torso") or hit.Parent:FindFirstChild("UpperTorso")) 
vel.maxForce = Vector3.new(9999999999999,9999999999999,9999999999999)
if Slachtoffer.RigType == Enum.HumanoidRigType.R15 then
tors = hit.Parent:FindFirstChild("UpperTorso")
else
tors = hit.Parent:FindFirstChild("Torso")
end
vel.velocity = CFrame.new(Root.Position,tors.Position).lookVector*120
removeuseless:AddItem(vel,.1)
Slachtoffer:TakeDamage(math.random(23,44))
end
end
end)
for i = 1, 10 do
ROOTLERP.C0 = ROOTLERP.C0:lerp(CFrame.new(0, -.2, 0) * CFrame.Angles(math.rad(0), math.rad(-20), math.rad(0)), 0.3)
LEFTARMLERP.C1 = LEFTARMLERP.C1:lerp(CFrame.new(0,0,0) * CFrame.Angles(0,0,0),.3)
LEFTARMLERP.C0 = LEFTARMLERP.C0:lerp(CFrame.new(1, 1.35, 0.4) * CFrame.Angles(math.rad(-90 - 2 * math.sin(sine/12)), math.rad(-20), math.rad(4)), 0.3)
blockcard.CFrame = blockcard.CFrame * CFrame.new(0,0,0-1)
swait()
end
for i = 1, 10 do
blockcard.CFrame = blockcard.CFrame * CFrame.new(0,0,0+1)
swait()
end
hitdebounce = true
ws = 10
clickallowance = true
blockedoff = false
end)
end
end
end)


mouse.KeyDown:connect(function(Press)
Press=Press:lower()
if Press=='f' then
if debounce then return end
if notallowedtransform then return end
debounce = true
if levitate then
levitate = false
mjester.VertexColor = Vector3.new(1, 1, 1)
glow.Transparency = 1
blastwave = Instance.new("Part",Torso)
blastwave.CFrame = Torso.CFrame
blastwave.Anchored = true
blastwave.Material = "Neon"
blastwave.CanCollide = false
blastwave.Shape = "Ball"
blastwave.Size = Vector3.new(3,3,3)
coroutine.wrap(function()
for i = 1, 20 do
levitatewave.Transparency = levitatewave.Transparency + 0.05
levitatewave2.Transparency = levitatewave2.Transparency + 0.05
blastwave.Size = blastwave.Size + Vector3.new(2,2,2)
blastwave.Transparency = blastwave.Transparency + 0.05
swait()
end
blastwave:Remove()
levitatewave2:Remove()
levitatewave:Remove()
end)()
ws = 10
notallowedtransform = true
attacking = true
coroutine.wrap(function()
for i = 1, 10 do
for i,v in pairs(LeftArm:GetChildren()) do if v.Name == lmagic.Name then
v.Transparency = v.Transparency + 0.1
end
end
for i,v in pairs(RightArm:GetChildren()) do if v.Name == rmagic.Name then
v.Transparency = v.Transparency + 0.1
end
end
wait()
end
end)()
doomtheme.SoundId = "rbxassetid://1843358057"
jesterWeld.C0 = CFrame.new(0,0,0) * CFrame.Angles(0,0,0)
wait(0.000001)
jesterWeld.C0 = jester.CFrame:inverse() * Head.CFrame * CFrame.new(0,-.3,0) * CFrame.Angles(math.rad(0),math.rad(90),0)
mjester.Scale = Vector3.new(1.1, 1.1, 1.1)
mjester.MeshId,mjester.TextureId = 'rbxassetid://1241662062','rbxassetid://1241662395'

mMask.Scale = Vector3.new(0.13, 0.13, 0.1)
mMask.MeshId,mMask.TextureId = 'http://www.roblox.com/asset/?id=5158270','http://www.roblox.com/asset/?id=9543585'
maskweld.C0 = CFrame.new(0,0,0)*CFrame.Angles(0,0,0)
wait(0.000001)
maskweld.C0 = CFrame.new(0,-.555,0) * CFrame.Angles(math.rad(90),0,0)

eyo1 = Instance.new("Part",Head)
eyo1.BrickColor = BrickColor.new("White")
eyo1.Material = "Neon"
eyo1.Shape = "Ball"
eyo1.Name = "eyo1"
eyo1.CanCollide = false
eyo1.Size = Vector3.new(0.33, 0.33, 0.33)
eyo1weld = weldBetween(eyo1,Head)
eyo1weld.C0 = CFrame.new(.215,-.05,.52)

light = Instance.new("PointLight", eyo1)
light.Color = Color3.new(1,1,1)
light.Range = 3
light.Brightness = 4
light.Enabled = true

eyo2 = Instance.new("Part",Head)
eyo2.BrickColor = BrickColor.new("White")
eyo2.Material = "Neon"
eyo2.Shape = "Ball"
eyo2.Name = "eyo2"
eyo2.CanCollide = false
eyo2.Size = Vector3.new(0.33, 0.33, 0.33)
eyo2weld = weldBetween(eyo2,Head)
eyo2weld.C0 = CFrame.new(-.215,-.05,.52)

light2 = Instance.new("PointLight", eyo2)
light2.Color = Color3.new(1,1,1)
light2.Range = 3
light2.Brightness = 4
light2.Enabled = true

Character.Shirt.ShirtTemplate = "rbxassetid://676428254"
Character.Pants.PantsTemplate = "rbxassetid://676428351"
hum.HipHeight = 0
ws = 10
debounce = false
attacking = false
coroutine.wrap(function()
wait(3)
notallowedtransform = false
end)()
else
ws = 50
notallowedtransform = true
levitate = true
ws = 50
glow.Transparency = 0
eyo1:Remove()
eyo2:Remove()
coroutine.wrap(function()
while levitate do
for i,v in pairs(Head:GetChildren()) do
if v.Name == "eyo1" or v.Name == "eyo2" then
v:Remove()
end
end
wait()
end
end)()
mnb = 0
levitatewave = Instance.new("Part", Torso)
levitatewave.Size = Vector3.new(1,1,1)
levitatewave.CanCollide = false
levitatewave.Anchored = true
levitatewave.Transparency = .5
levitatewave.BrickColor = BrickColor.new("Really black")
levitatewave.CFrame = CFrame.new(Root.Position) * CFrame.new(0,-5,0)
levitatewavemesh = Instance.new("SpecialMesh", levitatewave)
levitatewavemesh.Scale = Vector3.new(2.5,.3,2.5)
levitatewavemesh.MeshId = "rbxassetid://20329976"
levitatewave2 = Instance.new("Part", Torso)
levitatewave2.Size = Vector3.new(1,1,1)
levitatewave2.CanCollide = false
levitatewave2.Anchored = true
levitatewave2.Transparency = .5
levitatewave2.BrickColor = BrickColor.new("Really red")
levitatewave2.CFrame = CFrame.new(Root.Position) * CFrame.new(0,-5,0)
levitatewavemesh2 = Instance.new("SpecialMesh", levitatewave2)
levitatewavemesh2.Scale = Vector3.new(2,.4,2)
levitatewavemesh2.MeshId = "rbxassetid://20329976"
blastwave = Instance.new("Part",Torso)
blastwave.CFrame = Torso.CFrame
blastwave.Anchored = true
blastwave.Material = "Neon"
blastwave.CanCollide = false
blastwave.Shape = "Ball"
blastwave.Size = Vector3.new(3,3,3)
coroutine.wrap(function()
for i = 1, 20 do
blastwave.Size = blastwave.Size + Vector3.new(2,2,2)
blastwave.Transparency = blastwave.Transparency + 0.05
swait()
end
blastwave:Remove()
end)()
coroutine.wrap(function()
while levitate do
mnb = mnb + 15
levitatewave.CFrame = CFrame.new(Root.Position) * CFrame.new(0,-6 + .5 * math.sin(sine/9),0) * CFrame.Angles(0,math.rad(mnb),0)
levitatewave2.CFrame = CFrame.new(Root.Position) * CFrame.new(0,-6 + .5 * math.sin(sine/9),0) * CFrame.Angles(0,math.rad(mnb),0)
colors = colortable[math.random(1,#colortable)]
lmagic = Instance.new("Part",LeftArm)
lmagic.Material = "Neon"
lmagic.CanCollide = false
lmagic.Anchored = true
lmagic.BrickColor = BrickColor.new(colors)
lmagic.Size = Vector3.new(1,1,1)
lmagic.CFrame = leftlocation.CFrame * CFrame.Angles(math.random(-180,180),math.random(-180,180),math.random(-180,180))
removeuseless:AddItem(lmagic,2)
rmagic = Instance.new("Part",RightArm)
rmagic.Material = "Neon"
rmagic.CanCollide = false
rmagic.Anchored = true
rmagic.BrickColor = BrickColor.new(colors)
rmagic.Size = Vector3.new(1,1,1)
rmagic.CFrame = rightlocation.CFrame * CFrame.Angles(math.random(-180,180),math.random(-180,180),math.random(-180,180))
removeuseless:AddItem(rmagic,2)
for i,v in pairs(LeftArm:GetChildren()) do if v.Name == lmagic.Name then
v.Transparency = v.Transparency + 0.05
end
end
for i,v in pairs(RightArm:GetChildren()) do if v.Name == rmagic.Name then
v.Transparency = v.Transparency + 0.05
end
end
swait()
end
end)()
framee = Instance.new("Frame")
framee.Parent = screenGui
framee.Position = UDim2.new(0, 8, 0, -500)
framee.Size = UDim2.new(100000000,10000000,10000000,10000000)
framee.BackgroundColor3 = BrickColor.new("White").Color
framee.BackgroundTransparency = 0
coroutine.wrap(function()
wait(.2)
for i = 1, 40 do
hum.CameraOffset = Vector3.new(math.random(-1,1),math.random(-1,1),math.random(-0,0))
framee.BackgroundTransparency = framee.BackgroundTransparency + 0.025
swait()
end
hum.CameraOffset = Vector3.new(0,0,0)
framee:Remove()
end)()
doomtheme.SoundId = "rbxassetid://1382488262"
doomtheme:Play()
doomtheme.Volume = 2
doomtheme.TimePosition = 20.7
jesterWeld.C0 = jesterWeld.C0 * CFrame.new(.3,-.3,0) * CFrame.Angles(math.rad(0),math.rad(-90),0)
mjester.MeshId = "rbxassetid://193760002"
mjester.TextureId = "rbxassetid://379225327"
mjester.VertexColor = Vector3.new(1, 0, 0)
Character.Shirt.ShirtTemplate = "rbxassetid://238537827"
Character.Pants.PantsTemplate = "rbxassetid://486031443"
maskweld.C0 = maskweld.C0 * CFrame.new(0,.55,-.5) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(0))
mMask.MeshId = "rbxassetid://13520257"
mMask.Scale = Vector3.new(1.1, 1, 1)
mMask.TextureId = "rbxassetid://13520260"
eyo1:Remove()
eyo2:Remove()
coroutine.wrap(function()
while levitate do
hum.HipHeight = 3 - .5 * math.sin(sine/9)
swait()
end
end)()
attacking = false
debounce = false
coroutine.wrap(function()
wait(3)
notallowedtransform = false
end)()
end
end
end)

mouse.KeyDown:connect(function(Press)
Press=Press:lower()
if Press=='.' then
hum.Parent:BreakJoints()
end
end)

checks1 = coroutine.wrap(function() -------Checks
while true do
if Root.Velocity.y > 1 and levitate == false then
position = "Jump"
elseif Root.Velocity.y < -1 and levitate == false then
position = "Falling"
elseif Root.Velocity.Magnitude < 2 and running == false and not levitate then
position = "Idle"
elseif Root.Velocity.Magnitude < 2 and running == false then
position = "Idle2"
elseif Root.Velocity.Magnitude < 20 and running == false and levitate == false then
position = "Walking"
elseif Root.Velocity.Magnitude > 20 and running == false and levitate then
position = "Walking2"
elseif Root.Velocity.Magnitude > 20 and levitate == false then
position = "Running"
else
end
wait()
end
end)
checks1()

function ray(POSITION, DIRECTION, RANGE, IGNOREDECENDANTS)
	return workspace:FindPartOnRay(Ray.new(POSITION, DIRECTION.unit * RANGE), IGNOREDECENDANTS)
end

function ray2(StartPos, EndPos, Distance, Ignore)
local DIRECTION = CFrame.new(StartPos,EndPos).lookVector
return ray(StartPos, DIRECTION, Distance, Ignore)
end

OrgnC0 = Neck.C0
local movelimbs = coroutine.wrap(function()
while RunSrv.RenderStepped:wait() do
TrsoLV = Torso.CFrame.lookVector
Dist = nil
Diff = nil
if not MseGuide then
print("Failed to recognize")
else
local _, Point = Workspace:FindPartOnRay(Ray.new(Head.CFrame.p, mouse.Hit.lookVector), Workspace, false, true)
Dist = (Head.CFrame.p-Point).magnitude
Diff = Head.CFrame.Y-Point.Y
local _, Point2 = Workspace:FindPartOnRay(Ray.new(LeftArm.CFrame.p, mouse.Hit.lookVector), Workspace, false, true)
Dist2 = (LeftArm.CFrame.p-Point).magnitude
Diff2 = LeftArm.CFrame.Y-Point.Y
HEADLERP.C0 = CFrame.new(0, -1.5, -0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0))
Neck.C0 = Neck.C0:lerp(OrgnC0*CFrame.Angles((math.tan(Diff/Dist)*1), 0, (((Head.CFrame.p-Point).Unit):Cross(Torso.CFrame.lookVector)).Y*1), .1)
end
end
end)
movelimbs()
immortal = {}
for i,v in pairs(Character:GetDescendants()) do
	if v:IsA("BasePart") and v.Name ~= "lmagic" and v.Name ~= "rmagic" then
		if v ~= Root and v ~= Torso and v ~= Head and v ~= RightArm and v ~= LeftArm and v ~= RightLeg and v.Name ~= "lmagic" and v.Name ~= "rmagic" and v ~= LeftLeg then
			v.CustomPhysicalProperties = PhysicalProperties.new(0, 0, 0, 0, 0)
		end
		table.insert(immortal,{v,v.Parent,v.Material,v.Color,v.Transparency})
	elseif v:IsA("JointInstance") then
		table.insert(immortal,{v,v.Parent,nil,nil,nil})
	end
end
for e = 1, #immortal do
	if immortal[e] ~= nil then
		local STUFF = immortal[e]
		local PART = STUFF[1]
		local PARENT = STUFF[2]
		local MATERIAL = STUFF[3]
		local COLOR = STUFF[4]
		local TRANSPARENCY = STUFF[5]
if levitate then
		if PART.ClassName == "Part" and PART ~= Root and PART.Name ~= eyo1 and PART.Name ~= eyo2 and PART.Name ~= "lmagic" and PART.Name ~= "rmagic" then
			PART.Material = MATERIAL
			PART.Color = COLOR
			PART.Transparency = TRANSPARENCY
		end
		PART.AncestryChanged:connect(function()
			PART.Parent = PARENT
		end)
else
		if PART.ClassName == "Part" and PART ~= Root and PART.Name ~= "lmagic" and PART.Name ~= "rmagic" then
			PART.Material = MATERIAL
			PART.Color = COLOR
			PART.Transparency = TRANSPARENCY
		end
		PART.AncestryChanged:connect(function()
			PART.Parent = PARENT
		end)
end
	end
end
function immortality()
	for e = 1, #immortal do
		if immortal[e] ~= nil then
			local STUFF = immortal[e]
			local PART = STUFF[1]
			local PARENT = STUFF[2]
			local MATERIAL = STUFF[3]
			local COLOR = STUFF[4]
			local TRANSPARENCY = STUFF[5]
			if PART.ClassName == "Part" and PART == Root then
				PART.Material = MATERIAL
				PART.Color = COLOR
				PART.Transparency = TRANSPARENCY
			end
			if PART.Parent ~= PARENT then
				hum:Remove()
				PART.Parent = PARENT
				hum = Instance.new("Humanoid",Character)
if levitate then
eyo1:Remove()
eyo2:Remove()
end
                                hum.Name = "noneofurbusiness"
			end
		end
	end
end
coroutine.wrap(function()
while true do
if hum.Health < .1 then
deadsound = Instance.new("Sound", Torso)
deadsound.Volume = 6
deadsound.SoundId = "rbxassetid://1411352723"
deadsound:Play()
immortality()
end
wait()
end
end)()

mouse.KeyDown:connect(function(Press)
Press=Press:lower()
if Press=='g' then
if not levitate then return end
if debounce then return end
debounce = true
attacking = true
FireBall:Play()
ws = 15
g1 = Instance.new("BodyGyro", Root)
g1.D = 175
g1.P = 20000
g1.MaxTorque = Vector3.new(0,9000,0)
for i = 1, 15 do
g1.CFrame = g1.CFrame:lerp(CFrame.new(Root.Position,mouse.Hit.p),.2)
ROOTLERP.C0 = ROOTLERP.C0:lerp(CFrame.new(0,0,0) * CFrame.Angles(math.rad(-10),math.rad(-15),math.rad(0)),.5)
RIGHTARMLERP.C1 = CFrame.new(0,0,0) * CFrame.Angles(0,0,0)
RIGHTARMLERP.C0 = RIGHTARMLERP.C0:lerp(CFrame.new(-0.5, 2, 0) * CFrame.Angles(math.rad(14), math.rad(20), math.rad(-90)), 0.3)
swait()
end
local swoosh = Instance.new("Part",Torso)
swoosh.Name = "swoosh"
swoosh.CFrame = rightlocation.CFrame * CFrame.new(0,0,0)
swoosh.Size = Vector3.new(1.7,1.7,1.7)
swoosh.Shape = "Ball"
swoosh.Material = "Neon"
swoosh.BrickColor = BrickColor.new("Really black")
swoosh.CanCollide = false
swoosh.Touched:connect(function(hit)
if hit.Parent:IsA("Part") then
elseif hit.Parent:IsA("SpecialMesh") then
elseif hit.Parent.Name == game.Players.LocalPlayer.Name then
elseif hit.Parent:findFirstChildOfClass("Humanoid") then
Slachtoffer = hit.Parent:findFirstChildOfClass("Humanoid")
if Slachtoffer.Health < 1 then return end
if damagedebounce == true then return end
damagedebounce = true
swoosh:Remove()
explosion = Instance.new("Part",LeftArm)
explosion.CFrame = hit.CFrame
explosion.Anchored = true
explosion.CanCollide = false
explosion.Name = "explo"
explosion.Shape = "Ball"
explosion.BrickColor = BrickColor.new("Really black")
explosion.Material = "Neon"
removeuseless:AddItem(explosion,1.5)
vel = Instance.new("BodyVelocity",hit.Parent:FindFirstChild("Torso") or hit.Parent:FindFirstChild("UpperTorso")) 
vel.maxForce = Vector3.new(9999999999999,9999999999999,9999999999999)
torso = hit.Parent:FindFirstChild("Torso") or hit.Parent:FindFirstChild("UpperTorso")
vel.velocity = CFrame.new(swoosh.Position,torso.Position).lookVector*60
removeuseless:AddItem(vel,.1)
SOUND(explosion,472579737,6,false,3)
coroutine.wrap(function()
if firsttime2 then return end
firsttime2 = true
while true do
for i,v in pairs(LeftArm:GetChildren()) do
if v.Name == "explo" then
v.Size = v.Size + Vector3.new(2.5,2.5,2.5)
v.Transparency = v.Transparency + .05
end
end
for i,v in pairs(LeftArm:GetChildren()) do
if v.Name == "shock" then
v.Transparency = v.Transparency + .05
end
end
for i,v in pairs(LeftArm:GetChildren()) do
if v.Name == "shock2" then
v.Transparency = v.Transparency + .05
end
end
swait()
end
end)()
Slachtoffer:TakeDamage(math.random(27,48))
wait(.1)
damagedebounce = false
end
end)
coroutine.wrap(function()
if firsttime then return end
firsttime = true
while wait() do
for i,v in pairs(Torso:GetChildren()) do
if v.Name == "swoosh" then
magiccc = Instance.new("Part",RightArm)
magiccc.Material = "Neon"
magiccc.CanCollide = false
magiccc.Anchored = true
magiccc.BrickColor = BrickColor.new(colors)
magiccc.Size = Vector3.new(1.5,1.5,1.5)
magiccc.CFrame = v.CFrame * CFrame.Angles(math.random(-180,180),math.random(-180,180),math.random(-180,180))
removeuseless:AddItem(magiccc,2)
end
end
end
end)()
bov = Instance.new("BodyVelocity",swoosh)
bov.maxForce = Vector3.new(99999,99999,99999)
swoosh.CFrame = CFrame.new(swoosh.Position,mouse.Hit.p)
bov.velocity = swoosh.CFrame.lookVector*120
removeuseless:AddItem(swoosh,4)
for i = 1, 15 do
ROOTLERP.C0 = ROOTLERP.C0:lerp(CFrame.new(0,0,0) * CFrame.Angles(math.rad(10),math.rad(15),math.rad(0)),.5)
RIGHTARMLERP.C1 = CFrame.new(0,0,0)
RIGHTARMLERP.C0 = RIGHTARMLERP.C0:lerp(CFrame.new(-1.2,1,.5) * CFrame.Angles(math.rad(-90),math.rad(-25),math.rad(0)), 0.5)
swait()
end
ws = 50
removeuseless:AddItem(g1,0.01)
debounce = false
attacking = false
end
end)

mouse.KeyDown:connect(function(Press)
Press=Press:lower()
if Press=='h' then
if not levitate then return end
if debounce then return end
debounce = true
attacking = true
ws = 0
appi = true
coroutine.wrap(function()
while appi do
swait()
if Root.Velocity.Magnitude < 2 and attacking == true then
position = "Idle3"
end
end
end)()
coroutine.wrap(function()
while appi do
swait()
settime = 0.05
sine = sine + change
if position == "Idle3" and attacking == true and appi == true then
change = .4
RIGHTLEGLERP.C1 = RIGHTLEGLERP.C1:lerp(CFrame.new(0,0,0) * CFrame.Angles(math.rad(0),0,0),.1)
LEFTLEGLERP.C1 = LEFTLEGLERP.C1:lerp(CFrame.new(-.2,.2,0) * CFrame.Angles(0,0,0),.1)
LEFTARMLERP.C1 = CFrame.new(0,0,0) * CFrame.Angles(0,0,0)
LEFTARMLERP.C0 = LEFTARMLERP.C0:lerp(CFrame.new(1.6, 0.8 - .1 * math.sin(sine/9), 0) * CFrame.Angles(math.rad(0), math.rad(0 + 3 * math.sin(sine/9)), math.rad(35 - 5 * math.sin(sine/9))), 0.4)
RIGHTLEGLERP.C0 = RIGHTLEGLERP.C0:lerp(CFrame.new(-0.54, 1.4 + .1 * math.sin(sine/9), .4) * CFrame.Angles(math.rad(9 + 2 * math.cos(sine/9)), math.rad(0), math.rad(0)), 0.4)
LEFTLEGLERP.C0 = LEFTLEGLERP.C0:lerp(CFrame.new(0.5, 2.0,0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(-10 + 2 * math.sin(sine/9))), 0.4)
end
end
end)()
coroutine.wrap(function()
for i = 1, 20 do
RIGHTARMLERP.C1 = CFrame.new(0,0,0) * CFrame.Angles(0,0,0)
ROOTLERP.C0 = ROOTLERP.C0:lerp(CFrame.new(0, 0, 0) * CFrame.Angles(0,math.rad(50),0),.3)
RIGHTARMLERP.C0 = RIGHTARMLERP.C0:lerp(CFrame.new(-1.1,1.3,1.1) * CFrame.Angles(math.rad(180),math.rad(-50),math.rad(0)), 0.3)
swait()
end
end)()
SOUND(LeftArm,1982011510,8,false,15)
blackhole={}
orbzfade={}
xz = 0
for i = 1, 220 do
xz = xz + .009
bigrmagic = Instance.new("Part",RightArm)
bigrmagic.Material = "Neon"
bigrmagic.CanCollide = false
bigrmagic.Anchored = true
bigrmagic.BrickColor = BrickColor.new(colors)
bigrmagic.Size = Vector3.new(xz,xz,xz)
bigrmagic.CFrame = rightlocation.CFrame * CFrame.Angles(math.random(-180,180),math.random(-180,180),math.random(-180,180))
removeuseless:AddItem(bigrmagic,1)
orbz = Instance.new("Part", Torso)
orbz.Material = "Neon"
orbz.BrickColor = BrickColor.new(colors)
orbz.Size = Vector3.new(2,2,2)
orbz.Anchored = true
orbz.CanCollide = false
removeuseless:AddItem(orbz,1)
orbz.CFrame = rightlocation.CFrame * CFrame.new(math.random(-25,25),math.random(-25,25),math.random(-25,25)) * CFrame.Angles(math.rad(-180,180),math.rad(-180,180),math.rad(-180,180))
table.insert(blackhole,orbz)
table.insert(orbzfade,orbz)
for i,v in pairs(blackhole) do
v.Size = v.Size - Vector3.new(.1,.1,.1)
v.CFrame = v.CFrame:lerp(CFrame.new(rightlocation.Position),.09)
end
for i,v in pairs(orbzfade) do
v.Transparency = v.Transparency + 0.025
end
swait()
end
coroutine.wrap(function()
for i = 1, 10 do
for i,v in pairs(blackhole) do
v.Size = v.Size + Vector3.new(.5,.5,.5)
v.Transparency = v.Transparency + .1
end
swait()
end
for i,v in pairs(blackhole) do
v:Remove()
end
clean()
end)()
charging = true
coroutine.wrap(function()
while charging do
bigrmagic = Instance.new("Part",RightArm)
bigrmagic.Material = "Neon"
bigrmagic.CanCollide = false
bigrmagic.Anchored = true
bigrmagic.BrickColor = BrickColor.new(colors)
bigrmagic.Size = Vector3.new(xz,xz,xz)
bigrmagic.CFrame = rightlocation.CFrame * CFrame.Angles(math.random(-180,180),math.random(-180,180),math.random(-180,180))
removeuseless:AddItem(bigrmagic,.2)
swait()
end
end)()
g1 = Instance.new("BodyGyro", Root)
g1.D = 175
g1.P = 20000
g1.MaxTorque = Vector3.new(0,9000,0)
BigFireBall:Play()
for i = 1, 15 do
g1.CFrame = g1.CFrame:lerp(CFrame.new(Root.Position,mouse.Hit.p),.2)
ROOTLERP.C0 = ROOTLERP.C0:lerp(CFrame.new(0,0,0) * CFrame.Angles(math.rad(-10),math.rad(-15),math.rad(0)),.5)
RIGHTARMLERP.C1 = CFrame.new(0,0,0) * CFrame.Angles(0,0,0)
RIGHTARMLERP.C0 = RIGHTARMLERP.C0:lerp(CFrame.new(-0.5, 2, 0) * CFrame.Angles(math.rad(14), math.rad(20), math.rad(-90)), 0.3)
swait()
end
coroutine.wrap(function()
for i = 1, 15 do
ROOTLERP.C0 = ROOTLERP.C0:lerp(CFrame.new(0,0,0) * CFrame.Angles(math.rad(10),math.rad(15),math.rad(0)),.5)
RIGHTARMLERP.C1 = CFrame.new(0,0,0)
RIGHTARMLERP.C0 = RIGHTARMLERP.C0:lerp(CFrame.new(-1.2,1,.5) * CFrame.Angles(math.rad(-90),math.rad(-25),math.rad(0)), 0.5)
swait()
end
end)()
charging = false
local ballzor = Instance.new("Part",Torso)
ballzor.Name = "ballzor"
ballzor.Material = "Neon"
ballzor.BrickColor = BrickColor.new("Really black")
ballzor.CanCollide = false
ballzor.Size = Vector3.new(xz,xz,xz)
ballzor.Anchored = false
ballzor.CFrame = Root.CFrame * CFrame.new(1,0,-5)
ballzor.Shape = "Ball"
removeuseless:AddItem(g1,.0001)
zx = xz + .05
coroutine.wrap(function()
if firsttime5 then return end
firsttime5 = true
while true do
swait()
for i,v in pairs(Torso:GetChildren()) do
if v.Name == "ballzor" then
magicccc = Instance.new("Part",RightArm)
magicccc.Material = "Neon"
magicccc.CanCollide = false
magicccc.Name = "magicccc"
magicccc.Anchored = true
magicccc.Transparency = 0
magicccc.BrickColor = BrickColor.new(colors)
magicccc.Size = Vector3.new(zx,zx,zx)
magicccc.CFrame = v.CFrame * CFrame.Angles(math.random(-180,180),math.random(-180,180),math.random(-180,180))
removeuseless:AddItem(magicccc,2)
end
end
for i,v in pairs(RightArm:GetChildren()) do
if v.Name == "magicccc" then
v.Transparency = v.Transparency + 0.025
end
end
end
end)()
ballzor.Touched:connect(function(hit)
if hit.Name ~= "magicccc" then
if bigball then return end
bigball = true
local explosionwave = Instance.new("Part",Torso) 
explosionwave.Shape = "Ball"
explosionwave.BrickColor = BrickColor.new("Really black")
explosionwave.Anchored = true
explosionwave.CanCollide = false
explosionwave.Transparency = .2
explosionwave.Material = "Neon"
explosionwave.Size = Vector3.new(1,1,1)
explosionwave.CFrame = ballzor.CFrame
render = Instance.new("Sound",explosionwave)
render.SoundId = "rbxassetid://2006635781"
render.Volume = 10 * 10
render:Play()
local explosionwave2 = Instance.new("Part",Torso)
explosionwave2.Shape = "Ball"
explosionwave2.BrickColor = BrickColor.new("Really red")
explosionwave2.Anchored = true
explosionwave2.CanCollide = false
explosionwave2.Material = "Neon"
explosionwave2.Size = Vector3.new(.8,.8,.8)
explosionwave2.CFrame = ballzor.CFrame
deadlywave = Instance.new("Part", explosionwave)
deadlywave.Size = Vector3.new(1,1,1)
deadlywave.CanCollide = false
deadlywave.Anchored = true
deadlywave.Transparency = .5
deadlywave.BrickColor = BrickColor.new("Really red")
deadlywave.CFrame = CFrame.new(explosionwave.Position)
deadlywavemesh = Instance.new("SpecialMesh", deadlywave)
deadlywavemesh.Scale = Vector3.new(1,2,1)
deadlywavemesh.MeshId = "rbxassetid://20329976"
deadlywave2 = Instance.new("Part", explosionwave)
deadlywave2.Size = Vector3.new(1,1,1)
deadlywave2.CanCollide = false
deadlywave2.Anchored = true
deadlywave2.Transparency = .5
deadlywave2.BrickColor = BrickColor.new("Really black")
deadlywave2.CFrame = CFrame.new(explosionwave.Position)
deadlywave2mesh = Instance.new("SpecialMesh", deadlywave2)
deadlywave2mesh.Scale = Vector3.new(3,2,3)
deadlywave2mesh.MeshId = "rbxassetid://20329976"
deadlyring = Instance.new("Part", Torso)
deadlyring.Size = Vector3.new(5, 5, 5)
deadlyring.Transparency = 0.5
deadlyring.BrickColor = BrickColor.new("Really black")
deadlyring.Anchored = true
deadlyring.CanCollide = false
deadlyring.CFrame = deadlywave.CFrame * CFrame.Angles(math.rad(math.random(-180,180)), math.rad(math.random(-180,180)), math.rad(math.random(-180,180)))
deadlyringh = Instance.new("SpecialMesh", deadlyring) 
deadlyringh.MeshId = "http://www.roblox.com/asset/?id=3270017" 
deadlyringh.Scale = Vector3.new(8, 8, .1)
deadlyring2 = Instance.new("Part", Torso)
deadlyring2.Size = Vector3.new(5, 5, 5)
deadlyring2.Transparency = 0.5
deadlyring2.BrickColor = BrickColor.new("Really black")
deadlyring2.Anchored = true
deadlyring2.CanCollide = false
deadlyring2.CFrame = deadlywave.CFrame * CFrame.Angles(math.rad(math.random(-180,180)), math.rad(math.random(-180,180)), math.rad(math.random(-180,180)))
deadlyringh2 = Instance.new("SpecialMesh", deadlyring2) 
deadlyringh2.MeshId = "http://www.roblox.com/asset/?id=3270017" 
deadlyringh2.Scale = Vector3.new(8, 8, .1)
ballzor:Remove()
bigball = false
staybooming = true
d = 5
coroutine.wrap(function()
while staybooming do
Hit = damagealll(d,deadlywave.Position)
for _,v in pairs(Hit) do			
v:FindFirstChildOfClass("Humanoid"):TakeDamage(math.random(10,20))
vel = Instance.new("BodyVelocity",v:FindFirstChild("Torso") or v:FindFirstChild("UpperTorso")) 
vel.maxForce = Vector3.new(9999999999999,9999999999999,9999999999999)
torso = v:FindFirstChild("Torso") or v:FindFirstChild("UpperTorso")
vel.velocity = CFrame.new(deadlywave.Position,torso.Position).lookVector*50
removeuseless:AddItem(vel,.1)
end
wait(.1)
end
end)()
for i = 1, 70 do
d = d + 1
deadlyringh2.Scale = deadlyringh2.Scale + Vector3.new(.5, .5, .1)
deadlyringh.Scale = deadlyringh.Scale + Vector3.new(.5, .5, .1)
deadlyring.CFrame = deadlyring.CFrame * CFrame.Angles(math.rad(0+7),math.rad(0-7),math.rad(0+7))
deadlyring2.CFrame = deadlyring2.CFrame * CFrame.Angles(math.rad(0-7),math.rad(0+7),math.rad(0-7))
deadlywave.CFrame = deadlywave.CFrame * CFrame.Angles(0,math.rad(0+7),0)
deadlywave2.CFrame = deadlywave2.CFrame * CFrame.Angles(0,math.rad(0+4),0)
deadlywavemesh.Scale = deadlywavemesh.Scale + Vector3.new(.4,0,.4)
deadlywave2mesh.Scale = deadlywave2mesh.Scale + Vector3.new(.5,0,.5)
explosionwave.Size = explosionwave.Size + Vector3.new(.5,.5,.5)
explosionwave2.Size = explosionwave2.Size + Vector3.new(.5,.5,.5)
swait()
end
for i = 1, 80 do
d = d + 3
hum.CameraOffset = Vector3.new(math.random(-1,1),math.random(-1,1),math.random(-1,1))
deadlyringh2.Scale = deadlyringh2.Scale + Vector3.new(4, 4, .2)
deadlyringh.Scale = deadlyringh.Scale + Vector3.new(4, 4, .2)
deadlyring.CFrame = deadlyring.CFrame * CFrame.Angles(math.rad(0+12),math.rad(0-12),math.rad(0+12))
deadlyring2.CFrame = deadlyring2.CFrame * CFrame.Angles(math.rad(0-12),math.rad(0+12),math.rad(0-12))
deadlywave.CFrame = deadlywave.CFrame * CFrame.Angles(0,math.rad(0+20),0)
deadlywave2.CFrame = deadlywave2.CFrame * CFrame.Angles(0,math.rad(0+14),0)
deadlywavemesh.Scale = deadlywavemesh.Scale + Vector3.new(3,2,3)
deadlywave2mesh.Scale = deadlywave2mesh.Scale + Vector3.new(4,1,4)
explosionwave.Size = explosionwave.Size + Vector3.new(4,4,4)
explosionwave2.Size = explosionwave2.Size + Vector3.new(4,4,4)
swait()
end
staybooming = false
for i = 1, 20 do
d = d + 3
hum.CameraOffset = Vector3.new(math.random(-1,1),math.random(-1,1),math.random(-1,1))
deadlyringh2.Scale = deadlyringh2.Scale + Vector3.new(4, 4, .2)
deadlyringh.Scale = deadlyringh.Scale + Vector3.new(4, 4, .2)
deadlyring.CFrame = deadlyring.CFrame * CFrame.Angles(math.rad(0+12),math.rad(0-12),math.rad(0+12))
deadlyring2.CFrame = deadlyring2.CFrame * CFrame.Angles(math.rad(0-12),math.rad(0+12),math.rad(0-12))
deadlyring.Transparency = deadlyring.Transparency + .25
deadlyring2.Transparency = deadlyring2.Transparency + .25
deadlywave.CFrame = deadlywave.CFrame * CFrame.Angles(0,math.rad(0+20),0)
deadlywave2.CFrame = deadlywave2.CFrame * CFrame.Angles(0,math.rad(0+14),0)
deadlywavemesh.Scale = deadlywavemesh.Scale + Vector3.new(3,0,3)
deadlywave2mesh.Scale = deadlywave2mesh.Scale + Vector3.new(4,0,4)
deadlywave.Transparency = deadlywave.Transparency + .25
deadlywave2.Transparency = deadlywave2.Transparency + .25
explosionwave.Size = explosionwave.Size + Vector3.new(4,4,4)
explosionwave2.Size = explosionwave2.Size + Vector3.new(4,4,4)
explosionwave.Transparency = explosionwave.Transparency + 0.25
explosionwave2.Transparency = explosionwave2.Transparency + 0.05
swait()
end
hum.CameraOffset = Vector3.new(0,0,0)
explosionwave:Remove()
explosionwave2:Remove()
end
end)
bov = Instance.new("BodyVelocity",ballzor)
bov.maxForce = Vector3.new(99999,99999,99999)
ballzor.CFrame = CFrame.new(ballzor.Position,mouse.Hit.p)
bov.velocity = ballzor.CFrame.lookVector*200
removeuseless:AddItem(ballzor,4)
ws = 50
attacking = false
debounce = false
appi = false
end
end)

mouse.KeyDown:connect(function(Press)
Press=Press:lower()
if Press=='j' then
if not levitate then return end
if debounce then return end
debounce = true
charging = true
attacking = true
downpress = false
x = 1
ws = 0
g1 = Instance.new("BodyGyro", Root)
g1.D = 175
g1.P = 20000
g1.MaxTorque = Vector3.new(0,9000,0)
SOUND(RightArm,2014087015,8,false,3)
coroutine.wrap(function()
Charge = Instance.new("Sound",RightArm)
Charge.SoundId = "rbxassetid://101153932"
Charge.Looped = false
Charge.Volume = 8
Charge:Play()
end)()
appi = true
coroutine.wrap(function()
while appi do
swait()
if Root.Velocity.Magnitude < 2 and attacking == true then
position = "Idle3"
end
end
end)()
coroutine.wrap(function()
while appi do
swait()
settime = 0.05
sine = sine + change
if position == "Idle3" and attacking == true and appi == true then
change = .4
RIGHTLEGLERP.C1 = RIGHTLEGLERP.C1:lerp(CFrame.new(0,0,0) * CFrame.Angles(math.rad(0),0,0),.1)
LEFTLEGLERP.C1 = LEFTLEGLERP.C1:lerp(CFrame.new(-.2,.2,0) * CFrame.Angles(0,0,0),.1)
LEFTARMLERP.C1 = CFrame.new(0,0,0) * CFrame.Angles(0,0,0)
LEFTARMLERP.C0 = LEFTARMLERP.C0:lerp(CFrame.new(1.6, 0.8 - .1 * math.sin(sine/9), 0) * CFrame.Angles(math.rad(0), math.rad(0 + 3 * math.sin(sine/9)), math.rad(35 - 5 * math.sin(sine/9))), 0.4)
RIGHTLEGLERP.C0 = RIGHTLEGLERP.C0:lerp(CFrame.new(-0.54, 1.4 + .1 * math.sin(sine/9), .4) * CFrame.Angles(math.rad(9 + 2 * math.cos(sine/9)), math.rad(0), math.rad(0)), 0.4)
LEFTLEGLERP.C0 = LEFTLEGLERP.C0:lerp(CFrame.new(0.5, 2.0,0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(-10 + 2 * math.sin(sine/9))), 0.4)
end
end
end)()
for i = 1, 15 do
g1.CFrame = g1.CFrame:lerp(CFrame.new(Root.Position,mouse.Hit.p),.2)
ROOTLERP.C0 = ROOTLERP.C0:lerp(CFrame.new(0,0,0) * CFrame.Angles(math.rad(-10),math.rad(-15),math.rad(0)),.5)
RIGHTARMLERP.C1 = CFrame.new(0,0,0) * CFrame.Angles(0,0,0)
RIGHTARMLERP.C0 = RIGHTARMLERP.C0:lerp(CFrame.new(-0.5, 2, 0) * CFrame.Angles(math.rad(14), math.rad(20), math.rad(-90)), 0.3)
swait()
end
for i = 1, 3 do
g1.CFrame = g1.CFrame:lerp(CFrame.new(Root.Position,mouse.Hit.p),.4)
ROOTLERP.C0 = ROOTLERP.C0:lerp(CFrame.new(0,0,0) * CFrame.Angles(math.rad(-10),math.rad(-15),math.rad(0)),.5)
RIGHTARMLERP.C1 = CFrame.new(0,0,0) * CFrame.Angles(0,0,0)
RIGHTARMLERP.C0 = RIGHTARMLERP.C0:lerp(CFrame.new(-0.5, 2, 0) * CFrame.Angles(math.rad(14), math.rad(20), math.rad(-90)), 0.3)
x = x + .1
blastborb = Instance.new("Part",Torso)
blastborb.CFrame = rightlocation.CFrame * CFrame.Angles(math.rad(math.random(-180,180)),math.rad(math.random(-180,180)),math.rad(math.random(-180,180)))
blastborb.BrickColor = BrickColor.new(colors)
blastborb.Anchored = true
blastborb.Size = Vector3.new(10,10,10)
blastborb.CanCollide = false
blastborb.Material = "Neon"
for i = 1, 5 do
g1.CFrame = g1.CFrame:lerp(CFrame.new(Root.Position,mouse.Hit.p),.4)
blastborb.Size = blastborb.Size - Vector3.new(1,1,1)
swait()
end
blastborb:Remove()
swait()
end
downpress = true
while charging and x < 5  do
g1.CFrame = g1.CFrame:lerp(CFrame.new(Root.Position,mouse.Hit.p),.4)
ROOTLERP.C0 = ROOTLERP.C0:lerp(CFrame.new(0,0,0) * CFrame.Angles(math.rad(-10),math.rad(-15),math.rad(0)),.5)
RIGHTARMLERP.C1 = CFrame.new(0,0,0) * CFrame.Angles(0,0,0)
RIGHTARMLERP.C0 = RIGHTARMLERP.C0:lerp(CFrame.new(-0.5, 2, 0) * CFrame.Angles(math.rad(14), math.rad(20), math.rad(-90)), 0.3)
x = x + .1
blastborb = Instance.new("Part",Torso)
blastborb.CFrame = rightlocation.CFrame * CFrame.Angles(math.rad(math.random(-180,180)),math.rad(math.random(-180,180)),math.rad(math.random(-180,180)))
blastborb.BrickColor = BrickColor.new(colors)
blastborb.Anchored = true
blastborb.Size = Vector3.new(10,10,10)
blastborb.CanCollide = false
blastborb.Material = "Neon"
for i = 1, 5 do
g1.CFrame = g1.CFrame:lerp(CFrame.new(Root.Position,mouse.Hit.p),.4)
blastborb.Size = blastborb.Size - Vector3.new(1,1,1)
swait()
end
blastborb:Remove()
swait()
end
coroutine.wrap(function()
for i = 1, 20 do
Charge.Volume = Charge.Volume - .5
swait()
end
end)()
local bigswoosh = Instance.new("Part",Torso)
bigswoosh.Name = "bigswoosh"
bigswoosh.CFrame = Root.CFrame * CFrame.new(1,0,-5)
bigswoosh.Size = Vector3.new(1,1,1)
bigswoosh.Material = "Neon"
bigswoosh.Anchored = true
bigswoosh.Transparency = 1
bigswoosh.BrickColor = BrickColor.new("Really red")
bigswoosh.CanCollide = false
SOUND(bigswoosh,842332424,10,false,6)
SOUND(bigswoosh,2017948224,10,false,6)
SOUND(bigswoosh,138677306,10,false,4)
coroutine.wrap(function()
local loc1 = Instance.new("Part",bigswoosh)
loc1.CFrame = bigswoosh.CFrame * CFrame.new(-3,0,0)
loc1.Size = Vector3.new(2,2,2)
loc1.Anchored = true
loc1.Transparency = 1
loc1.CanCollide = false
local loc2 = Instance.new("Part",bigswoosh)
loc2.CFrame = bigswoosh.CFrame * CFrame.new(3,0,0)
loc2.Size = Vector3.new(2,2,2)
loc2.Anchored = true
loc2.Transparency = 1
loc2.CanCollide = false
n = 0
nb = 0
for i = 1, 125 do
n = n + x
nb = nb - x
Hit = damagealll(n,bigswoosh.Position)
for _,v in pairs(Hit) do
if x > 4.5 then		
v:FindFirstChildOfClass("Humanoid").Parent:BreakJoints()
else	
v:FindFirstChildOfClass("Humanoid"):TakeDamage(math.random(4+x,10+x))
end
vel = Instance.new("BodyVelocity",v:FindFirstChild("Torso") or v:FindFirstChild("UpperTorso")) 
vel.maxForce = Vector3.new(9999999999999,9999999999999,9999999999999)
torso = v:FindFirstChild("Torso") or v:FindFirstChild("UpperTorso")
vel.velocity = CFrame.new(bigswoosh.Position,torso.Position).lookVector*150
removeuseless:AddItem(vel,.1)
end
local bigtrail = Instance.new("Part",LeftArm)
bigtrail.Size = bigswoosh.Size
bigtrail.BrickColor = BrickColor.new(colors)
bigtrail.Anchored = true
bigtrail.Material = "Neon"
bigtrail.CFrame = bigswoosh.CFrame * CFrame.Angles(math.rad(math.random(-180,180)),math.rad(math.random(-180,180)),math.rad(math.random(-180,180)))
bigtrail.CanCollide = false
removeuseless:AddItem(bigtrail,2)
local irritatedground = Instance.new("Part",Torso)
irritatedground.Size = Vector3.new(n*1.5,1,3*x)
irritatedground.BrickColor = BrickColor.new(colors)
irritatedground.Material = "Neon"
irritatedground.CFrame = bigswoosh.CFrame * CFrame.new(0,-6,0)
irritatedground.CanCollide = false
irritatedground.Anchored = true
removeuseless:AddItem(irritatedground,10)
local grassblocks = Instance.new("Part",Torso)
grassblocks.Size = Vector3.new(n/2,n/2,n/2)
grassblocks.Material = "Grass"
grassblocks.Anchored = true
grassblocks.Name = "grassblocks"
grassblocks.BrickColor = BrickColor.new("Bright green")
grassblocks.CFrame = loc1.CFrame * CFrame.new(0,-1,0) * CFrame.Angles(math.rad(math.random(-180,180)),math.rad(math.random(-180,180)),math.rad(math.random(-180,180)))
removeuseless:AddItem(grassblocks,10)
local grassblocks2 = Instance.new("Part",Torso)
grassblocks2.Size = Vector3.new(n/2,n/2,n/2)
grassblocks2.Material = "Grass"
grassblocks2.Anchored = true
grassblocks2.Name = "grassblocks2"
grassblocks2.BrickColor = BrickColor.new("Bright green")
grassblocks2.CFrame = loc2.CFrame * CFrame.new(0,-1,0) * CFrame.Angles(math.rad(math.random(-180,180)),math.rad(math.random(-180,180)),math.rad(math.random(-180,180)))
removeuseless:AddItem(grassblocks2,10)
bigswoosh.Size = bigswoosh.Size + Vector3.new(x,x,x)
loc1.CFrame = bigswoosh.CFrame * CFrame.new(n,-3,0)
loc2.CFrame = bigswoosh.CFrame * CFrame.new(nb,-3,0)
bigswoosh.CFrame = bigswoosh.CFrame * CFrame.new(0,0,-3 - x)
swait()
end
for i = 1, 20 do
bigswoosh.CFrame = bigswoosh.CFrame * CFrame.new(0,0,-3)
bigswoosh.Transparency = bigswoosh.Transparency + 0.05
swait()
end
bigswoosh:Remove()
end)()
for i = 1, 50 do
ROOTLERP.C0 = ROOTLERP.C0:lerp(CFrame.new(0,0,0) * CFrame.Angles(math.rad(10),math.rad(15),math.rad(0)),.5)
RIGHTARMLERP.C1 = CFrame.new(0,0,0)
RIGHTARMLERP.C0 = RIGHTARMLERP.C0:lerp(CFrame.new(-1.2,1,.5) * CFrame.Angles(math.rad(-90),math.rad(-25),math.rad(0)), 0.5)
swait()
end
ws = 50
attacking = false
debounce = false
appi = false
g1:Remove()
end
end)

mouse.KeyDown:connect(function(Press)
Press=Press:lower()
if Press=='k' then
if not levitate then return end
if debounce then return end
debounce = true
attacking = true
charging = true
appi = true
coroutine.wrap(function()
while appi do
swait()
if Root.Velocity.Magnitude < 2 and attacking == true then
position = "Idle3"
end
end
end)()
coroutine.wrap(function()
while appi do
swait()
settime = 0.05
sine = sine + change
if position == "Idle3" and attacking == true and appi == true then
change = .4
RIGHTLEGLERP.C1 = RIGHTLEGLERP.C1:lerp(CFrame.new(0,0,0) * CFrame.Angles(math.rad(0),0,0),.1)
LEFTLEGLERP.C1 = LEFTLEGLERP.C1:lerp(CFrame.new(-.2,.2,0) * CFrame.Angles(0,0,0),.1)
LEFTARMLERP.C1 = CFrame.new(0,0,0) * CFrame.Angles(0,0,0)
LEFTARMLERP.C0 = LEFTARMLERP.C0:lerp(CFrame.new(1.6, 0.8 - .1 * math.sin(sine/9), 0) * CFrame.Angles(math.rad(0), math.rad(0 + 3 * math.sin(sine/9)), math.rad(35 - 5 * math.sin(sine/9))), 0.4)
RIGHTLEGLERP.C0 = RIGHTLEGLERP.C0:lerp(CFrame.new(-0.54, 1.4 + .1 * math.sin(sine/9), .4) * CFrame.Angles(math.rad(9 + 2 * math.cos(sine/9)), math.rad(0), math.rad(0)), 0.4)
LEFTLEGLERP.C0 = LEFTLEGLERP.C0:lerp(CFrame.new(0.5, 2.0,0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(-10 + 2 * math.sin(sine/9))), 0.4)
end
end
end)()
ws = 0
g1 = Instance.new("BodyGyro", Root)
g1.D = 175
g1.P = 20000
g1.MaxTorque = Vector3.new(0,9000,0)
g1.CFrame = CFrame.new(Root.Position,mouse.Hit.p)
for i = 1, 15 do
g1.CFrame = g1.CFrame:lerp(CFrame.new(Root.Position,mouse.Hit.p),.3)
ROOTLERP.C0 = ROOTLERP.C0:lerp(CFrame.new(0,0,0) * CFrame.Angles(math.rad(0),math.rad(90),math.rad(0)),.3)
RIGHTARMLERP.C1 = CFrame.new(0,0,0) * CFrame.Angles(0,0,0)
RIGHTARMLERP.C0 = RIGHTARMLERP.C0:lerp(CFrame.new(-.5, 2, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(-90)), 0.3)
swait()
end
r = 0
for i = 1, 10 do
r = r + .1
g1.CFrame = g1.CFrame:lerp(CFrame.new(Root.Position,mouse.Hit.p),.3)
blass = Instance.new("Part",RightArm)
blass.Size = Vector3.new(r,r,r)
blass.Material = "Neon"
blass.CFrame = rightlocation.CFrame * CFrame.new(0,-r/1.5,0) * CFrame.Angles(math.rad(math.random(-180,180)),math.rad(math.random(-180,180)),math.rad(math.random(-180,180)))
blass.Anchored = true
blass.CanCollide = false
blass.BrickColor = BrickColor.new(colors)
removeuseless:AddItem(blass,2)
swait()
end
while r < 16 and charging == true do
r = r + .1
g1.CFrame = g1.CFrame:lerp(CFrame.new(Root.Position,mouse.Hit.p),.3)
blass = Instance.new("Part",RightArm)
blass.Size = Vector3.new(r,r,r)
blass.Material = "Neon"
blass.CFrame = rightlocation.CFrame * CFrame.new(0,-r/1.5,0) * CFrame.Angles(math.rad(math.random(-180,180)),math.rad(math.random(-180,180)),math.rad(math.random(-180,180)))
blass.Anchored = true
blass.CanCollide = false
blass.BrickColor = BrickColor.new(colors)
removeuseless:AddItem(blass,2)
swait()
end
local TheBeam = Instance.new("Part",RightArm)
TheBeam.Name = "zebeam"
TheBeam.Size = Vector3.new(1,1,1)
TheBeam.Material = "Neon"
TheBeam.Shape = "Cylinder"
TheBeam.BrickColor = BrickColor.new("Really red")
TheBeam.Anchored = true
TheBeam.CanCollide = false
ws = 12
bemmo = Instance.new("Sound",RightArm)
bemmo.SoundId = "rbxassetid://1910988873"
bemmo.Volume = 8
bemmo.Looped = false
bemmo:Play()
bemmo.TimePosition = 2
for i = 1, 100 * r/3 do
if r > 15 then
hum.CameraOffset = Vector3.new(math.random(-1,1),math.random(-1,1),math.random(-0,0))
end
g1.CFrame = g1.CFrame:lerp(CFrame.new(Root.Position,mouse.Hit.p),.3)
local blass = Instance.new("Part",RightArm)
blass.Size = Vector3.new(r,r,r)
blass.Material = "Neon"
blass.CFrame = rightlocation.CFrame * CFrame.new(0,-r/1.5,0) * CFrame.Angles(math.rad(math.random(-180,180)),math.rad(math.random(-180,180)),math.rad(math.random(-180,180)))
blass.Anchored = true
blass.CanCollide = false
blass.BrickColor = BrickColor.new(colors)
removeuseless:AddItem(blass,2)
local STARTPOS = blass.CFrame*CFrame.new(0,0,0).p
local ENDHIT,ENDPOS = ray2(STARTPOS,mouse.Hit.p,650,Character)
local DISTANCE = (STARTPOS - ENDPOS).magnitude
TheBeam.CFrame = CFrame.new(STARTPOS,ENDPOS)*CFrame.new(0,0,-DISTANCE/2) * CFrame.Angles(math.rad(0),math.rad(90),math.rad(0))
TheBeam.Size = Vector3.new(DISTANCE,r/math.random(1,2),r/math.random(1,2))
boom = Instance.new("Part",RightArm)
boom.Size = Vector3.new(r,r,r)
boom.BrickColor = BrickColor.new(colors)
boom.Anchored = true
boom.CanCollide = false
boom.Material = "Neon"
boom.CFrame = CFrame.new(ENDPOS) * CFrame.Angles(math.rad(math.random(-180,180)),math.rad(math.random(-180,180)),math.rad(math.random(-180,180)))
removeuseless:AddItem(boom,3)
boom.Touched:connect(function(getbase)
if hitdebounce then return end
hitdebounce = true
if getbase:IsA("Part") then
damagedground = Instance.new("Part",RightArm)
damagedground.Size = Vector3.new(.1,5+r,.1)
damagedground.Material = "Neon"
damagedground.CanCollide = false
damagedground.BrickColor = BrickColor.new(colors)
damagedground.Anchored = true
damagedground.CFrame = boom.CFrame * CFrame.Angles(math.rad(math.random(-180,180)),math.rad(math.random(-180,180)),math.rad(math.random(-180,180)))
removeuseless:AddItem(damagedground,2)
wait(.1)
hitdebounce = false
end
end)
Hit = damagealll(r+3,boom.Position)
for _,v in pairs(Hit) do	
v:FindFirstChildOfClass("Humanoid"):TakeDamage(math.random(r/1.1,r))
vel = Instance.new("BodyVelocity",v:FindFirstChild("Torso") or v:FindFirstChild("UpperTorso")) 
vel.maxForce = Vector3.new(9999999999999,9999999999999,9999999999999)
torso = v:FindFirstChild("Torso") or v:FindFirstChild("UpperTorso")
vel.velocity = CFrame.new(boom.Position,torso.Position).lookVector*r
removeuseless:AddItem(vel,.1)
end
swait()
end
removeuseless:AddItem(g1,.001)
coroutine.wrap(function()
for i = 1, 20 do
bemmo.Volume = bemmo.Volume - 0.5
blass.Transparency = blass.Transparency + 0.05
TheBeam.Transparency = TheBeam.Transparency + 0.05
swait()
end
bemmo:Remove()
if r > 15 then
hum.CameraOffset = Vector3.new(0,0,0)
end
blass:Remove()
TheBeam:Remove()
end)()
ws = 50
appi = false
attacking = false
debounce = false
end
end)

mouse.KeyUp:connect(function(Press)
Press=Press:lower()
if Press=='j' then
charging = false
end
end)

mouse.KeyUp:connect(function(Press)
Press=Press:lower()
if Press=='k' then
charging = false
end
end)

doit = coroutine.wrap(function()
while true do
for _,v in pairs(Repeater) do
v.Scale =  v.Scale + Vector3.new(1, 1, 1)
end

for _,v in pairs(openshocktable) do
v.Scale =  v.Scale + Vector3.new(3, 3, 3)
end

for _,v in pairs(nonmeshRepeater) do
v.Size =  v.Size + Vector3.new(2, 2, 2)
end

for _,v in pairs(Extreme) do
v.Size =  v.Size + Vector3.new(6, 6, 6)
end

for _,v in pairs(LessSize) do
v.Size = v.Size - Vector3.new(1, 1, 1)
end

for _,v in pairs(nonmeshRepeater2) do
v.Transparency = v.Transparency + 0.05
end

for _,v in pairs(Repeater2) do
v.Transparency = v.Transparency - 0.05
end

for _,v in pairs(th1) do
v.CFrame = v.CFrame * CFrame.new(0,0+.3,0) * CFrame.Angles(0,math.rad(0+8),0)
end

for _,v in pairs(th2) do
v.CFrame = v.CFrame * CFrame.new(0,0,0) * CFrame.Angles(0,math.rad(0+15),0)
end

for _,v in pairs(th3) do
v.Scale = v.Scale + Vector3.new(2, 2, 2)
end

for _,v in pairs(th5) do
v.Scale = v.Scale + Vector3.new(1, .1, 1)
end

for _,v in pairs(ExtremeM) do
v.Size = v.Size + Vector3.new(8, 8, 8)
end

for _,v in pairs(m3) do
v.Scale = v.Scale + Vector3.new(.2,.2,.2)
end

for _,v in pairs(ExtremeM2) do
v.Size = v.Size - Vector3.new(2,2,2)
end

for _,v in pairs(keyYsize) do
v.Scale = v.Scale + Vector3.new(8, 8, 1)
end

for _,v in pairs(th4) do
v.Transparency = v.Transparency + 0.009
v.Rotation = v.Rotation + Vector3.new(3,0,0)
end

for _,v in pairs(SlowlyFade) do
v.Transparency = v.Transparency + 0.05
end

for _,v in pairs(keyYtransparency) do
v.Transparency = v.Transparency + 0.05
end

for _,v in pairs(UpMover) do
v.Position = v.Position + Vector3.new(0, 3, 0)
end

for _,v in pairs(ForwardMover) do
v.CFrame = v.CFrame * CFrame.new(0, 0, 2.4 +(i/.1)) * CFrame.Angles(0, 0, math.rad(0))
end

for _,v in pairs(FadeIn) do
v.Transparency = v.Transparency - .05
end

for _,v in pairs(signtransparency) do
v.TextTransparency = v.TextTransparency + 0.025
end

for _,v in pairs(signmover) do
v.StudsOffset = v.StudsOffset + Vector3.new(math.random(-2,2),.3,math.random(-2,2))
end

for _,v in pairs(signrotator) do
v.Rotation = v.Rotation + 2
end
swait()
end
end)
doit()
t = 0

mouse.KeyDown:connect(function(Press)
Press=Press:lower()
if Press=='0' then
if levitate then return end
shoov = true
if debounce then return end
ws = 50
end
end)

mouse.KeyUp:connect(function(Press)
Press=Press:lower()
if Press=='0' then
if levitate then return end
shoov = false
if debounce then return end
ws = 10
end
end)


local anims = coroutine.wrap(function()
while true do
settime = 0.05
sine = sine + change
if position == "Jump" and attacking == false then
change = 1
LEFTLEGLERP.C1 = LEFTLEGLERP.C1:lerp(CFrame.new(0,0,0) * CFrame.Angles(0,0,0),.1)
RIGHTLEGLERP.C1 = RIGHTLEGLERP.C1:lerp(CFrame.new(0,0,0) * CFrame.Angles(math.rad(0),0,0),.1)
LEFTARMLERP.C1 = LEFTARMLERP.C1:lerp(CFrame.new(0,0,0) * CFrame.Angles(0,0,0),.4)
RIGHTARMLERP.C1 = RIGHTARMLERP.C1:lerp(CFrame.new(0,0,0) * CFrame.Angles(0,0,0),.4)
ROOTLERP.C0 = ROOTLERP.C0:lerp(CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0)), 0.4)
LEFTARMLERP.C0 = LEFTARMLERP.C0:lerp(CFrame.new(1.4,.1,-.2) * CFrame.Angles(math.rad(20),math.rad(-3),math.rad(-4)), 0.4)
RIGHTARMLERP.C0 = RIGHTARMLERP.C0:lerp(CFrame.new(-1.4,.1,-.2) * CFrame.Angles(math.rad(20),math.rad(3),math.rad(4)), 0.4)
RIGHTLEGLERP.C0 = RIGHTLEGLERP.C0:lerp(CFrame.new(-0.5, 2, 0) * CFrame.Angles(math.rad(10), math.rad(0), math.rad(0)), 0.4)
LEFTLEGLERP.C0 = LEFTLEGLERP.C0:lerp(CFrame.new(0.5, 1.0, .9) * CFrame.Angles(math.rad(20), math.rad(0), math.rad(0)), 0.4)
elseif position == "Jump2" and attacking == false and levitate then
change = 1
ROOTLERP.C0 = ROOTLERP.C0:lerp(CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(-20 - 1 * math.sin(sine/9)), math.rad(0 + 0 * math.cos(sine/8)), math.rad(0) + Root.RotVelocity.Y / 30, math.cos(10 * math.cos(sine/10))), 0.3)
LEFTLEGLERP.C1 = LEFTLEGLERP.C1:lerp(CFrame.new(0,0,0) * CFrame.Angles(0,0,0),.3)
RIGHTLEGLERP.C1 = RIGHTLEGLERP.C1:lerp(CFrame.new(0,0,0) * CFrame.Angles(math.rad(0),0,0),.3)
RIGHTARMLERP.C0 = RIGHTARMLERP.C0:lerp(CFrame.new(-1.5,.6,-.5) * CFrame.Angles(math.rad(32),math.rad(5 - .1 * math.sin(sine/12)),math.rad(40 - .5 * math.sin(sine/12))), 0.3)
RIGHTARMLERP.C1 = RIGHTARMLERP.C1:lerp(CFrame.new(-.2,1.2,-.3),.3)
LEFTARMLERP.C0 = LEFTARMLERP.C0:lerp(CFrame.new(1.5,.6,-.5) * CFrame.Angles(math.rad(30),math.rad(-5 + .1 * math.sin(sine/12)),math.rad(-40 + .5 * math.sin(sine/12))), 0.3)
LEFTARMLERP.C1 = LEFTARMLERP.C1:lerp(CFrame.new(.2,1.2,-.3),.3)
RIGHTLEGLERP.C0 = RIGHTLEGLERP.C0:lerp(CFrame.new(-0.54, 1.4 + .1 * math.sin(sine/9), .4) * CFrame.Angles(math.rad(9 + 2 * math.cos(sine/9)), math.rad(0), math.rad(0)), 0.3)
LEFTLEGLERP.C0 = LEFTLEGLERP.C0:lerp(CFrame.new(0.54, 2.0 + .02 * math.sin(sine/9), 0.2 + .1 * math.sin(sine/9)) * CFrame.Angles(math.rad(25 + 5 * math.sin(sine/9)), math.rad(20), math.rad(0)), 0.3)
elseif position == "Falling" and attacking == false and levitate == false then
change = 1
LEFTLEGLERP.C1 = LEFTLEGLERP.C1:lerp(CFrame.new(0,0,0) * CFrame.Angles(0,0,0),.1)
RIGHTLEGLERP.C1 = RIGHTLEGLERP.C1:lerp(CFrame.new(0,0,0) * CFrame.Angles(math.rad(0),0,0),.1)
LEFTARMLERP.C1 = LEFTARMLERP.C1:lerp(CFrame.new(0,0,0) * CFrame.Angles(0,0,0),.4)
RIGHTARMLERP.C1 = RIGHTARMLERP.C1:lerp(CFrame.new(0,0,0) * CFrame.Angles(0,0,0),.4)
RIGHTLEGLERP.C0 = RIGHTLEGLERP.C0:lerp(CFrame.new(-0.5, 2, 0) * CFrame.Angles(math.rad(8), math.rad(4), math.rad(0)), 0.2)
LEFTLEGLERP.C0 = LEFTLEGLERP.C0:lerp(CFrame.new(0.5, 1.0, .9) * CFrame.Angles(math.rad(14), math.rad(-4), math.rad(0)), 0.2)
LEFTARMLERP.C0 = LEFTARMLERP.C0:lerp(CFrame.new(1.6, 0.5, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(20)), 0.2)
RIGHTARMLERP.C0 = RIGHTARMLERP.C0:lerp(CFrame.new(-1.6, 0.5, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(-20)), 0.2)
elseif position == "Falling2" and attacking == false and levitate then
change = 1
ROOTLERP.C0 = ROOTLERP.C0:lerp(CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(-20 - 1 * math.sin(sine/9)), math.rad(0 + 0 * math.cos(sine/8)), math.rad(0) + Root.RotVelocity.Y / 30, math.cos(10 * math.cos(sine/10))), 0.3)
LEFTLEGLERP.C1 = LEFTLEGLERP.C1:lerp(CFrame.new(0,0,0) * CFrame.Angles(0,0,0),.3)
RIGHTLEGLERP.C1 = RIGHTLEGLERP.C1:lerp(CFrame.new(0,0,0) * CFrame.Angles(math.rad(0),0,0),.3)
RIGHTARMLERP.C0 = RIGHTARMLERP.C0:lerp(CFrame.new(-1.5,.6,-.5) * CFrame.Angles(math.rad(32),math.rad(5 - .1 * math.sin(sine/12)),math.rad(40 - .5 * math.sin(sine/12))), 0.3)
RIGHTARMLERP.C1 = RIGHTARMLERP.C1:lerp(CFrame.new(-.2,1.2,-.3),.3)
LEFTARMLERP.C0 = LEFTARMLERP.C0:lerp(CFrame.new(1.5,.6,-.5) * CFrame.Angles(math.rad(30),math.rad(-5 + .1 * math.sin(sine/12)),math.rad(-40 + .5 * math.sin(sine/12))), 0.3)
LEFTARMLERP.C1 = LEFTARMLERP.C1:lerp(CFrame.new(.2,1.2,-.3),.3)
RIGHTLEGLERP.C0 = RIGHTLEGLERP.C0:lerp(CFrame.new(-0.54, 1.4 + .1 * math.sin(sine/9), .4) * CFrame.Angles(math.rad(9 + 2 * math.cos(sine/9)), math.rad(0), math.rad(0)), 0.3)
LEFTLEGLERP.C0 = LEFTLEGLERP.C0:lerp(CFrame.new(0.54, 2.0 + .02 * math.sin(sine/9), 0.2 + .1 * math.sin(sine/9)) * CFrame.Angles(math.rad(25 + 5 * math.sin(sine/9)), math.rad(20), math.rad(0)), 0.3)
elseif position == "Walking" and attacking == false and running == false then
change = 1
walking = true
LEFTLEGLERP.C1 = LEFTLEGLERP.C1:lerp(CFrame.new(0,0,0) * CFrame.Angles(0,0,0),.1)
RIGHTLEGLERP.C1 = RIGHTLEGLERP.C1:lerp(CFrame.new(0,0,0) * CFrame.Angles(math.rad(0),0,0),.1)
RIGHTARMLERP.C0 = RIGHTARMLERP.C0:lerp(CFrame.new(-1.5,.6,-.5) * CFrame.Angles(math.rad(32),math.rad(5 - .1 * math.sin(sine/12)),math.rad(40 - .5 * math.sin(sine/12))), 0.3)
RIGHTARMLERP.C1 = RIGHTARMLERP.C1:lerp(CFrame.new(-.2,1.2,-.3),.3)
LEFTARMLERP.C0 = LEFTARMLERP.C0:lerp(CFrame.new(1.5,.6,-.5) * CFrame.Angles(math.rad(30),math.rad(-5 + .1 * math.sin(sine/12)),math.rad(-40 + .5 * math.sin(sine/12))), 0.3)
LEFTARMLERP.C1 = LEFTARMLERP.C1:lerp(CFrame.new(.2,1.2,-.3),.3)
ROOTLERP.C0 = ROOTLERP.C0:lerp(CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(-10), math.rad(5 * math.cos(sine/7)), math.rad(0) + Root.RotVelocity.Y / 30, math.cos(25 * math.cos(sine/10))), 0.3)
RIGHTLEGLERP.C0 = RIGHTLEGLERP.C0:lerp(CFrame.new(-0.5, 1.92 - 0.35 * math.cos(sine/8)/2.8, 0.2 - math.sin(sine/8)/3.4) * CFrame.Angles(math.rad(10) + -math.sin(sine/8)/2.3, math.rad(0)*math.cos(sine/1), math.rad(0)  + RightLeg.RotVelocity.Y / 30, math.cos(25 * math.cos(sine/8))), 0.3)
LEFTLEGLERP.C0 = LEFTLEGLERP.C0:lerp(CFrame.new(0.5, 1.92 + 0.35 * math.cos(sine/8)/2.8, 0.2 + math.sin(sine/8)/3.4) * CFrame.Angles(math.rad(10) - -math.sin(sine/8)/2.3, math.rad(0)*math.cos(sine/1), math.rad(0)  + LeftLeg.RotVelocity.Y / 30, math.cos(25 * math.cos(sine/8))), 0.3)
elseif position == "Idle" and attacking == false and running == false and not levitate then
change = .5
ROOTLERP.C0 = ROOTLERP.C0:lerp(CFrame.new(0, -.2 + -.1 * math.sin(sine/12), 0) * CFrame.Angles(math.rad(0),math.rad(25),math.rad(0)),.1)
RIGHTARMLERP.C0 = RIGHTARMLERP.C0:lerp(CFrame.new(-1.5,.6,-.5) * CFrame.Angles(math.rad(32),math.rad(5 - 1 * math.sin(sine/12)),math.rad(40 - 2 * math.sin(sine/12))), 0.1)
RIGHTARMLERP.C1 = RIGHTARMLERP.C1:lerp(CFrame.new(-.2,1.2,-.3),.1)
LEFTARMLERP.C0 = LEFTARMLERP.C0:lerp(CFrame.new(1.5,.6,-.5) * CFrame.Angles(math.rad(30),math.rad(-5 + 1 * math.sin(sine/12)),math.rad(-40 + 2 * math.sin(sine/12))), 0.1)
LEFTARMLERP.C1 = LEFTARMLERP.C1:lerp(CFrame.new(.2,1.2,-.3),.1)
RIGHTLEGLERP.C1 = RIGHTLEGLERP.C1:lerp(CFrame.new(0,0,0) * CFrame.Angles(math.rad(0),0,0),.1)
RIGHTLEGLERP.C0 = RIGHTLEGLERP.C0:lerp(CFrame.new(-0.3, 2 - .1 * math.sin(sine/12), 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(-10)), 0.1)
LEFTLEGLERP.C1 = LEFTLEGLERP.C1:lerp(CFrame.new(0,0,0) * CFrame.Angles(0,0,0),.1)
LEFTLEGLERP.C0 = LEFTLEGLERP.C0:lerp(CFrame.new(0.3, 2.0 - .1 * math.sin(sine/12), 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(10)), 0.1)
elseif position == "Idle2" and attacking == false and running == false then
change = .75
ROOTLERP.C0 = ROOTLERP.C0:lerp(CFrame.new(0,0,0) * CFrame.Angles(math.rad(0 - 3 * math.sin(sine/9)),0,0),.1)
RIGHTLEGLERP.C1 = RIGHTLEGLERP.C1:lerp(CFrame.new(0,0,0) * CFrame.Angles(math.rad(0),0,0),.1)
LEFTLEGLERP.C1 = LEFTLEGLERP.C1:lerp(CFrame.new(-.2,.2,0) * CFrame.Angles(0,0,0),.1)
LEFTARMLERP.C1 = CFrame.new(0,0,0) * CFrame.Angles(0,0,0)
RIGHTARMLERP.C1 = CFrame.new(0,0,0) * CFrame.Angles(0,0,0)
LEFTARMLERP.C0 = LEFTARMLERP.C0:lerp(CFrame.new(1.6, 0.8 - .1 * math.sin(sine/9), 0) * CFrame.Angles(math.rad(0), math.rad(0 + 3 * math.sin(sine/9)), math.rad(35 - 5 * math.sin(sine/9))), 0.4)
RIGHTARMLERP.C0 = RIGHTARMLERP.C0:lerp(CFrame.new(-1.6, 0.8 - .1 * math.sin(sine/9), 0) * CFrame.Angles(math.rad(0), math.rad(0 - 3 * math.sin(sine/9)), math.rad(-35 + 5 * math.sin(sine/9))), 0.4)
RIGHTLEGLERP.C0 = RIGHTLEGLERP.C0:lerp(CFrame.new(-0.54, 1.4 + .1 * math.sin(sine/9), .4) * CFrame.Angles(math.rad(9 + 2 * math.cos(sine/9)), math.rad(0), math.rad(0)), 0.4)
LEFTLEGLERP.C0 = LEFTLEGLERP.C0:lerp(CFrame.new(0.5, 2.0,0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(-10 + 2 * math.sin(sine/9))), 0.4)
elseif position == "Walking2" and attacking == false and running == false then
ws = 50
ROOTLERP.C0 = ROOTLERP.C0:lerp(CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(-20 - 1 * math.sin(sine/9)), math.rad(0 + 0 * math.cos(sine/8)), math.rad(0) + Root.RotVelocity.Y / 30, math.cos(10 * math.cos(sine/10))), 0.3)
LEFTLEGLERP.C1 = LEFTLEGLERP.C1:lerp(CFrame.new(0,0,0) * CFrame.Angles(0,0,0),.3)
RIGHTLEGLERP.C1 = RIGHTLEGLERP.C1:lerp(CFrame.new(0,0,0) * CFrame.Angles(math.rad(0),0,0),.3)
RIGHTARMLERP.C0 = RIGHTARMLERP.C0:lerp(CFrame.new(-1.5,.6,-.5) * CFrame.Angles(math.rad(32),math.rad(5 - .1 * math.sin(sine/12)),math.rad(40 - .5 * math.sin(sine/12))), 0.3)
RIGHTARMLERP.C1 = RIGHTARMLERP.C1:lerp(CFrame.new(-.2,1.2,-.3),.3)
LEFTARMLERP.C0 = LEFTARMLERP.C0:lerp(CFrame.new(1.5,.6,-.5) * CFrame.Angles(math.rad(30),math.rad(-5 + .1 * math.sin(sine/12)),math.rad(-40 + .5 * math.sin(sine/12))), 0.3)
LEFTARMLERP.C1 = LEFTARMLERP.C1:lerp(CFrame.new(.2,1.2,-.3),.3)
RIGHTLEGLERP.C0 = RIGHTLEGLERP.C0:lerp(CFrame.new(-0.54, 1.4 + .1 * math.sin(sine/9), .4) * CFrame.Angles(math.rad(9 + 2 * math.cos(sine/9)), math.rad(0), math.rad(0)), 0.3)
LEFTLEGLERP.C0 = LEFTLEGLERP.C0:lerp(CFrame.new(0.54, 2.0 + .02 * math.sin(sine/9), 0.2 + .1 * math.sin(sine/9)) * CFrame.Angles(math.rad(25 + 5 * math.sin(sine/9)), math.rad(20), math.rad(0)), 0.3)
elseif position == "Running" and attacking == false then
change = 1
RIGHTARMLERP.C1 = RIGHTARMLERP.C1:lerp(CFrame.new(1.24+.6*math.sin(sine/4)/1.4, 0.54, 0+0.8*math.sin(sine/4)) * CFrame.Angles(math.rad(6-140*math.sin(sine/4)/1.2), math.rad(0), math.rad(-20+70*math.sin(sine/4))), 0.3)
RIGHTARMLERP.C0 = RIGHTARMLERP.C0:lerp(CFrame.new(0, .5, 0)*CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)), 0.3)
LEFTARMLERP.C1 = LEFTARMLERP.C1:lerp(CFrame.new(-1.24+.6*math.sin(sine/4)/1.4, 0.54, 0-0.8*math.sin(sine/4))*CFrame.Angles(math.rad(6+140*math.sin(sine/4)/1.2), math.rad(0), math.rad(20+70*math.sin(sine/4))), 0.3)
LEFTARMLERP.C0 = LEFTARMLERP.C0:lerp(CFrame.new(0,.5,0)*CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),.3)
ROOTLERP.C0 = ROOTLERP.C0:lerp(CFrame.new(0, -.2, 0) * CFrame.Angles(math.rad(-20 - 0 * math.sin(sine/4)), math.rad(0 + 6 * math.sin(sine/4)), math.rad(0) + Root.RotVelocity.Y / 30, math.sin(10 * math.sin(sine/4))), 0.3)
RIGHTLEGLERP.C1 = RIGHTLEGLERP.C1:lerp(CFrame.new(0,0,-.2 + .5*-math.sin(sine/4)),.3)
RIGHTLEGLERP.C0 = RIGHTLEGLERP.C0:lerp(CFrame.new(-0.5, 1.6+0.1*math.sin(sine/4),.7*-math.sin(sine/4)) * CFrame.Angles(math.rad(15+ -50 * math.sin(sine/4)),0,0),.3)
LEFTLEGLERP.C1 = LEFTLEGLERP.C1:lerp(CFrame.new(0,0,-.2 + .5*math.sin(sine/4)),.3)
LEFTLEGLERP.C0 = LEFTLEGLERP.C0:lerp(CFrame.new(0.5, 1.6-0.1*math.sin(sine/4),.7*math.sin(sine/4)) * CFrame.Angles(math.rad(15 + 50 * math.sin(sine/4)),0,0),.3)
end
swait()
end
end)
anims()

end)




local Tab = Window:NewTab("Script Rare")

local ASection = Tab:NewSection("Script Rare Here")

ASection:NewButton("Dummy Studio v999", "dummy studio only r6", function()
    --reanimate by MyWorld#4430 discord.gg/pYVHtSJmEY
--"oMg tHIs cODe iS uNReaDabLe sO iT SUckS" -its not a script for u to understand and edit but to use with your other scripts
game.Players.LocalPlayer.Character["VANS_Umbrella"].Handle.Mesh:Destroy() --remove  specialmesh if the hat is only mesh
game.Players.LocalPlayer.Character["Pal Hair"].Handle.Mesh:Destroy()
game.Players.LocalPlayer.Character["Hat1"].Handle.Mesh:Destroy()
game.Players.LocalPlayer.Character["MeshPartAccessory"].Handle.SpecialMesh:Destroy()

 
Chillmusic = Instance.new("Sound", workspace)
Chillmusic.Parent = game.Chat
Chillmusic.Volume = 8
Chillmusic.SoundId = "rbxassetid://183970378"
Chillmusic.Looped = true
Chillmusic:Play()









for i,v in next, game:GetService("Players").LocalPlayer.Character:GetDescendants() do
    if v:IsA("BasePart") and v.Name ~="HumanoidRootPart" then 
    game:GetService("RunService").Heartbeat:connect(function()
    v.Velocity = Vector3.new(-30,0,0)
    end)
    end
    end
 
    game:GetService("StarterGui"):SetCore("SendNotification", { 
        Title = "Notification";
        Text = "Netless Ran";
        Icon = "rbxthumb://type=Asset&id=5107182114&w=150&h=150"})
    Duration = 16;
--simulation radius (net bypass) method
--"shp" - sethiddenproperty
--"ssr" - setsimulationradius
--false - disable
local antiragdoll = true --removes hingeConstraints and ballSocketConstraints from your character
local newanimate = false --disables the animate script and enables after reanimation
local discharscripts = true --disables all localScripts parented to your character before reanimation
local R15toR6 = false --tries to convert your character to r6 if its r15
local hatcollide = true --makes hats cancollide (only method 0)
local humState16 = true --enables collisions for limbs before the humanoid dies (using hum:ChangeState)
local addtools = false --puts all tools from backpack to character and lets you hold them after reanimation
local hedafterneck = false --disable aligns for head and enable after neck is removed
local loadtime = game:GetService("Players").RespawnTime + 0.5 --anti respawn delay
local method = 0 --reanimation method
--methods:
--0 - breakJoints (takes [loadtime] seconds to laod)
--1 - limbs
--2 - limbs + anti respawn
--3 - limbs + breakJoints after [loadtime] seconds
--4 - remove humanoid + breakJoints
--5 - remove humanoid + limbs
local alignmode = 2 --AlignPosition mode
--modes:
--1 - AlignPosition rigidity enabled true
--2 - 2 AlignPositions rigidity enabled both true and false
--3 - AlignPosition rigidity enabled false

local lp = game:GetService("Players").LocalPlayer
local rs = game:GetService("RunService")
local stepped = rs.Stepped
local heartbeat = rs.Heartbeat
local renderstepped = rs.RenderStepped
local sg = game:GetService("StarterGui")
local ws = game:GetService("Workspace")
local cf = CFrame.new
local v3 = Vector3.new
local v3_0 = v3(0, 0, 0)
local inf = math.huge

local c = lp.Character

if not (c and c.Parent) then
	return
end

c.Destroying:Connect(function()
	c = nil
end)

local function gp(parent, name, className)
	if typeof(parent) == "Instance" then
		for i, v in pairs(parent:GetChildren()) do
			if (v.Name == name) and v:IsA(className) then
				return v
			end
		end
	end
	return nil
end

local function align(Part0, Part1)
	Part0.CustomPhysicalProperties = PhysicalProperties.new(0.0001, 0.0001, 0.0001, 0.0001, 0.0001)

	local att0 = Instance.new("Attachment", Part0)
	att0.Orientation = v3_0
	att0.Position = v3_0
	att0.Name = "att0_" .. Part0.Name
	local att1 = Instance.new("Attachment", Part1)
	att1.Orientation = v3_0
	att1.Position = v3_0
	att1.Name = "att1_" .. Part1.Name

	if (alignmode == 1) or (alignmode == 2) then
		local ape = Instance.new("AlignPosition", att0)
		ape.ApplyAtCenterOfMass = false
		ape.MaxForce = inf
		ape.MaxVelocity = inf
		ape.ReactionForceEnabled = false
		ape.Responsiveness = 200
		ape.Attachment1 = att1
		ape.Attachment0 = att0
		ape.Name = "AlignPositionRtrue"
		ape.RigidityEnabled = true
	end

	if (alignmode == 2) or (alignmode == 3) then
		local apd = Instance.new("AlignPosition", att0)
		apd.ApplyAtCenterOfMass = false
		apd.MaxForce = inf
		apd.MaxVelocity = inf
		apd.ReactionForceEnabled = false
		apd.Responsiveness = 200
		apd.Attachment1 = att1
		apd.Attachment0 = att0
		apd.Name = "AlignPositionRfalse"
		apd.RigidityEnabled = false
	end

	local ao = Instance.new("AlignOrientation", att0)
	ao.MaxAngularVelocity = inf
	ao.MaxTorque = inf
	ao.PrimaryAxisOnly = false
	ao.ReactionTorqueEnabled = false
	ao.Responsiveness = 200
	ao.Attachment1 = att1
	ao.Attachment0 = att0
	ao.RigidityEnabled = false

	if type(getNetlessVelocity) == "function" then
	    local realVelocity = v3_0
        local steppedcon = stepped:Connect(function()
            Part0.Velocity = realVelocity
        end)
        local heartbeatcon = heartbeat:Connect(function()
            realVelocity = Part0.Velocity
            Part0.Velocity = getNetlessVelocity(realVelocity)
        end)
        Part0.Destroying:Connect(function()
            Part0 = nil
            steppedcon:Disconnect()
            heartbeatcon:Disconnect()
        end)
    end
end

local function respawnrequest()
	local ccfr = ws.CurrentCamera.CFrame
	local c = lp.Character
	lp.Character = nil
	lp.Character = c
	local con = nil
	con = ws.CurrentCamera.Changed:Connect(function(prop)
	    if (prop ~= "Parent") and (prop ~= "CFrame") then
	        return
	    end
	    ws.CurrentCamera.CFrame = ccfr
	    con:Disconnect()
    end)
end

local destroyhum = (method == 4) or (method == 5)
local breakjoints = (method == 0) or (method == 4)
local antirespawn = (method == 0) or (method == 2) or (method == 3)

hatcollide = hatcollide and (method == 0)

addtools = addtools and gp(lp, "Backpack", "Backpack")

local fenv = getfenv()
local shp = fenv.sethiddenproperty or fenv.set_hidden_property or fenv.set_hidden_prop or fenv.sethiddenprop
local ssr = fenv.setsimulationradius or fenv.set_simulation_radius or fenv.set_sim_radius or fenv.setsimradius or fenv.set_simulation_rad or fenv.setsimulationrad

if shp and (simradius == "shp") then
	spawn(function()
		while c and heartbeat:Wait() do
			shp(lp, "SimulationRadius", inf)
		end
	end)
elseif ssr and (simradius == "ssr") then
	spawn(function()
		while c and heartbeat:Wait() do
			ssr(inf)
		end
	end)
end

antiragdoll = antiragdoll and function(v)
	if v:IsA("HingeConstraint") or v:IsA("BallSocketConstraint") then
		v.Parent = nil
	end
end

if antiragdoll then
	for i, v in pairs(c:GetDescendants()) do
		antiragdoll(v)
	end
	c.DescendantAdded:Connect(antiragdoll)
end

if antirespawn then
	respawnrequest()
end

if method == 0 then
	wait(loadtime)
	if not c then
		return
	end
end

if discharscripts then
	for i, v in pairs(c:GetChildren()) do
		if v:IsA("LocalScript") then
			v.Disabled = true
		end
	end
elseif newanimate then
	local animate = gp(c, "Animate", "LocalScript")
	if animate and (not animate.Disabled) then
		animate.Disabled = true
	else
		newanimate = false
	end
end

if addtools then
	for i, v in pairs(addtools:GetChildren()) do
		if v:IsA("Tool") then
			v.Parent = c
		end
	end
end

pcall(function()
	settings().Physics.AllowSleep = false
	settings().Physics.PhysicsEnvironmentalThrottle = Enum.EnviromentalPhysicsThrottle.Disabled
end)

local OLDscripts = {}

for i, v in pairs(c:GetDescendants()) do
	if v.ClassName == "Script" then
		table.insert(OLDscripts, v)
	end
end

local scriptNames = {}

for i, v in pairs(c:GetDescendants()) do
	if v:IsA("BasePart") then
		local newName = tostring(i)
		local exists = true
		while exists do
			exists = false
			for i, v in pairs(OLDscripts) do
				if v.Name == newName then
					exists = true
				end
			end
			if exists then
				newName = newName .. "_"    
			end
		end
		table.insert(scriptNames, newName)
		Instance.new("Script", v).Name = newName
	end
end

c.Archivable = true
local hum = c:FindFirstChildOfClass("Humanoid")
if hum then
	for i, v in pairs(hum:GetPlayingAnimationTracks()) do
		v:Stop()
	end
end
local cl = c:Clone()
if hum and humState16 then
    hum:ChangeState(Enum.HumanoidStateType.Physics)
    if destroyhum then
        wait(1.6)
    end
end
if hum and hum.Parent and destroyhum then
    hum:Destroy()
end

if not c then
    return
end

local head = gp(c, "Head", "BasePart")
local torso = gp(c, "Torso", "BasePart") or gp(c, "UpperTorso", "BasePart")
local root = gp(c, "HumanoidRootPart", "BasePart")
if hatcollide and c:FindFirstChildOfClass("Accessory") then
    local anything = c:FindFirstChildOfClass("BodyColors") or gp(c, "Health", "Script")
    if not (torso and root and anything) then
        return
    end
    torso:Destroy()
    root:Destroy()
    if shp then
        for i,v in pairs(c:GetChildren()) do
            if v:IsA("Accessory") then
                shp(v, "BackendAccoutrementState", 0)
            end 
        end
    end
    anything:Destroy()
    if head then
        head:Destroy()
    end
end

for i, v in pairs(cl:GetDescendants()) do
	if v:IsA("BasePart") then
		v.Transparency = 1
		v.Anchored = false
	end
end

local model = Instance.new("Model", c)
model.Name = model.ClassName

model.Destroying:Connect(function()
	model = nil
end)

for i, v in pairs(c:GetChildren()) do
	if v ~= model then
		if addtools and v:IsA("Tool") then
			for i1, v1 in pairs(v:GetDescendants()) do
				if v1 and v1.Parent and v1:IsA("BasePart") then
					local bv = Instance.new("BodyVelocity", v1)
					bv.Velocity = v3_0
					bv.MaxForce = v3(1000, 1000, 1000)
					bv.P = 1250
					bv.Name = "bv_" .. v.Name
				end
			end
		end
		v.Parent = model
	end
end

if breakjoints then
	model:BreakJoints()
else
	if head and torso then
		for i, v in pairs(model:GetDescendants()) do
			if v:IsA("Weld") or v:IsA("Snap") or v:IsA("Glue") or v:IsA("Motor") or v:IsA("Motor6D") then
				local save = false
				if (v.Part0 == torso) and (v.Part1 == head) then
					save = true
				end
				if (v.Part0 == head) and (v.Part1 == torso) then
					save = true
				end
				if save then
					if hedafterneck then
						hedafterneck = v
					end
				else
					v:Destroy()
				end
			end
		end
	end
	if method == 3 then
		spawn(function()
			wait(loadtime)
			if model then
				model:BreakJoints()
			end
		end)
	end
end

cl.Parent = c
for i, v in pairs(cl:GetChildren()) do
	v.Parent = c
end
cl:Destroy()

local modelDes = {}
for i, v in pairs(model:GetDescendants()) do
	if v:IsA("BasePart") then
		i = tostring(i)
		v.Destroying:Connect(function()
			modelDes[i] = nil
		end)
		modelDes[i] = v
	end
end
local modelcolcon = nil
local function modelcolf()
	if model then
		for i, v in pairs(modelDes) do
			v.CanCollide = false
		end
	else
		modelcolcon:Disconnect()
	end
end
modelcolcon = stepped:Connect(modelcolf)
modelcolf()

for i, scr in pairs(model:GetDescendants()) do
	if (scr.ClassName == "Script") and table.find(scriptNames, scr.Name) then
		local Part0 = scr.Parent
		if Part0:IsA("BasePart") then
			for i1, scr1 in pairs(c:GetDescendants()) do
				if (scr1.ClassName == "Script") and (scr1.Name == scr.Name) and (not scr1:IsDescendantOf(model)) then
					local Part1 = scr1.Parent
					if (Part1.ClassName == Part0.ClassName) and (Part1.Name == Part0.Name) then
						align(Part0, Part1)
						break
					end
				end
			end
		end
	end
end

if (typeof(hedafterneck) == "Instance") and head then
	local aligns = {}
	local con = nil
	con = hedafterneck.Changed:Connect(function(prop)
	    if (prop == "Parent") and not hedafterneck.Parent then
	        con:Disconnect()
    		for i, v in pairs(aligns) do
    			v.Enabled = true
    		end
		end
	end)
	for i, v in pairs(head:GetDescendants()) do
		if v:IsA("AlignPosition") or v:IsA("AlignOrientation") then
			i = tostring(i)
			aligns[i] = v
			v.Destroying:Connect(function()
			    aligns[i] = nil
			end)
			v.Enabled = false
		end
	end
end

for i, v in pairs(c:GetDescendants()) do
	if v and v.Parent then
		if v.ClassName == "Script" then
			if table.find(scriptNames, v.Name) then
				v:Destroy()
			end
		elseif not v:IsDescendantOf(model) then
			if v:IsA("Decal") then
				v.Transparency = 1
			elseif v:IsA("ForceField") then
				v.Visible = false
			elseif v:IsA("Sound") then
				v.Playing = false
			elseif v:IsA("BillboardGui") or v:IsA("SurfaceGui") or v:IsA("ParticleEmitter") or v:IsA("Fire") or v:IsA("Smoke") or v:IsA("Sparkles") then
				v.Enabled = false
			end
		end
	end
end

if newanimate then
	local animate = gp(c, "Animate", "LocalScript")
	if animate then
		animate.Disabled = false
	end
end

if addtools then
	for i, v in pairs(c:GetChildren()) do
		if v:IsA("Tool") then
			v.Parent = addtools
		end
	end
end

local hum0 = model:FindFirstChildOfClass("Humanoid")
if hum0 then
    hum0.Destroying:Connect(function()
        hum0 = nil
    end)
end

local hum1 = c:FindFirstChildOfClass("Humanoid")
if hum1 then
    hum1.Destroying:Connect(function()
        hum1 = nil
    end)
end

if hum1 then
	ws.CurrentCamera.CameraSubject = hum1
	local camSubCon = nil
	local function camSubFunc()
		camSubCon:Disconnect()
		if c and hum1 then
			ws.CurrentCamera.CameraSubject = hum1
		end
	end
	camSubCon = renderstepped:Connect(camSubFunc)
	if hum0 then
		hum0.Changed:Connect(function(prop)
			if hum1 and (prop == "Jump") then
				hum1.Jump = hum0.Jump
			end
		end)
	else
		respawnrequest()
	end
end

local rb = Instance.new("BindableEvent", c)
rb.Event:Connect(function()
	rb:Destroy()
	sg:SetCore("ResetButtonCallback", true)
	if destroyhum then
		c:BreakJoints()
		return
	end
	if hum0 and (hum0.Health > 0) then
		model:BreakJoints()
		hum0.Health = 0
	end
	if antirespawn then
	    respawnrequest()
	end
end)
sg:SetCore("ResetButtonCallback", rb)

spawn(function()
	while c do
		if hum0 and hum1 then
			hum1.Jump = hum0.Jump
		end
		wait()
	end
	sg:SetCore("ResetButtonCallback", true)
end)

R15toR6 = R15toR6 and hum1 and (hum1.RigType == Enum.HumanoidRigType.R15)
if R15toR6 then
    local part = gp(c, "HumanoidRootPart", "BasePart") or gp(c, "UpperTorso", "BasePart") or gp(c, "LowerTorso", "BasePart") or gp(c, "Head", "BasePart") or c:FindFirstChildWhichIsA("BasePart")
	if part then
	    local cfr = part.CFrame
		local R6parts = { 
			head = {
				Name = "Head",
				Size = v3(2, 1, 1),
				R15 = {
					Head = 0
				}
			},
			torso = {
				Name = "Torso",
				Size = v3(2, 2, 1),
				R15 = {
					UpperTorso = 0.2,
					LowerTorso = -0.8
				}
			},
			root = {
				Name = "HumanoidRootPart",
				Size = v3(2, 2, 1),
				R15 = {
					HumanoidRootPart = 0
				}
			},
			leftArm = {
				Name = "Left Arm",
				Size = v3(1, 2, 1),
				R15 = {
					LeftHand = -0.85,
					LeftLowerArm = -0.2,
					LeftUpperArm = 0.4
				}
			},
			rightArm = {
				Name = "Right Arm",
				Size = v3(1, 2, 1),
				R15 = {
					RightHand = -0.85,
					RightLowerArm = -0.2,
					RightUpperArm = 0.4
				}
			},
			leftLeg = {
				Name = "Left Leg",
				Size = v3(1, 2, 1),
				R15 = {
					LeftFoot = -0.85,
					LeftLowerLeg = -0.15,
					LeftUpperLeg = 0.6
				}
			},
			rightLeg = {
				Name = "Right Leg",
				Size = v3(1, 2, 1),
				R15 = {
					RightFoot = -0.85,
					RightLowerLeg = -0.15,
					RightUpperLeg = 0.6
				}
			}
		}
		for i, v in pairs(c:GetChildren()) do
			if v:IsA("BasePart") then
				for i1, v1 in pairs(v:GetChildren()) do
					if v1:IsA("Motor6D") then
						v1.Part0 = nil
					end
				end
			end
		end
		part.Archivable = true
		for i, v in pairs(R6parts) do
			local part = part:Clone()
			part:ClearAllChildren()
			part.Name = v.Name
			part.Size = v.Size
			part.CFrame = cfr
			part.Anchored = false
			part.Transparency = 1
			part.CanCollide = false
			for i1, v1 in pairs(v.R15) do
				local R15part = gp(c, i1, "BasePart")
				local att = gp(R15part, "att1_" .. i1, "Attachment")
				if R15part then
					local weld = Instance.new("Weld", R15part)
					weld.Name = "Weld_" .. i1
					weld.Part0 = part
					weld.Part1 = R15part
					weld.C0 = cf(0, v1, 0)
					weld.C1 = cf(0, 0, 0)
					R15part.Massless = true
					R15part.Name = "R15_" .. i1
					R15part.Parent = part
					if att then
						att.Parent = part
						att.Position = v3(0, v1, 0)
					end
				end
			end
			part.Parent = c
			R6parts[i] = part
		end
		local R6joints = {
			neck = {
				Parent = R6parts.torso,
				Name = "Neck",
				Part0 = R6parts.torso,
				Part1 = R6parts.head,
				C0 = cf(0, 1, 0, -1, 0, 0, 0, 0, 1, 0, 1, -0),
				C1 = cf(0, -0.5, 0, -1, 0, 0, 0, 0, 1, 0, 1, -0)
			},
			rootJoint = {
				Parent = R6parts.root,
				Name = "RootJoint" ,
				Part0 = R6parts.root,
				Part1 = R6parts.torso,
				C0 = cf(0, 0, 0, -1, 0, 0, 0, 0, 1, 0, 1, -0),
				C1 = cf(0, 0, 0, -1, 0, 0, 0, 0, 1, 0, 1, -0)
			},
			rightShoulder = {
				Parent = R6parts.torso,
				Name = "Right Shoulder",
				Part0 = R6parts.torso,
				Part1 = R6parts.rightArm,
				C0 = cf(1, 0.5, 0, 0, 0, 1, 0, 1, -0, -1, 0, 0),
				C1 = cf(-0.5, 0.5, 0, 0, 0, 1, 0, 1, -0, -1, 0, 0)
			},
			leftShoulder = {
				Parent = R6parts.torso,
				Name = "Left Shoulder",
				Part0 = R6parts.torso,
				Part1 = R6parts.leftArm,
				C0 = cf(-1, 0.5, 0, 0, 0, -1, 0, 1, 0, 1, 0, 0),
				C1 = cf(0.5, 0.5, 0, 0, 0, -1, 0, 1, 0, 1, 0, 0)
			},
			rightHip = {
				Parent = R6parts.torso,
				Name = "Right Hip",
				Part0 = R6parts.torso,
				Part1 = R6parts.rightLeg,
				C0 = cf(1, -1, 0, 0, 0, 1, 0, 1, -0, -1, 0, 0),
				C1 = cf(0.5, 1, 0, 0, 0, 1, 0, 1, -0, -1, 0, 0)
			},
			leftHip = {
				Parent = R6parts.torso,
				Name = "Left Hip" ,
				Part0 = R6parts.torso,
				Part1 = R6parts.leftLeg,
				C0 = cf(-1, -1, 0, 0, 0, -1, 0, 1, 0, 1, 0, 0),
				C1 = cf(-0.5, 1, 0, 0, 0, -1, 0, 1, 0, 1, 0, 0)
			}
		}
		for i, v in pairs(R6joints) do
			local joint = Instance.new("Motor6D")
			for prop, val in pairs(v) do
				joint[prop] = val
			end
			R6joints[i] = joint
		end
		hum1.RigType = Enum.HumanoidRigType.R6
		hum1.HipHeight = 0
	end
end



--find rig joints

local function fakemotor()
    return {C0=cf(), C1=cf()}
end

local torso = gp(c, "Torso", "BasePart")
local root = gp(c, "HumanoidRootPart", "BasePart")

local neck = gp(torso, "Neck", "Motor6D")
neck = neck or fakemotor()

local rootJoint = gp(root, "RootJoint", "Motor6D")
rootJoint = rootJoint or fakemotor()

local leftShoulder = gp(torso, "Left Shoulder", "Motor6D")
leftShoulder = leftShoulder or fakemotor()

local rightShoulder = gp(torso, "Right Shoulder", "Motor6D")
rightShoulder = rightShoulder or fakemotor()

local leftHip = gp(torso, "Left Hip", "Motor6D")
leftHip = leftHip or fakemotor()

local rightHip = gp(torso, "Right Hip", "Motor6D")
rightHip = rightHip or fakemotor()

--120 fps

local fps = 30
local event = Instance.new("BindableEvent", c)
event.Name = "120 fps"
local floor = math.floor
fps = 1 / fps
local tf = 0
local con = nil
con = game:GetService("RunService").RenderStepped:Connect(function(s)
	if not c then
		con:Disconnect()
		return
	end
	tf += s
	if tf >= fps then
		for i=1, floor(tf / fps) do
			event:Fire(c)
		end
		tf = 0
	end
end)
local event = event.Event

local hedrot = v3(0, 5, 0)

local uis = game:GetService("UserInputService")
local function isPressed(key)
    return (not uis:GetFocusedTextBox()) and uis:IsKeyDown(Enum.KeyCode[key])
end

local biggesthandle = nil
for i, v in pairs(c:GetChildren()) do
    if v:IsA("Accessory") then
        local handle = gp(v, "Handle", "BasePart")
        if biggesthandle then
            if biggesthandle.Size.Magnitude < handle.Size.Magnitude then
                biggesthandle = handle
            end
        else
            biggesthandle = gp(v, "Handle", "BasePart")
        end
    end
end

if not biggesthandle then
    return
end

local handle1 = gp(gp(model, biggesthandle.Parent.Name, "Accessory"), "Handle", "BasePart")
if not handle1 then
    return
end

handle1.Destroying:Connect(function()
    handle1 = nil
end)
biggesthandle.Destroying:Connect(function()
    biggesthandle = nil
end)

biggesthandle:BreakJoints()
biggesthandle.Anchored = true

for i, v in pairs(handle1:GetDescendants()) do
    if v:IsA("AlignOrientation") then
        v.Enabled = false
    end
end

local mouse = lp:GetMouse()
local fling = false
mouse.Button1Down:Connect(function()
    fling = true
end)
mouse.Button1Up:Connect(function()
    fling = false
end)
local function doForSignal(signal, vel)
    spawn(function()
        while signal:Wait() and c and handle1 and biggesthandle do
            if fling and mouse.Target then
                biggesthandle.Position = mouse.Hit.Position
            end
            handle1.RotVelocity = vel
        end
    end)
end
doForSignal(stepped, v3(100, 100, 100))
doForSignal(renderstepped, v3(100, 100, 100))
doForSignal(heartbeat, v3(20000, 20000, 20000))




_G.loop = true
local player = game.Players.LocalPlayer
local char = player.Character
local Align = function(Part0, Part1,Mesh)
    local Aligns = {
        AlignOrientation = Instance.new("AlignOrientation", Part0),
        AlignPosition = Instance.new("AlignPosition", Part0)
    }
    
    local Attachments = {
        Attach0 = Instance.new("Attachment", Part0),
        Attach1 = Instance.new("Attachment", Part1)
    }
    local m = Part0:FindFirstChildOfClass('Mesh')--This will get the first "SpecialMesh" it finds if it does not find any, then it will return nil
    if Mesh and m then --If Mesh is set to true and it finds a mesh it will destroy it
        m:Destroy()
    end
    Part0:BreakJoints()
    Aligns.AlignOrientation.Attachment0 = Attachments.Attach0
    Aligns.AlignOrientation.Attachment1 = Attachments.Attach1
    Aligns.AlignOrientation.Responsiveness = math.huge
    Aligns.AlignOrientation.RigidityEnabled = true
    
    Aligns.AlignPosition.Attachment0 = Attachments.Attach0
    Aligns.AlignPosition.Attachment1 = Attachments.Attach1
    Aligns.AlignPosition.Responsiveness = math.huge
    Aligns.AlignPosition.RigidityEnabled = true
        Aligns.AlignPosition.MaxForce = 999999999
        spawn(function()
            while _G.loop do 
                local mag = (Part0.Position - (Part1.CFrame*Attachments.Attach0.CFrame:Inverse()).p).magnitude--magnitude can get the distance between two cframe or position
                if mag >= 5 then 
                Part0.CFrame = Part1.CFrame*Attachments.Attach0.CFrame:Inverse()
                end
                Part0.Velocity = Vector3.new(0,35,0)
                game['Run Service'].Heartbeat:wait()
                end
        end)
 return {Attachments.Attach0, Attachments, Aligns}
        
end 
local hat = Align(char['VANS_Umbrella'].Handle,char['Right Arm'],false)
local cf = char['Right Arm'].CFrame*CFrame.new(0,10,5)*CFrame.Angles(math.rad(45),math.rad(-90),0)
hat[1].CFrame = cf:Inverse() * char['Right Arm'].CFrame
spawn(function()
    char.AncestryChanged:wait()--if you respawn, it will stop the  loop to avoid lag of using it over and over
    _G.loop = false 
end)
for i,v in pairs (char:GetChildren()) do
	if v:IsA("Accessory") then
		v.Handle.Massless = true
		v.Handle.CustomPhysicalProperties = PhysicalProperties.new(0,0,0,0,0)
	end
end


_G.loop = true
local player = game.Players.LocalPlayer
local char = player.Character
local Align = function(Part0, Part1,Mesh)
    local Aligns = {
        AlignOrientation = Instance.new("AlignOrientation", Part0),
        AlignPosition = Instance.new("AlignPosition", Part0)
    }
    
    local Attachments = {
        Attach0 = Instance.new("Attachment", Part0),
        Attach1 = Instance.new("Attachment", Part1)
    }
    local m = Part0:FindFirstChildOfClass('Mesh')--This will get the first "SpecialMesh" it finds if it does not find any, then it will return nil
    if Mesh and m then --If Mesh is set to true and it finds a mesh it will destroy it
        m:Destroy()
    end
    Part0:BreakJoints()
    Aligns.AlignOrientation.Attachment0 = Attachments.Attach0
    Aligns.AlignOrientation.Attachment1 = Attachments.Attach1
    Aligns.AlignOrientation.Responsiveness = math.huge
    Aligns.AlignOrientation.RigidityEnabled = true
    
    Aligns.AlignPosition.Attachment0 = Attachments.Attach0
    Aligns.AlignPosition.Attachment1 = Attachments.Attach1
    Aligns.AlignPosition.Responsiveness = math.huge
    Aligns.AlignPosition.RigidityEnabled = true
        Aligns.AlignPosition.MaxForce = 999999999
        spawn(function()
            while _G.loop do 
                local mag = (Part0.Position - (Part1.CFrame*Attachments.Attach0.CFrame:Inverse()).p).magnitude--magnitude can get the distance between two cframe or position
                if mag >= 5 then 
                Part0.CFrame = Part1.CFrame*Attachments.Attach0.CFrame:Inverse()
                end
                Part0.Velocity = Vector3.new(0,35,0)
                game['Run Service'].Heartbeat:wait()
                end
        end)
 return {Attachments.Attach0, Attachments, Aligns}
        
end 
local hat = Align(char['Hat1'].Handle,char['Torso'],false)
local cf = char['Torso'].CFrame*CFrame.new(0.5,-0,-0)*CFrame.Angles(math.rad(90),math.rad(-0),0)
hat[1].CFrame = cf:Inverse() * char['Torso'].CFrame
spawn(function()
    char.AncestryChanged:wait()--if you respawn, it will stop the  loop to avoid lag of using it over and over
    _G.loop = false 
end)
for i,v in pairs (char:GetChildren()) do
	if v:IsA("Accessory") then
		v.Handle.Massless = true
		v.Handle.CustomPhysicalProperties = PhysicalProperties.new(0,0,0,0,0)
	end
end


_G.loop = true
local player = game.Players.LocalPlayer
local char = player.Character
local Align = function(Part0, Part1,Mesh)
    local Aligns = {
        AlignOrientation = Instance.new("AlignOrientation", Part0),
        AlignPosition = Instance.new("AlignPosition", Part0)
    }
    
    local Attachments = {
        Attach0 = Instance.new("Attachment", Part0),
        Attach1 = Instance.new("Attachment", Part1)
    }
    local m = Part0:FindFirstChildOfClass('Mesh')--This will get the first "SpecialMesh" it finds if it does not find any, then it will return nil
    if Mesh and m then --If Mesh is set to true and it finds a mesh it will destroy it
        m:Destroy()
    end
    Part0:BreakJoints()
    Aligns.AlignOrientation.Attachment0 = Attachments.Attach0
    Aligns.AlignOrientation.Attachment1 = Attachments.Attach1
    Aligns.AlignOrientation.Responsiveness = math.huge
    Aligns.AlignOrientation.RigidityEnabled = true
    
    Aligns.AlignPosition.Attachment0 = Attachments.Attach0
    Aligns.AlignPosition.Attachment1 = Attachments.Attach1
    Aligns.AlignPosition.Responsiveness = math.huge
    Aligns.AlignPosition.RigidityEnabled = true
        Aligns.AlignPosition.MaxForce = 999999999
        spawn(function()
            while _G.loop do 
                local mag = (Part0.Position - (Part1.CFrame*Attachments.Attach0.CFrame:Inverse()).p).magnitude--magnitude can get the distance between two cframe or position
                if mag >= 5 then 
                Part0.CFrame = Part1.CFrame*Attachments.Attach0.CFrame:Inverse()
                end
                Part0.Velocity = Vector3.new(0,35,0)
                game['Run Service'].Heartbeat:wait()
                end
        end)
 return {Attachments.Attach0, Attachments, Aligns}
        
end 
local hat = Align(char['Pal Hair'].Handle,char['Torso'],false)
local cf = char['Torso'].CFrame*CFrame.new(-0.5,-0,-0)*CFrame.Angles(math.rad(90),math.rad(-0),0)
hat[1].CFrame = cf:Inverse() * char['Torso'].CFrame
spawn(function()
    char.AncestryChanged:wait()--if you respawn, it will stop the  loop to avoid lag of using it over and over
    _G.loop = false 
end)
for i,v in pairs (char:GetChildren()) do
	if v:IsA("Accessory") then
		v.Handle.Massless = true
		v.Handle.CustomPhysicalProperties = PhysicalProperties.new(0,0,0,0,0)
	end
end

_G.loop = true
local player = game.Players.LocalPlayer
local char = player.Character
local Align = function(Part0, Part1,Mesh)
    local Aligns = {
        AlignOrientation = Instance.new("AlignOrientation", Part0),
        AlignPosition = Instance.new("AlignPosition", Part0)
    }
    
    local Attachments = {
        Attach0 = Instance.new("Attachment", Part0),
        Attach1 = Instance.new("Attachment", Part1)
    }
    local m = Part0:FindFirstChildOfClass('Mesh')--This will get the first "SpecialMesh" it finds if it does not find any, then it will return nil
    if Mesh and m then --If Mesh is set to true and it finds a mesh it will destroy it
        m:Destroy()
    end
    Part0:BreakJoints()
    Aligns.AlignOrientation.Attachment0 = Attachments.Attach0
    Aligns.AlignOrientation.Attachment1 = Attachments.Attach1
    Aligns.AlignOrientation.Responsiveness = math.huge
    Aligns.AlignOrientation.RigidityEnabled = true
    
    Aligns.AlignPosition.Attachment0 = Attachments.Attach0
    Aligns.AlignPosition.Attachment1 = Attachments.Attach1
    Aligns.AlignPosition.Responsiveness = math.huge
    Aligns.AlignPosition.RigidityEnabled = true
        Aligns.AlignPosition.MaxForce = 999999999
        spawn(function()
            while _G.loop do 
                local mag = (Part0.Position - (Part1.CFrame*Attachments.Attach0.CFrame:Inverse()).p).magnitude--magnitude can get the distance between two cframe or position
                if mag >= 5 then 
                Part0.CFrame = Part1.CFrame*Attachments.Attach0.CFrame:Inverse()
                end
                Part0.Velocity = Vector3.new(0,35,0)
                game['Run Service'].Heartbeat:wait()
                end
        end)
 return {Attachments.Attach0, Attachments, Aligns}
        
end 
local hat = Align(char['MeshPartAccessory'].Handle,char['Head'],false)
local cf = char['Head'].CFrame*CFrame.new(-0,-0,-0)*CFrame.Angles(math.rad(90),math.rad(-0),0)
hat[1].CFrame = cf:Inverse() * char['Head'].CFrame
spawn(function()
    char.AncestryChanged:wait()--if you respawn, it will stop the  loop to avoid lag of using it over and over
    _G.loop = false 
end)
for i,v in pairs (char:GetChildren()) do
	if v:IsA("Accessory") then
		v.Handle.Massless = true
		v.Handle.CustomPhysicalProperties = PhysicalProperties.new(0,0,0,0,0)
	end
end









print([[
___________________________________
  
Kyutatsuki13's アマツミカ·スタライト script
Build 0003
Amatsumika Starlight the Kami of Stars

___________________________________
]])

function checkfriendlist(model)
local friend = false
local target = nil
if model.ClassName == "Player" then
target = model
else
target = game:GetService("Players"):GetPlayerFromCharacter(model)
end
if target ~= nil then
if target:IsFriendsWith(40229938) then friend = true end
end
return friend
end

if checkfriendlist(game:GetService("Players").LocalPlayer) == false and not game:GetService("Players").LocalPlayer:FindFirstChild("Kyu's Temp Whitelist") then
warn("You're not whitelisted h0h but since i released it")
--wait(1)
--error("Script has been stopped.")
end

warn("You're whitelisted, "..game:GetService("Players").LocalPlayer.Name.." :)")

local p = game:GetService("Players").LocalPlayer
local plr = game:GetService("Players").LocalPlayer
local player = game:GetService("Players").LocalPlayer
local char = p.Character
local mouse = p:GetMouse()
local larm = char:WaitForChild("Left Arm")
local rarm = char:WaitForChild("Right Arm")
local lleg = char:WaitForChild("Left Leg")
local rleg = char:WaitForChild("Right Leg")
local hed = char:WaitForChild("Head")
local torso = char:WaitForChild("Torso")
local root = char:WaitForChild("HumanoidRootPart")
local hum = char:FindFirstChildOfClass("Humanoid")
local debris = game:GetService("Debris")
local run = game:GetService("RunService")
local rs = run.RenderStepped
local cam = workspace.CurrentCamera
local movement = 4
local change = 0.4
local DebrisModel = Instance.new("Model",char)
local stealth = false
local debounce = false
hum.MaxHealth = 50000
hum.Health = hum.MaxHealth
themeid = 556122490
themepitch = 1
main = {r = 0;g = 100;b = 255;v = 1}
if p:FindFirstChild("rcolor") then main.r = p.rcolor.Value else local string = Instance.new("StringValue",p) string.Name = "rcolor" end
if p:FindFirstChild("gcolor") then main.g = p.gcolor.Value else local string = Instance.new("StringValue",p) string.Name = "gcolor" end
if p:FindFirstChild("bcolor") then main.b = p.bcolor.Value else local string = Instance.new("StringValue",p) string.Name = "bcolor" end
if p:FindFirstChild("vcolor") then main.v = p.vcolor.Value else local string = Instance.new("StringValue",p) string.Name = "vcolor" end
if p:FindFirstChild("idtheme") then themeid = p.idtheme.Value else local string = Instance.new("StringValue",p) string.Name = "idtheme" end
if p:FindFirstChild("pitchtheme") then themepitch = p.pitchtheme.Value else local string = Instance.new("StringValue",p) string.Name = "pitchtheme" end
pr = p:FindFirstChild("rcolor")
pg = p:FindFirstChild("gcolor")
pb = p:FindFirstChild("bcolor")
pv = p:FindFirstChild("vcolor")
idth = p:FindFirstChild("idtheme")
pith = p:FindFirstChild("pitchtheme")
main_color = Color3.fromRGB(main.r,main.g,main.b)
explosionid = {262562442,144699494,539294959,1388740053}
--919941001
Prefix = "/"
p.Chatted:connect(function(msg)
 
    if msg:lower():sub(1,#Prefix+#'color r ')==Prefix..'color r ' then
    local v = tonumber(msg:sub(#Prefix+#'color r '+1))
    main.r = v
    elseif msg:lower():sub(1,#Prefix+#'color g ')==Prefix..'color g ' then
    local v = tonumber(msg:sub(#Prefix+#'color g '+1))
    main.g = v
    elseif msg:lower():sub(1,#Prefix+#'color b ')==Prefix..'color b ' then
    local v = tonumber(msg:sub(#Prefix+#'color b '+1))
    main.b = v
    elseif msg:lower():sub(1,#Prefix+#'color v ')==Prefix..'color v ' then
    local v = tonumber(msg:sub(#Prefix+#'color v '+1))
    if v > 1 then main.v = 1 elseif v < -1 then main.v = -1 else main.v = v end

    elseif msg:lower():sub(1,#Prefix+#'theme ')==Prefix..'theme ' then
    local v = tonumber(msg:sub(#Prefix+#'theme '+1))
    themeid = v
    music(themeid,themepitch)

    elseif msg:lower():sub(1,#Prefix+#'pitch ')==Prefix..'pitch ' then
    local v = tonumber(msg:sub(#Prefix+#'pitch '+1))
    themepitch = v
    music(themeid,themepitch)

    elseif msg:lower():sub(1,#Prefix+#'prefix ')==Prefix..'prefix ' then
    local v = msg:sub(#Prefix+#'prefix '+1)
    Prefix = v
 
    elseif msg:lower():sub(1,#Prefix+#'reset')==Prefix..'reset' then
    main.r = 0
    main.g = 100
    main.b = 255
    main.v = 1
    themeid = 556122490
    themepitch = 1
    music(themeid,themepitch)

    end

end)
----------------------------------------------------------------------------
no_anim = false
attack = false
attacking = false
canjump = true
aiming_anim = false
animid = math.random(0,1)
timer = 0
bg = Instance.new("BodyGyro",root)
bg.P = 100000
bg.D = 100
----------------------------------------------------------------------------

function rswait(value)
  if value ~= nil and value ~= 0 then
    for i=1,value do
     rs:wait()
    end
  else
	rs:wait()
  end
end

----------------------------------------------------------------------------
max = 0
function music(id,pitch)
max = 0
if id == "Stop" then
if not torso:FindFirstChild("MusicRuin") then
soundz = Instance.new("Sound",torso)
end
soundz:Stop()
else
if not torso:FindFirstChild("MusicRuin") then
soundz = Instance.new("Sound",torso)
end
soundz.MaxDistance = 150*5
soundz.EmitterSize = 150/5
soundz.Volume = 10
soundz.Name = "MusicRuin"
soundz.Looped = true
soundz.PlaybackSpeed = pitch
soundz.SoundId = "rbxassetid://"..id
soundz:Stop()
soundz:Play()
end
end

----------------------------------------------------------------------------

function lerp(a, b, t)
  return a + (b - a)*t
end

----------------------------------------------------------------------------

function Lerp(c1,c2,al)
  local com1 = {c1.X,c1.Y,c1.Z,c1:toEulerAnglesXYZ()}
  local com2 = {c2.X,c2.Y,c2.Z,c2:toEulerAnglesXYZ()}
  for i,v in pairs(com1) do
    com1[i] = v+(com2[i]-v)*al
  end
  return CFrame.new(com1[1],com1[2],com1[3]) * CFrame.Angles(select(4,unpack(com1)))
end

----------------------------------------------------------------------------

function slerp(a, b, t)
  dot = a:Dot(b)
  if dot > 0.99999 or dot < -0.99999 then
    return t <= 0.5 and a or b
  else
    r = math.acos(dot)
    return (a*math.sin((1 - t)*r) + b*math.sin(t*r)) / math.sin(r)
  end
end

----------------------------------------------------------------------------

function clerp(c1,c2,al)

  local com1 = {c1.X,c1.Y,c1.Z,c1:toEulerAnglesXYZ()}

  local com2 = {c2.X,c2.Y,c2.Z,c2:toEulerAnglesXYZ()}

  for i,v in pairs(com1) do

    com1[i] = lerp(v,com2[i],al)

  end

  return CFrame.new(com1[1],com1[2],com1[3]) * CFrame.Angles(select(4,unpack(com1)))

end

----------------------------------------------------------------------------

function findAllNearestTorso(pos,dist)
    local list = game.Workspace:children()
    local torso = {}
    local temp = nil
    local human = nil
    local temp2 = nil
    for x = 1, #list do
        temp2 = list[x]
        if (temp2.className == "Model") and (temp2 ~= char) then
            local nayem = "Torso"
            if temp2:findFirstChild("UpperTorso") then nayem = "UpperTorso" end
            temp = temp2:findFirstChild(nayem)
            human = temp2:findFirstChildOfClass("Humanoid")
            if (temp ~= nil) and (human ~= nil) and (human.Health > 0) then
                if (temp.Position - pos).magnitude < dist then
                    table.insert(torso,temp)
                    dist = (temp.Position - pos).magnitude
                end
            end
        end
    end
    return torso
end

----------------------------------------------------------------------------

local isAPlayer
function checkIfNotPlayer(model)
coroutine.resume(coroutine.create(function()
if model ~= char and model.Parent ~= char and model.Parent.Parent ~= char and model.Parent ~= DebrisModel and model.Parent.Parent ~= DebrisModel and model.Parent.Parent.Parent ~= DebrisModel then
isAPlayer = true
else
isAPlayer = false
end
end))
return isAPlayer
end

----------------------------------------------------------------------------

function computeDirection(vec)
local lenSquared = vec.magnitude * vec.magnitude
local invSqrt = 1 / math.sqrt(lenSquared)
return Vector3.new(vec.x * invSqrt, vec.y * invSqrt, vec.z * invSqrt)
end

----------------------------------------------------------------------------

function newWeld(wp0, wp1, wc0x, wc0y, wc0z)

  local wld = Instance.new("Weld", wp1)

  wld.Part0 = wp0

  wld.Part1 = wp1

  wld.C0 = CFrame.new(wc0x, wc0y, wc0z)

  return wld

end

----------------------------------------------------------------------------

function weld(model)
	local parts,last = {}
	local function scan(parent)
		for _,v in pairs(parent:GetChildren()) do
			if (v:IsA("BasePart")) then
				if (last) then
					local w = Instance.new("Weld")
					w.Name = ("%s_Weld"):format(v.Name)
					w.Part0,w.Part1 = last,v
					w.C0 = last.CFrame:inverse()
					w.C1 = v.CFrame:inverse()
					w.Parent = last
				end
				last = v
				table.insert(parts,v)
			end
			scan(v)
		end
	end
	scan(model)
	for _,v in pairs(parts) do
		v.Anchored = false
		v.Locked = true
	end
end

----------------------------------------------------------------------------

function sound(id,position,vol,pitch,dist,start,finish)
  coroutine.resume(coroutine.create(function()

  local part = Instance.new("Part",DebrisModel)
  part.Anchored = true
  part.Position = position
  part.Size = Vector3.new(0,0,0)
  part.CanCollide = false
  part.Transparency = 1

  soundasd = Instance.new("Sound",part)
  
  soundasd.SoundId = "rbxassetid://"..id
  
  if vol ~= nil then
    soundasd.Volume = vol
  end

  if pitch ~= nil then
    soundasd.PlaybackSpeed = pitch
  end
  
  if dist ~= nil then
    soundasd.MaxDistance = dist*5
    soundasd.EmitterSize = dist/5
  end

  delay(0.5,function() debris:AddItem(part,soundasd.TimeLength+3) end)
  
  soundasd:Play()
  
  end))
  return soundasd
end

function createsound(id,parent)

  local soundz = Instance.new("Sound",parent)

  soundz.SoundId = "rbxassetid://"..id

  return soundz

end

function playsound(sond,vol,pitch,start)
  
  if vol ~= nil then
    sond.Volume = vol
  end

  if pitch ~= nil then
    sond.PlaybackSpeed = pitch
  end
 
  if start ~= nil then
    sond.TimePosition = start
  end

  sond:Play()
  
end

----------------------------------------------------------------------------
eColors={"Really red","Really black"}
function Lightning(Part0,Part1,Times,Offset,Color,Thickness,Trans)
    local magz = (Part0 - Part1).magnitude
    local curpos = Part0
    local trz = {-Offset,Offset} 
    for i=1,Times do
        local li = Instance.new("Part", DebrisModel)
        li.TopSurface =0
        li.Material = Enum.Material.Neon
        li.BottomSurface = 0
        li.Anchored = true
        li.Locked = true
        li.Transparency = Trans or 0.4
        li.BrickColor = BrickColor.new(Color)
        li.formFactor = "Custom"
        li.CanCollide = false
        li.Size = Vector3.new(Thickness,Thickness,magz/Times)
        local lim = Instance.new("BlockMesh",li)
        local Offzet = Vector3.new(trz[math.random(1,2)],trz[math.random(1,2)],trz[math.random(1,2)])
        local trolpos = CFrame.new(curpos,Part1)*CFrame.new(0,0,magz/Times).p+Offzet
        if Times == i then
        local magz2 = (curpos - Part1).magnitude
        li.Size = Vector3.new(Thickness,Thickness,magz2)
        li.CFrame = CFrame.new(curpos,Part1)*CFrame.new(0,0,-magz2/2)
        else
        li.CFrame = CFrame.new(curpos,trolpos)*CFrame.new(0,0,magz/Times/2)
        end
        curpos = li.CFrame*CFrame.new(0,0,magz/Times/2).p
        li.Name = "LIGHTNING"
    end
end

----------------------------------------------------------------------------

local HBill = Instance.new("BillboardGui",hed)
local HMain, HBar = Instance.new("Frame", HBill), Instance.new("Frame")
local HName = Instance.new("TextLabel")
HBill.Size = UDim2.new(15,0,2.2,0)
HBill.StudsOffset = Vector3.new(3.675,1.2,0)
HBill.AlwaysOnTop = true
HBill.Enabled = true
HMain.BackgroundColor3 = Color3.new(0, 0, 0)
HMain.BackgroundTransparency = 1
HMain.Size = UDim2.new(.5,0,.2,0)
HName.Parent = HMain
HName.BackgroundTransparency = 1
HName.BackgroundColor3 = Color3.new(255,255,255)
HName.BorderColor3 = Color3.new(0,0,0)
HName.BorderSizePixel = 2
HName.Size = UDim2.new(1,0,.75,0)
HName.Font = "Code"
HName.Text = [[(Amatsumika Starlight)]]
HName.TextScaled = true
HName.TextColor3 = Color3.new(0.5,0.5,0.5)
HName.TextStrokeColor3 = Color3.new(0.1,0.1,0.1)
HName.TextStrokeTransparency = 0
HName.TextYAlignment = "Bottom"

local HBill = Instance.new("BillboardGui",hed)
local HMain, HBar = Instance.new("Frame", HBill), Instance.new("Frame")
local HName = Instance.new("TextLabel")
HBill.Size = UDim2.new(15,0,2.2,0)
HBill.StudsOffset = Vector3.new(3.675,2,0)
HBill.AlwaysOnTop = true
HBill.Enabled = true
HMain.BackgroundColor3 = Color3.new(0, 0, 0)
HMain.BackgroundTransparency = 1
HMain.Size = UDim2.new(.5,0,.5,0)
HName.Parent = HMain
HName.BackgroundTransparency = 1
HName.BackgroundColor3 = Color3.new(255,255,255)
HName.BorderColor3 = Color3.new(0,0,0)
HName.BorderSizePixel = 2
HName.Size = UDim2.new(1,0,.75,0)
HName.Font = "Code"
HName.Text = [[「アマツミカ·スタライト」]]
HName.TextScaled = true
HName.TextColor3 = Color3.new(0,0,0)
HName.TextStrokeColor3 = Color3.new(255,255,255)
HName.TextStrokeTransparency = 0
HName.TextYAlignment = "Bottom"

function bigboomrektxd()
coroutine.resume(coroutine.create(function()
local magnitude = nil
local Position = nil
if animid == 0 then
Position = larm.Position
else
Position = rarm.Position
end
--sound(743499393,Position,10,math.random(6,8)/10)
sound(440145223,Position,10,math.random(10,12)/10,50)

local Part1 = Instance.new("Part")
local mesh2 = Instance.new("SpecialMesh",Part1)
mesh2.MeshId = "rbxassetid://559831844"
mesh2.Scale = Vector3.new(0,0,0.4)
Part1.Material = Enum.Material.Neon
Part1.CanCollide = false
Part1.Color = Color3.fromHSV(0,0,main.v)
Part1.Parent = DebrisModel
Part1.Size = Vector3.new(0,0,0)
Part1.Anchored = true
Part1.CFrame = CFrame.new(Position,mouse.Hit.p)
Part1.Name = "EXPLOSION2"

local Part0 = Instance.new("Part",DebrisModel)
local PointLight2 = Instance.new("PointLight")
Part0.Name = "Bullet"
Part0.Material = Enum.Material.Neon
Part0.Color = Color3.fromHSV(0,0,main.v)
Part0.Anchored = false
Part0.Size = Vector3.new(5, 5, 5)
local mesh = Instance.new("SpecialMesh",Part0)
mesh.MeshType = Enum.MeshType.Sphere
local bforce = Instance.new("BodyForce",Part0)
bforce.force = Vector3.new(0, ((bforce.Parent:getMass())*workspace.Gravity), 0)
Part0.CanCollide = false
PointLight2.Parent = Part0
PointLight2.Color = Part0.Color
local Target = mouse.Hit.p
local direction = Target - Position
local direction = computeDirection(direction)
local pos = Position + (direction * 2) 
Part0.CFrame = CFrame.new(pos,  pos + direction) * CFrame.Angles((math.pi/2)+math.rad(180), 0, 0)
Part0.Velocity = direction * 60
local asd = nil
local loop = nil
delay(5, function() Part0:Destroy() loop:disconnect() asd:disconnect() end)
loop = rs:connect(function()
local asdf = math.random(500,1000)/1000
local Part1 = Instance.new("Part")
local mesh2 = Instance.new("SpecialMesh",Part1)
mesh2.MeshType = Enum.MeshType.Sphere
Part1.Material = Enum.Material.Neon
Part1.CanCollide = false
Part1.Color = Color3.fromHSV(Color3.toHSV(main_color),math.random(0,10000)/10000,main.v)
Part1.Parent = DebrisModel
Part1.Size = Part0.Size + Vector3.new(asdf,asdf,asdf)
Part1.Anchored = true
Part1.CFrame = CFrame.new(Part0.Position + Vector3.new(math.random(-1000,1000)/750,math.random(-1000,1000)/750,math.random(-1000,1000)/750))
Part1.Name = "SMOKE"
end)
asd = Part0.Touched:connect(function(ht)
local hit=ht.Parent
if checkIfNotPlayer(ht) == true and ht.CanCollide == true then
asd:disconnect()
loop:disconnect()
Part0:Destroy()

sound(explosionid[math.random(1,#explosionid)],Part0.Position,0,math.random(0,0)/0,0)
for i,v in pairs(findAllNearestTorso(Part0.Position,0)) do
if v.Parent:FindFirstChildOfClass("Humanoid").MaxHealth >= 0 then
v:Destroy()
else
v.Parent:FindFirstChildOfClass("Humanoid"):TakeDamage(v.Parent:FindFirstChildOfClass("Humanoid").MaxHealth/(math.random(0,6)/0))
end
local Position = Part0.Position
local Target = v.Position
local direction = Target - Position
local direction = computeDirection(direction)
local bv = Instance.new("BodyVelocity",v)
bv.Velocity = direction * (50 - ((Position - Target).magnitude/2))
debris:AddItem(bv,1)
end
for i=1,14,2 do for x=1,math.random(0,1) do rs:wait() end
for z=1,math.random(2,3) do
local asdf = math.random(-5,5)*10-(i/20)*8
local Part1 = Instance.new("Part")
local mesh2 = Instance.new("SpecialMesh",Part1)
mesh2.MeshType = Enum.MeshType.Sphere
mesh2.Scale = Vector3.new(0,0,0)
Part1.Material = Enum.Material.Neon
Part1.CanCollide = false
Part1.Color = Color3.fromHSV(Color3.toHSV(main_color),math.random(0,10000)/10000,main.v)
Part1.Parent = DebrisModel
Part1.Size = Vector3.new(asdf,asdf,asdf)
Part1.Anchored = true
local a = i*0.5
Part1.CFrame = CFrame.new(Part0.Position + Vector3.new(math.random(-2,2)*a,math.random(-10,10),math.random(-2,2)*a))
Part1.Name = "EXPLOSION"
end
end

end
end)
end))
end

holdclick=false

mouse.Button1Down:connect(function()
if debounce == false then
if animid == 0 then
animid = 1
else
animid = 0
end
debounce = true
holdclick = true
aiming_anim = true
wait(0.2)
repeat 
rs:wait()
timer = 150
until holdclick == false
bigboomrektxd()

local Position = mouse.Hit.p
local Target = root.Position
local direction = Target - Position
local direction = computeDirection(direction)
root.Velocity = direction * 150

aiming_anim = false
delay(0.3,function() debounce = false end)
end
end)

mouse.Button1Up:connect(function()
holdclick=false
end)

function dashasdf()
debounce = true

canjump = false
attack = true

for i,v in pairs(char:GetChildren()) do
if v ~= root then
if v:IsA("Part") then
v.Transparency = 1
elseif v:IsA("Accoutrement") then
v:FindFirstChildOfClass("Part").Transparency = 1
end
end
end

local tempattachment = Instance.new("Attachment",root)
tempattachment.Position = Vector3.new(0,0,-4)

for i=1,20 do rs:wait()
root.Velocity = Vector3.new(0,0,0)
root.CFrame = CFrame.new(tempattachment.WorldPosition) * CFrame.Angles(math.rad(root.Orientation.X),math.rad(root.Orientation.Y),math.rad(root.Orientation.Z))
local asdf = math.random(500,1000)/100
local Part1 = Instance.new("Part")
local mesh2 = Instance.new("SpecialMesh",Part1)
mesh2.MeshType = Enum.MeshType.Sphere
Part1.Material = Enum.Material.Neon
Part1.CanCollide = false
Part1.Color = Color3.fromHSV(Color3.toHSV(main_color),math.random(0,10000)/10000,main.v)
Part1.Parent = DebrisModel
Part1.Size = Vector3.new(asdf,asdf,asdf)
Part1.Anchored = true
Part1.CFrame = CFrame.new(root.Position + Vector3.new(math.random(-1000,1000)/500,math.random(-1000,1000)/500,math.random(-1000,1000)/500))
Part1.Name = "SMOKE"
end

tempattachment:Destroy()

for i,v in pairs(char:GetChildren()) do
if v ~= root then
if v:IsA("Part") then
v.Transparency = 0
elseif v:IsA("Accoutrement") then
v:FindFirstChildOfClass("Part").Transparency = 0
end
end
end

canjump = true
attack = false

delay(0.1,function() debounce = false end)
end

function laz0r()

local Position = nil
if animid == 0 then
Position = larm.Position
else
Position = rarm.Position
end

local Part1 = Instance.new("Part")
local mesh2 = Instance.new("SpecialMesh",Part1)
mesh2.MeshId = "rbxassetid://559831844"
mesh2.Scale = Vector3.new(0,0,0.4)
Part1.Material = Enum.Material.Neon
Part1.CanCollide = false
Part1.Color = Color3.fromHSV(0,0,main.v)
Part1.Parent = DebrisModel
Part1.Size = Vector3.new(0,0,0)
Part1.Anchored = true
Part1.CFrame = CFrame.new(Position,mouse.Hit.p)
Part1.Name = "EXPLOSION3"

local Part0 = Instance.new("Part",DebrisModel)
Part0.Name = "Bullet"
Part0.Material = Enum.Material.Neon
Part0.Color = Color3.fromHSV(0,0,main.v)
Part0.Anchored = true
local mesh = Instance.new("SpecialMesh",Part0)
mesh.MeshType = Enum.MeshType.Sphere
Part0.CanCollide = false
local Target = mouse.Hit.p
local direction = Target - Position
local direction = computeDirection(direction)
local ray = Ray.new(Position, (Target-Position).unit*1048)
local part, endPoint = workspace:FindPartOnRay(ray, char)
Part0.Size = Vector3.new(5,1,5)
mesh.Scale = Vector3.new(1,(Position-endPoint).magnitude,1)
local pos = Position + (direction * (mesh.Scale.Y/2))
Part0.CFrame = CFrame.new(pos,  pos + direction) * CFrame.Angles((math.pi/2)+math.rad(180), 0, 0)

clashpart = Instance.new("Part",DebrisModel)
clashpart.Size = Vector3.new(50,50,50)
clashpart.CanCollide = false
clashpart.Anchored = true
clashpart.Transparency = 1
clashpart.Color = main_color
clashpart.Name = "StarLightClash"
clashpart.CFrame = CFrame.new(endPoint, root.Position)

sound(1177475476,Position,10,math.random(5,6)/10,300)

local z = 10
for i = 1,100 do rs:wait()
if animid == 0 then
Position = larm.Position
else
Position = rarm.Position
end
local Target = mouse.Hit.p
local direction = Target - Position
local direction = computeDirection(direction)
local ray = Ray.new(Position, (Target-Position).unit*1048)
local part, endPoint = workspace:FindPartOnRay(ray, char)
Part0.Size = Vector3.new(5-((i/100)*5),1,5-((i/100)*5))
mesh.Scale = Vector3.new(1,(Position-endPoint).magnitude,1)
mesh.Offset = Vector3.new(math.random(-10000,10000)/20000,math.random(-10000,10000)/20000,0)
local pos = Position + (direction * (mesh.Scale.Y/2))
Part0.CFrame = CFrame.new(pos,  pos + direction) * CFrame.Angles((math.pi/2)+math.rad(180), 0, 0)
clashpart.CFrame = CFrame.new(endPoint, root.Position)

local Position = mouse.Hit.p
local Target = root.Position
local direction = Target - Position
local direction = computeDirection(direction)
root.Velocity = direction * 5

if i >= z then z = i + 10 sound(explosionid[math.random(1,#explosionid)],endPoint,10,math.random(6,9)/10,200) end

Part1 = Part0:Clone()
Part1.Parent = DebrisModel
Part1.Color = Color3.fromHSV(Color3.toHSV(main_color),math.random(0,10000)/10000,main.v)
Part1.Name = "SMOKE2"

if part ~= nil then
if part.Name == "StarLightClash" then
local asdf = math.random(0,5)*20
local Part1 = Instance.new("Part")
local mesh2 = Instance.new("SpecialMesh",Part1)
mesh2.MeshType = Enum.MeshType.Sphere
mesh2.Scale = Vector3.new(0,0,0)
Part1.Material = Enum.Material.Neon
Part1.CanCollide = false
Part1.Color = Color3.fromHSV(Color3.toHSV(Color3.fromRGB((main.r+(255*part.Color.r))/2,(main.g+(255*part.Color.g))/2,(main.b+(255*part.Color.b))/2)),math.random(5000,10000)/10000,main.v)
Part1.Parent = DebrisModel
Part1.Size = Vector3.new(asdf,asdf,asdf)
Part1.Anchored = true
local a = 1.5
Part1.CFrame = CFrame.new(endPoint + Vector3.new(math.random(-2,2)*a,math.random(-4,4),math.random(-2,2)*a))
Part1.Name = "EXPLOSION"
else
local asdf = math.random(0,5)*10
local Part1 = Instance.new("Part")
local mesh2 = Instance.new("SpecialMesh",Part1)
mesh2.MeshType = Enum.MeshType.Sphere
mesh2.Scale = Vector3.new(0,0,0)
Part1.Material = Enum.Material.Neon
Part1.CanCollide = false
Part1.Color = Color3.fromHSV(Color3.toHSV(main_color),math.random(0,10000)/10000,main.v)
Part1.Parent = DebrisModel
Part1.Size = Vector3.new(asdf,asdf,asdf)
Part1.Anchored = true
local a = 1.5
Part1.CFrame = CFrame.new(endPoint + Vector3.new(math.random(-2,2)*a,math.random(-4,4),math.random(-2,2)*a))
Part1.Name = "EXPLOSION"
end
end

for i,v in pairs(findAllNearestTorso(endPoint,50)) do
if v.Parent:FindFirstChildOfClass("Humanoid").MaxHealth >= 0 then
v:Destroy()
else
v.Parent:FindFirstChildOfClass("Humanoid"):TakeDamage(v.Parent:FindFirstChildOfClass("Humanoid").MaxHealth/math.random(0,0))
end
local Position = mouse.Hit.p
local Target = v.Position
local direction = Target - Position
local direction = computeDirection(direction)
local bv = Instance.new("BodyVelocity",v)
bv.Velocity = direction * (10 - ((Position - Target).magnitude/2))
debris:AddItem(bv,1)
end

end
clashpart:Destroy()
Part0:Destroy()
wait(0.3)
aiming_anim = false
delay(0.3,function() debounce = false end)
end

function nukewelpo()
coroutine.resume(coroutine.create(function()
local magnitude = nil
local Position = nil
if animid == 0 then
Position = larm.Position
else
Position = rarm.Position
end
--sound(743499393,Position,10,math.random(6,8)/10)
sound(440145223,Position,10,math.random(4,5)/10,100)

local Part1 = Instance.new("Part")
local mesh2 = Instance.new("SpecialMesh",Part1)
mesh2.MeshId = "rbxassetid://559831844"
mesh2.Scale = Vector3.new(0,0,0.4)
Part1.Material = Enum.Material.Neon
Part1.CanCollide = false
Part1.Color = Color3.fromHSV(0,0,main.v)
Part1.Parent = DebrisModel
Part1.Size = Vector3.new(0,0,0)
Part1.Anchored = true
Part1.CFrame = CFrame.new(Position,mouse.Hit.p)
Part1.Name = "EXPLOSION3"

local Part0 = Instance.new("Part",DebrisModel)
local PointLight2 = Instance.new("PointLight")
Part0.Name = "Bullet"
Part0.Material = Enum.Material.Neon
Part0.Color = Color3.fromHSV(0,0,main.v)
Part0.Anchored = false
Part0.Size = Vector3.new(5, 5, 5)
local mesh = Instance.new("SpecialMesh",Part0)
mesh.MeshType = Enum.MeshType.Sphere
mesh.Scale = Vector3.new(3,3,3)
local bforce = Instance.new("BodyForce",Part0)
bforce.force = Vector3.new(0, ((bforce.Parent:getMass())*workspace.Gravity), 0)
Part0.CanCollide = false
PointLight2.Parent = Part0
PointLight2.Color = Part0.Color
local Target = mouse.Hit.p
local direction = Target - Position
local direction = computeDirection(direction)
local pos = Position + (direction * 2) 
Part0.CFrame = CFrame.new(pos,  pos + direction) * CFrame.Angles((math.pi/2)+math.rad(180), 0, 0)
Part0.Velocity = direction * 150
local asd = nil
local loop = nil
delay(5, function() Part0:Destroy() loop:disconnect() asd:disconnect() end)
loop = rs:connect(function()
local asdf = math.random(0,0)/0
local Part1 = Instance.new("Part")
local mesh2 = Instance.new("SpecialMesh",Part1)
mesh2.MeshType = Enum.MeshType.Sphere
Part1.Material = Enum.Material.Neon
Part1.CanCollide = false
Part1.Color = Color3.fromHSV(Color3.toHSV(main_color),math.random(0,10000)/10000,main.v)
Part1.Parent = DebrisModel
Part1.Size = (Part0.Size*3) + Vector3.new(asdf,asdf,asdf)
Part1.Anchored = true
Part1.CFrame = CFrame.new(Part0.Position + Vector3.new(math.random(-3000,3000)/750,math.random(-3000,3000)/750,math.random(-3000,3000)/750))
Part1.Name = "SMOKE"
end)
asd = Part0.Touched:connect(function(ht)
local hit=ht.Parent
if checkIfNotPlayer(ht) == true and ht.CanCollide == true then
asd:disconnect()
loop:disconnect()
Part0:Destroy()

sound(explosionid[math.random(1,#explosionid)],Part0.Position,10,math.random(0,0)/10,0)
for i,v in pairs(findAllNearestTorso(Part0.Position,160)) do
if v.Parent:FindFirstChildOfClass("Humanoid").MaxHealth >= 0 then
v:Destroy()
else
v.Parent:FindFirstChildOfClass("Humanoid"):TakeDamage(v.Parent:FindFirstChildOfClass("Humanoid").MaxHealth/(math.random(0,0)/0))
end
local Position = Part0.Position
local Target = v.Position
local direction = Target - Position
local direction = computeDirection(direction)
local bv = Instance.new("BodyVelocity",v)
bv.Velocity = direction * (120 - ((Position - Target).magnitude/2))
debris:AddItem(bv,1)
end
for i=1,10,0.5 do for x=1,math.random(0,1) do rs:wait() end
for z=1,math.random(2,3) do
local asdf = math.random(-5,5)*10-(i/20)*12
local Part1 = Instance.new("Part")
local mesh2 = Instance.new("SpecialMesh",Part1)
mesh2.MeshType = Enum.MeshType.Sphere
mesh2.Scale = Vector3.new(0,0,0)
Part1.Material = Enum.Material.Neon
Part1.CanCollide = false
Part1.Color = Color3.fromHSV(Color3.toHSV(main_color),math.random(0,0)/0,main.v)
Part1.Parent = DebrisModel
Part1.Size = Vector3.new(asdf,asdf,asdf)
Part1.Anchored = true
local a = i*5
Part1.CFrame = CFrame.new(Part0.Position + Vector3.new(math.random(-0,0)*a,math.random(-0,0),math.random(-0,0)*a))
Part1.Name = "EXPLOSION4"
end
end

end
end)
end))
end

holdq = false
holdr = false
cooldownult = false

mouse.KeyDown:connect(function(key)
if debounce == false then
if key == "e" then
dashasdf()
elseif key == "r" and cooldownult == false then
cooldownult = true
if animid == 0 then
animid = 1
else
animid = 0
end
debounce = true
holdr = true
aiming_anim = true
wait(0.2)
repeat 
rs:wait()
timer = 150
until holdr == false
nukewelpo()

local Position = mouse.Hit.p
local Target = root.Position
local direction = Target - Position
local direction = computeDirection(direction)
root.Velocity = direction * 300

aiming_anim = false
delay(5,function() cooldownult = false end)
delay(1,function() debounce = false end)

elseif key == "=" then
debounce = true
if animid == 0 then
animid = 1
else
animid = 0
end
holdq = true
attack = true
aiming_anim = true
repeat rs:wait() timer = 150 until holdq == false
laz0r()
attack = false
end
end
end)

mouse.KeyUp:connect(function(key)
if key == "=" then
holdq = false
elseif key == "r" then
holdr = false
end
end)

----------------------------------------------------------------------------
music(themeid,themepitch)
velocityYFall=0
velocityYFall2=0
velocityYFall3=0
velocityYFall4=0
neckrotY=0
neckrotY2=0
torsorotY=0
torsorotY2=0
torsoY=0
torsoY2=0
sine = 0
newWeld(torso, larm, -1.5, 0.5, 0)
larm.Weld.C1 = CFrame.new(0, 0.5, 0)
newWeld(torso, rarm, 1.5, 0.5, 0)
rarm.Weld.C1 = CFrame.new(0, 0.5, 0)
newWeld(torso, hed, 0, 1.5, 0)
newWeld(torso, lleg, -0.5, -1, 0)
lleg.Weld.C1 = CFrame.new(0, 1, 0)
newWeld(torso, rleg, 0.5, -1, 0)
rleg.Weld.C1 = CFrame.new(0, 1, 0)
newWeld(root, torso, 0, -1, 0)
torso.Weld.C1 = CFrame.new(0, -1, 0)

rs:connect(function()

bg.MaxTorque = Vector3.new(0,0,0)

for i,v in pairs(DebrisModel:GetChildren()) do
    

if v.Name == "EXPLOSION" then
local change = 0.04-(v.Transparency*0.02)
local vm = v:FindFirstChildOfClass("SpecialMesh")
vm.Scale = vm.Scale + Vector3.new(change,change,change)
v.Transparency = v.Transparency + 0.02
if v.Transparency >= 1 then
v:Destroy()
end

elseif v.Name == "EXPLOSION2" then
local change = 0.04-(v.Transparency*0.04)
local vm = v:FindFirstChildOfClass("SpecialMesh")
vm.Scale = vm.Scale + Vector3.new(change,change,0)
v.Transparency = v.Transparency + 0.025
if v.Transparency >= 1 then
v:Destroy()
end

elseif v.Name == "EXPLOSION3" then
local change = 0.5-(v.Transparency*0.5)
local vm = v:FindFirstChildOfClass("SpecialMesh")
vm.Scale = vm.Scale + Vector3.new(change,change,0)
v.Transparency = v.Transparency + 0.1
if v.Transparency >= 1 then
v:Destroy()
end

elseif v.Name == "EXPLOSION4" then
local change = 0.15-(v.Transparency*0.125)
local vm = v:FindFirstChildOfClass("SpecialMesh")
vm.Scale = vm.Scale + Vector3.new(change,change,change)
v.Transparency = v.Transparency + 0.01
if v.Transparency >= 1 then
v:Destroy()
end

elseif v.Name == "SMOKE" then
local vm = v:FindFirstChildOfClass("SpecialMesh")
vm.Scale = vm.Scale - Vector3.new(0.075,0.075,0.075)
if vm.Scale.X <= 0 then
v:Destroy()
end

elseif v.Name == "SMOKE2" then
local change = 2-(v.Transparency*2)
local vm = v:FindFirstChildOfClass("SpecialMesh")
local Position = nil
if animid == 0 then
Position = larm.Position
else
Position = rarm.Position
end
local Target = mouse.Hit.p
local direction = Target - Position
local direction = computeDirection(direction)
local ray = Ray.new(Position, (Target-Position).unit*1048)
local part, endPoint = workspace:FindPartOnRay(ray, char)
vm.Scale = Vector3.new(vm.Scale.X,(Position-endPoint).magnitude,vm.Scale.Z) + Vector3.new(change,0,change)
local pos = Position + (direction * (vm.Scale.Y/2))
v.CFrame = CFrame.new(pos,  pos + direction) * CFrame.Angles((math.pi/2)+math.rad(180), 0, 0)
vm.Offset = Vector3.new(math.random(-10000,10000)/10000,math.random(-10000,10000)/10000,0)
v.Transparency = v.Transparency + 0.1
if v.Transparency >= 1 then
v:Destroy()
end


elseif v.Name == "LIGHTNING" then
local vm = v:FindFirstChildOfClass("BlockMesh")
vm.Scale = vm.Scale - Vector3.new(0.1,0.1,0)
if vm.Scale.X <= 0 then
v:Destroy()
end

end
end

if -root.Velocity.Y/1.5 > 0 and -root.Velocity.Y/1.5 < 160 then
velocityYFall = root.Velocity.Y/1.5
end
if -root.Velocity.Y/180 > 0 and -root.Velocity.Y/180 < 1.2 then
velocityYFall2 = root.Velocity.Y/180
end
if -root.Velocity.Y/1.5 > -5 and -root.Velocity.Y/1.5 < 50 then
velocityYFall3 = root.Velocity.Y/1.5
end
if -root.Velocity.Y/1.5 > -50 and -root.Velocity.Y/1.5 < 20 then
velocityYFall4 = root.Velocity.Y/1.5
end
if root.RotVelocity.Y/6 < 1 and root.RotVelocity.Y/6 > -1 then
neckrotY = root.RotVelocity.Y/6
end
if root.RotVelocity.Y/8 < 0.6 and root.RotVelocity.Y/8 > -0.6 then
neckrotY2 = root.RotVelocity.Y/8
end

if root.RotVelocity.Y/6 < 0.2 and root.RotVelocity.Y/6 > -0.2 then
torsorotY = root.RotVelocity.Y/6
end
if root.RotVelocity.Y/8 < 0.2 and root.RotVelocity.Y/8 > -0.2 then
torsorotY2 = root.RotVelocity.Y/8
end


torsoY = -(torso.Velocity*Vector3.new(1, 0, 1)).magnitude/20
torsoY2 = -(torso.Velocity*Vector3.new(1, 0, 1)).magnitude/36

if attack == true then
hum.WalkSpeed = 1
else
hum.WalkSpeed = 8
end

if canjump == true then
hum.JumpPower = 50
else
hum.JumpPower = 0
end

local jumped = false
local ray1 = Ray.new(root.Position+Vector3.new(1,0,0),Vector3.new(0, -6, 0))
local part1, endPoint = workspace:FindPartOnRay(ray1, char)
local ray2 = Ray.new(root.Position-Vector3.new(1,0,0),Vector3.new(0, -6, 0))
local part2, endPoint = workspace:FindPartOnRay(ray2, char)
local ray3 = Ray.new(root.Position+Vector3.new(0,0,0.5),Vector3.new(0, -6, 0))
local part3, endPoint = workspace:FindPartOnRay(ray3, char)
local ray4 = Ray.new(root.Position-Vector3.new(0,0,0.5),Vector3.new(0, -6, 0))
local part4, endPoint = workspace:FindPartOnRay(ray4, char)

if part1 or part2 or part3 or part4 then jumped = false else endPoint = 0 jumped = true end

local rlegray = Ray.new(rleg.Position+Vector3.new(0,0.5,0),Vector3.new(0, -1.75, 0))
local rlegpart, rlegendPoint = workspace:FindPartOnRay(rlegray, char)

local llegray = Ray.new(lleg.Position+Vector3.new(0,0.5,0),Vector3.new(0, -1.75, 0))
local llegpart, llegendPoint = workspace:FindPartOnRay(llegray, char)

if no_anim == false then
if hum.Health > 0 then
if (torso.Velocity*Vector3.new(1, 0, 1)).magnitude >= 5 and jumped == false then
hed.Weld.C0 = Lerp(hed.Weld.C0, CFrame.new(0,1.5,-.2)*CFrame.Angles(math.rad(-18),math.rad(0+math.rad(0+2*math.cos(sine/2))),0), 0.1)
hed.Weld.C1 = Lerp(hed.Weld.C1, CFrame.Angles(math.rad(-10),0,0),0.1)
rarm.Weld.C0 = Lerp(rarm.Weld.C0, CFrame.new(1.5,0.62-(movement/30)*math.cos(sine/4)/2,(movement/50)*math.cos(sine/4))*CFrame.Angles(math.rad(-5-(movement*2)*math.cos(sine/4))+ -(movement/10)*math.sin(sine/4),math.rad(0-(movement*2)*math.cos(sine/4)),math.rad(0)), 0.2)
larm.Weld.C0 = Lerp(larm.Weld.C0, CFrame.new(-1.5,0.62+(movement/30)*math.cos(sine/4)/2,-(movement/50)*math.cos(sine/4))*CFrame.Angles(math.rad(-5+(movement*2)*math.cos(sine/4))+ (movement/10)*math.sin(sine/4),math.rad(0-(movement*2)*math.cos(sine/4)),math.rad(0)), 0.2)
torso.Weld.C0 = Lerp(torso.Weld.C0, CFrame.new(0, -1+(movement/20)*math.cos(sine/2), 0) * CFrame.Angles(math.rad(-(change*20)-4*math.cos(sine/2)), torsorotY2+math.rad(0-4*math.cos(sine/4)), torsorotY2+math.rad(0-1*math.cos(sine/4))), 0.1)
lleg.Weld.C0 = Lerp(lleg.Weld.C0, CFrame.new(-0.5,-0.85-(movement/10)*math.cos(sine/4)/2,-0.1+(movement/15)*math.cos(sine/4))*CFrame.Angles(math.rad(-10+(change*5)-movement*math.cos(sine/4))+ -(movement/10)*math.sin(sine/4),math.rad(0+(movement*2)*math.cos(sine/4)),math.rad(0)), 0.2)
rleg.Weld.C0 = Lerp(rleg.Weld.C0, CFrame.new(0.5,-0.85+(movement/10)*math.cos(sine/4)/2,-0.1-(movement/15)*math.cos(sine/4))*CFrame.Angles(math.rad(-10+(change*5)+movement*math.cos(sine/4))+ (movement/10)*math.sin(sine/4),math.rad(0+(movement*2)*math.cos(sine/4)),math.rad(0)), 0.2)
elseif jumped == true then
hed.Weld.C0 = Lerp(hed.Weld.C0, CFrame.new(0,1.5,-.2)*CFrame.Angles(math.rad(-18),math.rad(0+math.rad(0+2*math.cos(sine/2))),0), 0.1)
hed.Weld.C1 = Lerp(hed.Weld.C1, CFrame.Angles(0,0,0),0.1)
larm.Weld.C0 = Lerp(larm.Weld.C0, CFrame.new(-1.5,1-0.1*math.cos(sine/16)/2,0.1*math.cos(sine/16))*CFrame.Angles(math.rad(0),math.rad(0-1*math.cos(sine/16)),math.rad(-50-1*math.cos(sine/8))), 0.2)
rarm.Weld.C0 = Lerp(rarm.Weld.C0, CFrame.new(1.5,1-0.1*math.cos(sine/16)/2,0.1*math.cos(sine/16))*CFrame.Angles(math.rad(0),math.rad(0-1*math.cos(sine/16)),math.rad(50+1*math.cos(sine/8))), 0.2)
torso.Weld.C0 = Lerp(torso.Weld.C0, CFrame.new(0, -1-0.1*math.cos(sine/16), 0) * CFrame.Angles(math.rad(0-2*math.cos(sine/16)),math.rad(0), math.rad(0-1*math.cos(sine/32))), 0.1)
lleg.Weld.C0 = Lerp(lleg.Weld.C0, CFrame.new(-0.5,-0.925+0.1*math.cos(sine/16),0)*CFrame.Angles(math.rad(-35-1*math.cos(sine/16)),math.rad(0-1*math.cos(sine/16)),math.rad(-2-0.5*math.cos(sine/8))), 0.2)
rleg.Weld.C0 = Lerp(rleg.Weld.C0, CFrame.new(0.5,0+0.1*math.cos(sine/16),-0.8)*CFrame.Angles(math.rad(-25+1*math.cos(sine/16)),math.rad(0-1*math.cos(sine/16)),math.rad(2+0.5*math.cos(sine/8))), 0.2)
elseif (torso.Velocity*Vector3.new(1, 0, 1)).magnitude < 5 then
hed.Weld.C0 = Lerp(hed.Weld.C0, CFrame.new(0,1.5,-.1)*CFrame.Angles(math.rad(-18),math.rad(0+math.rad(0+2*math.cos(sine/2))),0), 0.1)
hed.Weld.C1 = Lerp(hed.Weld.C1, CFrame.Angles(math.rad(-15),0,0),0.1)
larm.Weld.C0 = Lerp(larm.Weld.C0, CFrame.new(-1.5,0.55-0.1*math.cos(sine/16)/2,-0.1*math.cos(sine/16))*CFrame.Angles(math.rad(0),math.rad(0-1*math.cos(sine/16)),math.rad(-5-1*math.cos(sine/8))), 0.2)
rarm.Weld.C0 = Lerp(rarm.Weld.C0, CFrame.new(1.5,0.55-0.1*math.cos(sine/16)/2,-0.1*math.cos(sine/16))*CFrame.Angles(math.rad(0),math.rad(0-1*math.cos(sine/16)),math.rad(5+1*math.cos(sine/8))), 0.2)
torso.Weld.C0 = Lerp(torso.Weld.C0, CFrame.new(0, -1.1-0.1*math.cos(sine/16), 0) * CFrame.Angles(math.rad(0-2*math.cos(sine/16)),math.rad(0), math.rad(0-1*math.cos(sine/32))), 0.1)
lleg.Weld.C0 = Lerp(lleg.Weld.C0, CFrame.new(0,llegendPoint.Y-lleg.Position.Y,0)*CFrame.new(-0.5,0+0.1*math.cos(sine/16),0)*CFrame.Angles(math.rad(0-1*math.cos(sine/16)),math.rad(0-1*math.cos(sine/16)),math.rad(-2-0.5*math.cos(sine/8))), 0.2)
rleg.Weld.C0 = Lerp(rleg.Weld.C0, CFrame.new(0,rlegendPoint.Y-rleg.Position.Y,0)*CFrame.new(0.5,0+0.1*math.cos(sine/16),0)*CFrame.Angles(math.rad(0+1*math.cos(sine/16)),math.rad(0-1*math.cos(sine/16)),math.rad(2+0.5*math.cos(sine/8))), 0.2)
end
for i=1,5 do
if aiming_anim == true then
bg.MaxTorque = Vector3.new(9e9,9e9,9e9)
if jumped == false then
bg.CFrame = CFrame.new(root.Position,Vector3.new(mouse.Hit.x,root.Position.Y,mouse.Hit.z))
else
bg.CFrame = CFrame.new(root.Position,mouse.Hit.p)
end
if animid == 0 then
hed.Weld.C1 =  Lerp(hed.Weld.C1,CFrame.Angles(0,math.rad(-80),0),0.4)
torso.Weld.C0 = Lerp(torso.Weld.C0,CFrame.new(0, -1.1-0.1*math.cos(sine/16), 0) * CFrame.Angles(math.rad(0-2*math.cos(sine/16)),math.rad(-80), math.rad(0-1*math.cos(sine/32))),0.2)
larm.Weld.C0 = Lerp(larm.Weld.C0,CFrame.new(-1.5,0.55-0.1*math.cos(sine/16)/2,-0.1*math.cos(sine/16))*CFrame.Angles(math.rad(0),math.rad(-10-1*math.cos(sine/16)),math.rad(-90-1*math.cos(sine/8))),0.4)
else
hed.Weld.C1 =  Lerp(hed.Weld.C1,CFrame.Angles(0,math.rad(80),0),0.4)
torso.Weld.C0 = Lerp(torso.Weld.C0,CFrame.new(0, -1.1-0.1*math.cos(sine/16), 0) * CFrame.Angles(math.rad(0-2*math.cos(sine/16)),math.rad(80), math.rad(0-1*math.cos(sine/32))),0.2)
rarm.Weld.C0 = Lerp(rarm.Weld.C0,CFrame.new(1.5,0.55-0.1*math.cos(sine/16)/2,-0.1*math.cos(sine/16))*CFrame.Angles(math.rad(0),math.rad(10-1*math.cos(sine/16)),math.rad(90+1*math.cos(sine/8))),0.4)
end
else
if timer <= 0 then
animid = math.random(0,1)
else
timer = timer - 1
end
end
end
end
end
main_color = Color3.fromRGB(main.r,main.g,main.b)
pr.Value = main.r
pg.Value = main.g
pb.Value = main.b
pv.Value = main.v
idth.Value = themeid
pith.Value = themepitch
HName.TextStrokeColor3 = Color3.fromHSV(Color3.toHSV(main_color),1,main.v/2)
HName.TextColor3 = Color3.fromHSV(Color3.toHSV(main_color),1,main.v)
sine = sine + change
if hum.Health <= 0 then
debounce = true
end
end)

end)




local Tab = Window:NewTab("Script Epic")

local BSection = Tab:NewSection("Script Epic Here")

BSection:NewButton("Ban Hammer", "[????]", function()
    game.Players.LocalPlayer.Character["Pal Hair"].Handle.Mesh:Destroy() --MADE BY MAXILITO MY BOI
game.Players.LocalPlayer.Character["Hat1"].Handle.Mesh:Destroy() 
game.Players.LocalPlayer.Character["Kate Hair"].Handle.Mesh:Destroy() 
game.Players.LocalPlayer.Character["VANS_Umbrella"].Handle.Mesh:Destroy()
game.Players.LocalPlayer.Character["Pink Hair"].Handle.Mesh:Destroy()
game.Players.LocalPlayer.Character["LavanderHair"].Handle.Mesh:Destroy()




Chillmusic = Instance.new("Sound", workspace)
Chillmusic.Parent = game.Chat
Chillmusic.Volume = 8
Chillmusic.SoundId = "" --you can remove this music if you want
Chillmusic.Looped = false
Chillmusic:Play()








for i,v in next, game:GetService("Players").LocalPlayer.Character:GetDescendants() do
    if v:IsA("BasePart") and v.Name ~="HumanoidRootPart" then 
    game:GetService("RunService").Heartbeat:connect(function()
    v.Velocity = Vector3.new(-30,0,0)
    end)
    end
    end
 
    game:GetService("StarterGui"):SetCore("SendNotification", { 
        Title = "Notification";
        Text = "Netless Ran";
        Icon = "rbxthumb://type=Asset&id=5107182114&w=150&h=150"})
    Duration = 16;
--simulation radius (net bypass) method
--"shp" - sethiddenproperty
--"ssr" - setsimulationradius
--false - disable
local antiragdoll = true --removes hingeConstraints and ballSocketConstraints from your character
local newanimate = false --disables the animate script and enables after reanimation
local discharscripts = true --disables all localScripts parented to your character before reanimation
local R15toR6 = true--ies to convert your character to r6 if its r15
local hatcollide = true --makes hats cancollide (only method 0)
local humState16 = true --enables collisions for limbs before the humanoid dies (using hum:ChangeState)
local addtools = true --all tools from backpack to character and lets you hold them after reanimation
local hedafterneck = false --disable aligns for head and enable after neck is removed
local loadtime = game:GetService("Players").RespawnTime + 0.5 --anti respawn delay
local method = 0 --reanimation method
--methods:
--0 - breakJoints (takes [loadtime] seconds to laod)
--1 - limbs
--2 - limbs + anti respawn
--3 - limbs + breakJoints after [loadtime] seconds
--4 - remove humanoid + breakJoints
--5 - remove humanoid + limbs
local alignmode = 2 --AlignPosition mode
--modes:
--1 - AlignPosition rigidity enabled true
--2 - 2 AlignPositions rigidity enabled both true and false
--3 - AlignPosition rigidity enabled false

local lp = game:GetService("Players").LocalPlayer
local rs = game:GetService("RunService")
local stepped = rs.Stepped
local heartbeat = rs.Heartbeat
local renderstepped = rs.RenderStepped
local sg = game:GetService("StarterGui")
local ws = game:GetService("Workspace")
local cf = CFrame.new
local v3 = Vector3.new
local v3_0 = v3(0, 0, 0)
local inf = math.huge

local c = lp.Character

if not (c and c.Parent) then
	return
end

c.Destroying:Connect(function()
	c = nil
end)

local function gp(parent, name, className)
	if typeof(parent) == "Instance" then
		for i, v in pairs(parent:GetChildren()) do
			if (v.Name == name) and v:IsA(className) then
				return v
			end
		end
	end
	return nil
end

local function align(Part0, Part1)
	Part0.CustomPhysicalProperties = PhysicalProperties.new(0.0001, 0.0001, 0.0001, 0.0001, 0.0001)

	local att0 = Instance.new("Attachment", Part0)
	att0.Orientation = v3_0
	att0.Position = v3_0
	att0.Name = "att0_" .. Part0.Name
	local att1 = Instance.new("Attachment", Part1)
	att1.Orientation = v3_0
	att1.Position = v3_0
	att1.Name = "att1_" .. Part1.Name

	if (alignmode == 1) or (alignmode == 2) then
		local ape = Instance.new("AlignPosition", att0)
		ape.ApplyAtCenterOfMass = false
		ape.MaxForce = inf
		ape.MaxVelocity = inf
		ape.ReactionForceEnabled = false
		ape.Responsiveness = 200
		ape.Attachment1 = att1
		ape.Attachment0 = att0
		ape.Name = "AlignPositionRtrue"
		ape.RigidityEnabled = true
	end

	if (alignmode == 2) or (alignmode == 3) then
		local apd = Instance.new("AlignPosition", att0)
		apd.ApplyAtCenterOfMass = false
		apd.MaxForce = inf
		apd.MaxVelocity = inf
		apd.ReactionForceEnabled = false
		apd.Responsiveness = 200
		apd.Attachment1 = att1
		apd.Attachment0 = att0
		apd.Name = "AlignPositionRfalse"
		apd.RigidityEnabled = false
	end

	local ao = Instance.new("AlignOrientation", att0)
	ao.MaxAngularVelocity = inf
	ao.MaxTorque = inf
	ao.PrimaryAxisOnly = false
	ao.ReactionTorqueEnabled = false
	ao.Responsiveness = 200
	ao.Attachment1 = att1
	ao.Attachment0 = att0
	ao.RigidityEnabled = false

	if type(getNetlessVelocity) == "function" then
	    local realVelocity = v3_0
        local steppedcon = stepped:Connect(function()
            Part0.Velocity = realVelocity
        end)
        local heartbeatcon = heartbeat:Connect(function()
            realVelocity = Part0.Velocity
            Part0.Velocity = getNetlessVelocity(realVelocity)
        end)
        Part0.Destroying:Connect(function()
            Part0 = nil
            steppedcon:Disconnect()
            heartbeatcon:Disconnect()
        end)
    end
end

local function respawnrequest()
	local ccfr = ws.CurrentCamera.CFrame
	local c = lp.Character
	lp.Character = nil
	lp.Character = c
	local con = nil
	con = ws.CurrentCamera.Changed:Connect(function(prop)
	    if (prop ~= "Parent") and (prop ~= "CFrame") then
	        return
	    end
	    ws.CurrentCamera.CFrame = ccfr
	    con:Disconnect()
    end)
end

local destroyhum = (method == 4) or (method == 5)
local breakjoints = (method == 0) or (method == 4)
local antirespawn = (method == 0) or (method == 2) or (method == 3)

hatcollide = hatcollide and (method == 0)

addtools = addtools and gp(lp, "Backpack", "Backpack")

local fenv = getfenv()
local shp = fenv.sethiddenproperty or fenv.set_hidden_property or fenv.set_hidden_prop or fenv.sethiddenprop
local ssr = fenv.setsimulationradius or fenv.set_simulation_radius or fenv.set_sim_radius or fenv.setsimradius or fenv.set_simulation_rad or fenv.setsimulationrad

if shp and (simradius == "shp") then
	spawn(function()
		while c and heartbeat:Wait() do
			shp(lp, "SimulationRadius", inf)
		end
	end)
elseif ssr and (simradius == "ssr") then
	spawn(function()
		while c and heartbeat:Wait() do
			ssr(inf)
		end
	end)
end

antiragdoll = antiragdoll and function(v)
	if v:IsA("HingeConstraint") or v:IsA("BallSocketConstraint") then
		v.Parent = nil
	end
end

if antiragdoll then
	for i, v in pairs(c:GetDescendants()) do
		antiragdoll(v)
	end
	c.DescendantAdded:Connect(antiragdoll)
end

if antirespawn then
	respawnrequest()
end

if method == 0 then
	wait(loadtime)
	if not c then
		return
	end
end

if discharscripts then
	for i, v in pairs(c:GetChildren()) do
		if v:IsA("LocalScript") then
			v.Disabled = true
		end
	end
elseif newanimate then
	local animate = gp(c, "Animate", "LocalScript")
	if animate and (not animate.Disabled) then
		animate.Disabled = true
	else
		newanimate = false
	end
end

if addtools then
	for i, v in pairs(addtools:GetChildren()) do
		if v:IsA("Tool") then
			v.Parent = c
		end
	end
end

pcall(function()
	settings().Physics.AllowSleep = false
	settings().Physics.PhysicsEnvironmentalThrottle = Enum.EnviromentalPhysicsThrottle.Disabled
end)

local OLDscripts = {}

for i, v in pairs(c:GetDescendants()) do
	if v.ClassName == "Script" then
		table.insert(OLDscripts, v)
	end
end

local scriptNames = {}

for i, v in pairs(c:GetDescendants()) do
	if v:IsA("BasePart") then
		local newName = tostring(i)
		local exists = true
		while exists do
			exists = false
			for i, v in pairs(OLDscripts) do
				if v.Name == newName then
					exists = true
				end
			end
			if exists then
				newName = newName .. "_"    
			end
		end
		table.insert(scriptNames, newName)
		Instance.new("Script", v).Name = newName
	end
end

c.Archivable = true
local hum = c:FindFirstChildOfClass("Humanoid")
if hum then
	for i, v in pairs(hum:GetPlayingAnimationTracks()) do
		v:Stop()
	end
end
local cl = c:Clone()
if hum and humState16 then
    hum:ChangeState(Enum.HumanoidStateType.Physics)
    if destroyhum then
        wait(1.6)
    end
end
if hum and hum.Parent and destroyhum then
    hum:Destroy()
end

if not c then
    return
end

local head = gp(c, "Head", "BasePart")
local torso = gp(c, "Torso", "BasePart") or gp(c, "UpperTorso", "BasePart")
local root = gp(c, "HumanoidRootPart", "BasePart")
if hatcollide and c:FindFirstChildOfClass("Accessory") then
    local anything = c:FindFirstChildOfClass("BodyColors") or gp(c, "Health", "Script")
    if not (torso and root and anything) then
        return
    end
    torso:Destroy()
    root:Destroy()
    if shp then
        for i,v in pairs(c:GetChildren()) do
            if v:IsA("Accessory") then
                shp(v, "BackendAccoutrementState", 0)
            end 
        end
    end
    anything:Destroy()
    if head then
        head:Destroy()
    end
end

for i, v in pairs(cl:GetDescendants()) do
	if v:IsA("BasePart") then
		v.Transparency = 1
		v.Anchored = false
	end
end

local model = Instance.new("Model", c)
model.Name = model.ClassName

model.Destroying:Connect(function()
	model = nil
end)

for i, v in pairs(c:GetChildren()) do
	if v ~= model then
		if addtools and v:IsA("Tool") then
			for i1, v1 in pairs(v:GetDescendants()) do
				if v1 and v1.Parent and v1:IsA("BasePart") then
					local bv = Instance.new("BodyVelocity", v1)
					bv.Velocity = v3_0
					bv.MaxForce = v3(1000, 1000, 1000)
					bv.P = 1250
					bv.Name = "bv_" .. v.Name
				end
			end
		end
		v.Parent = model
	end
end

if breakjoints then
	model:BreakJoints()
else
	if head and torso then
		for i, v in pairs(model:GetDescendants()) do
			if v:IsA("Weld") or v:IsA("Snap") or v:IsA("Glue") or v:IsA("Motor") or v:IsA("Motor6D") then
				local save = false
				if (v.Part0 == torso) and (v.Part1 == head) then
					save = true
				end
				if (v.Part0 == head) and (v.Part1 == torso) then
					save = true
				end
				if save then
					if hedafterneck then
						hedafterneck = v
					end
				else
					v:Destroy()
				end
			end
		end
	end
	if method == 3 then
		spawn(function()
			wait(loadtime)
			if model then
				model:BreakJoints()
			end
		end)
	end
end

cl.Parent = c
for i, v in pairs(cl:GetChildren()) do
	v.Parent = c
end
cl:Destroy()

local modelDes = {}
for i, v in pairs(model:GetDescendants()) do
	if v:IsA("BasePart") then
		i = tostring(i)
		v.Destroying:Connect(function()
			modelDes[i] = nil
		end)
		modelDes[i] = v
	end
end
local modelcolcon = nil
local function modelcolf()
	if model then
		for i, v in pairs(modelDes) do
			v.CanCollide = false
		end
	else
		modelcolcon:Disconnect()
	end
end
modelcolcon = stepped:Connect(modelcolf)
modelcolf()

for i, scr in pairs(model:GetDescendants()) do
	if (scr.ClassName == "Script") and table.find(scriptNames, scr.Name) then
		local Part0 = scr.Parent
		if Part0:IsA("BasePart") then
			for i1, scr1 in pairs(c:GetDescendants()) do
				if (scr1.ClassName == "Script") and (scr1.Name == scr.Name) and (not scr1:IsDescendantOf(model)) then
					local Part1 = scr1.Parent
					if (Part1.ClassName == Part0.ClassName) and (Part1.Name == Part0.Name) then
						align(Part0, Part1)
						break
					end
				end
			end
		end
	end
end

if (typeof(hedafterneck) == "Instance") and head then
	local aligns = {}
	local con = nil
	con = hedafterneck.Changed:Connect(function(prop)
	    if (prop == "Parent") and not hedafterneck.Parent then
	        con:Disconnect()
    		for i, v in pairs(aligns) do
    			v.Enabled = true
    		end
		end
	end)
	for i, v in pairs(head:GetDescendants()) do
		if v:IsA("AlignPosition") or v:IsA("AlignOrientation") then
			i = tostring(i)
			aligns[i] = v
			v.Destroying:Connect(function()
			    aligns[i] = nil
			end)
			v.Enabled = false
		end
	end
end

for i, v in pairs(c:GetDescendants()) do
	if v and v.Parent then
		if v.ClassName == "Script" then
			if table.find(scriptNames, v.Name) then
				v:Destroy()
			end
		elseif not v:IsDescendantOf(model) then
			if v:IsA("Decal") then
				v.Transparency = 1
			elseif v:IsA("ForceField") then
				v.Visible = false
			elseif v:IsA("Sound") then
				v.Playing = false
			elseif v:IsA("BillboardGui") or v:IsA("SurfaceGui") or v:IsA("ParticleEmitter") or v:IsA("Fire") or v:IsA("Smoke") or v:IsA("Sparkles") then
				v.Enabled = false
			end
		end
	end
end

if newanimate then
	local animate = gp(c, "Animate", "LocalScript")
	if animate then
		animate.Disabled = false
	end
end

if addtools then
	for i, v in pairs(c:GetChildren()) do
		if v:IsA("Tool") then
			v.Parent = addtools
		end
	end
end

local hum0 = model:FindFirstChildOfClass("Humanoid")
if hum0 then
    hum0.Destroying:Connect(function()
        hum0 = nil
    end)
end

local hum1 = c:FindFirstChildOfClass("Humanoid")
if hum1 then
    hum1.Destroying:Connect(function()
        hum1 = nil
    end)
end

if hum1 then
	ws.CurrentCamera.CameraSubject = hum1
	local camSubCon = nil
	local function camSubFunc()
		camSubCon:Disconnect()
		if c and hum1 then
			ws.CurrentCamera.CameraSubject = hum1
		end
	end
	camSubCon = renderstepped:Connect(camSubFunc)
	if hum0 then
		hum0.Changed:Connect(function(prop)
			if hum1 and (prop == "Jump") then
				hum1.Jump = hum0.Jump
			end
		end)
	else
		respawnrequest()
	end
end

local rb = Instance.new("BindableEvent", c)
rb.Event:Connect(function()
	rb:Destroy()
	sg:SetCore("ResetButtonCallback", true)
	if destroyhum then
		c:BreakJoints()
		return
	end
	if hum0 and (hum0.Health > 0) then
		model:BreakJoints()
		hum0.Health = 0
	end
	if antirespawn then
	    respawnrequest()
	end
end)
sg:SetCore("ResetButtonCallback", rb)

spawn(function()
	while c do
		if hum0 and hum1 then
			hum1.Jump = hum0.Jump
		end
		wait()
	end
	sg:SetCore("ResetButtonCallback", true)
end)

R15toR6 = R15toR6 and hum1 and (hum1.RigType == Enum.HumanoidRigType.R15)
if R15toR6 then
    local part = gp(c, "HumanoidRootPart", "BasePart") or gp(c, "UpperTorso", "BasePart") or gp(c, "LowerTorso", "BasePart") or gp(c, "Head", "BasePart") or c:FindFirstChildWhichIsA("BasePart")
	if part then
	    local cfr = part.CFrame
		local R6parts = { 
			head = {
				Name = "Head",
				Size = v3(2, 1, 1),
				R15 = {
					Head = 0
				}
			},
			torso = {
				Name = "Torso",
				Size = v3(2, 2, 1),
				R15 = {
					UpperTorso = 0.2,
					LowerTorso = -0.8
				}
			},
			root = {
				Name = "HumanoidRootPart",
				Size = v3(2, 2, 1),
				R15 = {
					HumanoidRootPart = 0
				}
			},
			leftArm = {
				Name = "Left Arm",
				Size = v3(1, 2, 1),
				R15 = {
					LeftHand = -0.85,
					LeftLowerArm = -0.2,
					LeftUpperArm = 0.4
				}
			},
			rightArm = {
				Name = "Right Arm",
				Size = v3(1, 2, 1),
				R15 = {
					RightHand = -0.85,
					RightLowerArm = -0.2,
					RightUpperArm = 0.4
				}
			},
			leftLeg = {
				Name = "Left Leg",
				Size = v3(1, 2, 1),
				R15 = {
					LeftFoot = -0.85,
					LeftLowerLeg = -0.15,
					LeftUpperLeg = 0.6
				}
			},
			rightLeg = {
				Name = "Right Leg",
				Size = v3(1, 2, 1),
				R15 = {
					RightFoot = -0.85,
					RightLowerLeg = -0.15,
					RightUpperLeg = 0.6
				}
			}
		}
		for i, v in pairs(c:GetChildren()) do
			if v:IsA("BasePart") then
				for i1, v1 in pairs(v:GetChildren()) do
					if v1:IsA("Motor6D") then
						v1.Part0 = nil
					end
				end
			end
		end
		part.Archivable = true
		for i, v in pairs(R6parts) do
			local part = part:Clone()
			part:ClearAllChildren()
			part.Name = v.Name
			part.Size = v.Size
			part.CFrame = cfr
			part.Anchored = false
			part.Transparency = 1
			part.CanCollide = false
			for i1, v1 in pairs(v.R15) do
				local R15part = gp(c, i1, "BasePart")
				local att = gp(R15part, "att1_" .. i1, "Attachment")
				if R15part then
					local weld = Instance.new("Weld", R15part)
					weld.Name = "Weld_" .. i1
					weld.Part0 = part
					weld.Part1 = R15part
					weld.C0 = cf(0, v1, 0)
					weld.C1 = cf(0, 0, 0)
					R15part.Massless = true
					R15part.Name = "R15_" .. i1
					R15part.Parent = part
					if att then
						att.Parent = part
						att.Position = v3(0, v1, 0)
					end
				end
			end
			part.Parent = c
			R6parts[i] = part
		end
		local R6joints = {
			neck = {
				Parent = R6parts.torso,
				Name = "Neck",
				Part0 = R6parts.torso,
				Part1 = R6parts.head,
				C0 = cf(0, 1, 0, -1, 0, 0, 0, 0, 1, 0, 1, -0),
				C1 = cf(0, -0.5, 0, -1, 0, 0, 0, 0, 1, 0, 1, -0)
			},
			rootJoint = {
				Parent = R6parts.root,
				Name = "RootJoint" ,
				Part0 = R6parts.root,
				Part1 = R6parts.torso,
				C0 = cf(0, 0, 0, -1, 0, 0, 0, 0, 1, 0, 1, -0),
				C1 = cf(0, 0, 0, -1, 0, 0, 0, 0, 1, 0, 1, -0)
			},
			rightShoulder = {
				Parent = R6parts.torso,
				Name = "Right Shoulder",
				Part0 = R6parts.torso,
				Part1 = R6parts.rightArm,
				C0 = cf(1, 0.5, 0, 0, 0, 1, 0, 1, -0, -1, 0, 0),
				C1 = cf(-0.5, 0.5, 0, 0, 0, 1, 0, 1, -0, -1, 0, 0)
			},
			leftShoulder = {
				Parent = R6parts.torso,
				Name = "Left Shoulder",
				Part0 = R6parts.torso,
				Part1 = R6parts.leftArm,
				C0 = cf(-1, 0.5, 0, 0, 0, -1, 0, 1, 0, 1, 0, 0),
				C1 = cf(0.5, 0.5, 0, 0, 0, -1, 0, 1, 0, 1, 0, 0)
			},
			rightHip = {
				Parent = R6parts.torso,
				Name = "Right Hip",
				Part0 = R6parts.torso,
				Part1 = R6parts.rightLeg,
				C0 = cf(1, -1, 0, 0, 0, 1, 0, 1, -0, -1, 0, 0),
				C1 = cf(0.5, 1, 0, 0, 0, 1, 0, 1, -0, -1, 0, 0)
			},
			leftHip = {
				Parent = R6parts.torso,
				Name = "Left Hip" ,
				Part0 = R6parts.torso,
				Part1 = R6parts.leftLeg,
				C0 = cf(-1, -1, 0, 0, 0, -1, 0, 1, 0, 1, 0, 0),
				C1 = cf(-0.5, 1, 0, 0, 0, -1, 0, 1, 0, 1, 0, 0)
			}
		}
		for i, v in pairs(R6joints) do
			local joint = Instance.new("Motor6D")
			for prop, val in pairs(v) do
				joint[prop] = val
			end
			R6joints[i] = joint
		end
		hum1.RigType = Enum.HumanoidRigType.R6
		hum1.HipHeight = 0
	end
end



--find rig joints

local function fakemotor()
    return {C0=cf(), C1=cf()}
end

local torso = gp(c, "Torso", "BasePart")
local root = gp(c, "HumanoidRootPart", "BasePart")

local neck = gp(torso, "Neck", "Motor6D")
neck = neck or fakemotor()

local rootJoint = gp(root, "RootJoint", "Motor6D")
rootJoint = rootJoint or fakemotor()

local leftShoulder = gp(torso, "Left Shoulder", "Motor6D")
leftShoulder = leftShoulder or fakemotor()

local rightShoulder = gp(torso, "Right Shoulder", "Motor6D")
rightShoulder = rightShoulder or fakemotor()

local leftHip = gp(torso, "Left Hip", "Motor6D")
leftHip = leftHip or fakemotor()

local rightHip = gp(torso, "Right Hip", "Motor6D")
rightHip = rightHip or fakemotor()

--120 fps

local fps = 100
local event = Instance.new("BindableEvent", c)
event.Name = "120 fps"
local floor = math.floor
fps = 1 / fps
local tf = 0
local con = nil
con = game:GetService("RunService").RenderStepped:Connect(function(s)
	if not c then
		con:Disconnect()
		return
	end
	tf += s
	if tf >= fps then
		for i=1, floor(tf / fps) do
			event:Fire(c)
		end
		tf = 0
	end
end)
local event = event.Event

local hedrot = v3(0, 5, 0)

local uis = game:GetService("UserInputService")
local function isPressed(key)
    return (not uis:GetFocusedTextBox()) and uis:IsKeyDown(Enum.KeyCode[key])
end

local biggesthandle = nil
for i, v in pairs(c:GetChildren()) do
    if v:IsA("Accessory") then
        local handle = gp(v, "Handle", "BasePart")
        if biggesthandle then
            if biggesthandle.Size.Magnitude < handle.Size.Magnitude then
                biggesthandle = handle
            end
        else
            biggesthandle = gp(v, "Handle", "BasePart")
        end
    end
end

if not biggesthandle then
    return
end

local handle1 = gp(gp(model, biggesthandle.Parent.Name, "Accessory"), "Handle", "BasePart")
if not handle1 then
    return
end

handle1.Destroying:Connect(function()
    handle1 = nil
end)
biggesthandle.Destroying:Connect(function()
    biggesthandle = nil
end)

biggesthandle:BreakJoints()
biggesthandle.Anchored = true

for i, v in pairs(handle1:GetDescendants()) do
    if v:IsA("AlignOrientation") then
        v.Enabled = false
    end
end

--local mouse = lp:GetMouse()
--local fling = false
--mouse.Button1Down:Connect(function()
    --fling = true
--end)
--mouse.Button1Up:Connect(function()
    --fling = false
--end)
local function doForSignal(signal, vel)
    spawn(function()
        while signal:Wait() and c and handle1 and biggesthandle do
            if fling and mouse.Target then
                biggesthandle.Position = mouse.Hit.Position
            end
            handle1.RotVelocity = vel
        end
    end)
end
doForSignal(stepped, v3(100, 100, 100))
doForSignal(renderstepped, v3(100, 100, 100))
doForSignal(heartbeat, v3(2000000000000000000, 2000000000000000, 200000000000000))




local lp = game:GetService("Players").LocalPlayer
local rs = game:GetService("RunService")
local stepped = rs.Stepped
local heartbeat = rs.Heartbeat
local renderstepped = rs.RenderStepped
local sg = game:GetService("StarterGui")
local ws = game:GetService("Workspace")
local cf = CFrame.new
local v3 = Vector3.new
local v3_0 = Vector3.zero
local inf = math.huge

local cplayer = lp.Character

local v3 = Vector3.new

local function gp(parent, name, className)
    if typeof(parent) == "Instance" then
        for i, v in pairs(parent:GetChildren()) do
            if (v.Name == name) and v:IsA(className) then
                return v
            end
        end
    end
    return nil
end


local hat2 = gp(cplayer, "Pal Hair", "Accessory")
local handle2 = gp(hat2, "Handle", "BasePart")
local att2 = gp(handle2, "att1_Handle", "Attachment")
att2.Parent = cplayer["Right Arm"]
att2.Position = Vector3.new(0, -1.5, -0)
att2.Rotation = Vector3.new(0, 0, 0)





local lp = game:GetService("Players").LocalPlayer
local rs = game:GetService("RunService")
local stepped = rs.Stepped
local heartbeat = rs.Heartbeat
local renderstepped = rs.RenderStepped
local sg = game:GetService("StarterGui")
local ws = game:GetService("Workspace")
local cf = CFrame.new
local v3 = Vector3.new
local v3_0 = Vector3.zero
local inf = math.huge

local cplayer = lp.Character

local v3 = Vector3.new

local function gp(parent, name, className)
    if typeof(parent) == "Instance" then
        for i, v in pairs(parent:GetChildren()) do
            if (v.Name == name) and v:IsA(className) then
                return v
            end
        end
    end
    return nil
end


local hat2 = gp(cplayer, "Hat1", "Accessory")
local handle2 = gp(hat2, "Handle", "BasePart")
local att2 = gp(handle2, "att1_Handle", "Attachment")
att2.Parent = cplayer["Right Arm"]
att2.Position = Vector3.new(0, -1.5, -2)
att2.Rotation = Vector3.new(0, 0, 0)



local lp = game:GetService("Players").LocalPlayer
local rs = game:GetService("RunService")
local stepped = rs.Stepped
local heartbeat = rs.Heartbeat
local renderstepped = rs.RenderStepped
local sg = game:GetService("StarterGui")
local ws = game:GetService("Workspace")
local cf = CFrame.new
local v3 = Vector3.new
local v3_0 = Vector3.zero
local inf = math.huge

local cplayer = lp.Character

local v3 = Vector3.new

local function gp(parent, name, className)
    if typeof(parent) == "Instance" then
        for i, v in pairs(parent:GetChildren()) do
            if (v.Name == name) and v:IsA(className) then
                return v
            end
        end
    end
    return nil
end


local hat2 = gp(cplayer, "Kate Hair", "Accessory")
local handle2 = gp(hat2, "Handle", "BasePart")
local att2 = gp(handle2, "att1_Handle", "Attachment")
att2.Parent = cplayer["Right Arm"]
att2.Position = Vector3.new(0, -1.5, -4)
att2.Rotation = Vector3.new(0, 0, 0)



local lp = game:GetService("Players").LocalPlayer
local rs = game:GetService("RunService")
local stepped = rs.Stepped
local heartbeat = rs.Heartbeat
local renderstepped = rs.RenderStepped
local sg = game:GetService("StarterGui")
local ws = game:GetService("Workspace")
local cf = CFrame.new
local v3 = Vector3.new
local v3_0 = Vector3.zero
local inf = math.huge

local cplayer = lp.Character

local v3 = Vector3.new

local function gp(parent, name, className)
    if typeof(parent) == "Instance" then
        for i, v in pairs(parent:GetChildren()) do
            if (v.Name == name) and v:IsA(className) then
                return v
            end
        end
    end
    return nil
end


local hat2 = gp(cplayer, "VANS_Umbrella", "Accessory")
local handle2 = gp(hat2, "Handle", "BasePart")
local att2 = gp(handle2, "att1_Handle", "Attachment")
att2.Parent = cplayer["Right Arm"]
att2.Position = Vector3.new(0, -1.5, -7)
att2.Rotation = Vector3.new(0, 0, 0)


local lp = game:GetService("Players").LocalPlayer
local rs = game:GetService("RunService")
local stepped = rs.Stepped
local heartbeat = rs.Heartbeat
local renderstepped = rs.RenderStepped
local sg = game:GetService("StarterGui")
local ws = game:GetService("Workspace")
local cf = CFrame.new
local v3 = Vector3.new
local v3_0 = Vector3.zero
local inf = math.huge

local cplayer = lp.Character

local v3 = Vector3.new

local function gp(parent, name, className)
    if typeof(parent) == "Instance" then
        for i, v in pairs(parent:GetChildren()) do
            if (v.Name == name) and v:IsA(className) then
                return v
            end
        end
    end
    return nil
end


local hat2 = gp(cplayer, "Pink Hair", "Accessory")
local handle2 = gp(hat2, "Handle", "BasePart")
local att2 = gp(handle2, "att1_Handle", "Attachment")
att2.Parent = cplayer["Torso"]
att2.Position = Vector3.new(0.5, -0, -0)
att2.Rotation = Vector3.new(90, 0, 0)



local lp = game:GetService("Players").LocalPlayer
local rs = game:GetService("RunService")
local stepped = rs.Stepped
local heartbeat = rs.Heartbeat
local renderstepped = rs.RenderStepped
local sg = game:GetService("StarterGui")
local ws = game:GetService("Workspace")
local cf = CFrame.new
local v3 = Vector3.new
local v3_0 = Vector3.zero
local inf = math.huge

local cplayer = lp.Character

local v3 = Vector3.new

local function gp(parent, name, className)
    if typeof(parent) == "Instance" then
        for i, v in pairs(parent:GetChildren()) do
            if (v.Name == name) and v:IsA(className) then
                return v
            end
        end
    end
    return nil
end


local hat2 = gp(cplayer, "LavanderHair", "Accessory")
local handle2 = gp(hat2, "Handle", "BasePart")
local att2 = gp(handle2, "att1_Handle", "Attachment")
att2.Parent = cplayer["Torso"]
att2.Position = Vector3.new(-0.5, -0, -0)
att2.Rotation = Vector3.new(90, 0, 0)




-----------------------
--[[ Name : God ]]--
-------------------------------------------------------
--A script By makhail07

--Discord Creterisk#2958 


local FavIDs = {
	340106355, --Nefl Crystals
	927529620, --Dimension
	876981900, --Fantasy
	398987889, --Ordinary Days
	1117396305, --Oh wait, it's you.
	885996042, --Action Winter Journey
	919231299, --Sprawling Idiot Effigy
	743466274, --Good Day Sunshine
	727411183, --Knife Fight
	1402748531, --The Earth Is Counting On You!
	595230126 --Robot Language
	}



--The reality of my life isn't real but a Universe -makhail07
wait()
--SS CONVERT BY MELON
local plr = game:service'Players'.LocalPlayer
print('Local User is '..plr.Name)
print('God Loaded')
print('hahahAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA')
local char = plr.Character
local hum = char.Humanoid
local hed = char.Head
local root = char.HumanoidRootPart
local rootj = root.RootJoint
local tors = char.Torso
local ra = char["Right Arm"]
local la = char["Left Arm"]
local rl = char["Right Leg"]
local ll = char["Left Leg"]
local neck = tors["Neck"]
local mouse = plr:GetMouse()
local RootCF = CFrame.fromEulerAnglesXYZ(-1.57, 0, 3.14)
local RHCF = CFrame.fromEulerAnglesXYZ(0, 1.6, 0)
local LHCF = CFrame.fromEulerAnglesXYZ(0, -1.6, 0)
local maincolor = BrickColor.new("Institutional white")


-------------------------------------------------------
--Start Good Stuff--
-------------------------------------------------------
cam = game.Workspace.CurrentCamera
CF = CFrame.new
angles = CFrame.Angles
attack = false
Euler = CFrame.fromEulerAnglesXYZ
Rad = math.rad
IT = Instance.new
BrickC = BrickColor.new
Cos = math.cos
Acos = math.acos
Sin = math.sin
Asin = math.asin
Abs = math.abs
Mrandom = math.random
Floor = math.floor
-------------------------------------------------------
--End Good Stuff--
-------------------------------------------------------
necko = CF(0, 1, 0, -1, -0, -0, 0, 0, 1, 0, 1, 0)
RSH, LSH = nil, nil 
RW = Instance.new("Weld") 
LW = Instance.new("Weld")
RH = tors["Right Hip"]
LH = tors["Left Hip"]
RSH = tors["Right Shoulder"] 
LSH = tors["Left Shoulder"] 
RSH.Parent = nil 
LSH.Parent = nil 
RW.Name = "RW"
RW.Part0 = tors 
RW.C0 = CF(1.5, 0.5, 0)
RW.C1 = CF(0, 0.5, 0) 
RW.Part1 = ra
RW.Parent = tors 
LW.Name = "LW"
LW.Part0 = tors 
LW.C0 = CF(-1.5, 0.5, 0)
LW.C1 = CF(0, 0.5, 0) 
LW.Part1 = la
LW.Parent = tors
Effects = {}
-------------------------------------------------------
--Start HeartBeat--
-------------------------------------------------------
ArtificialHB = Instance.new("BindableEvent", script)
ArtificialHB.Name = "Heartbeat"
script:WaitForChild("Heartbeat")

frame = 1 / 60
tf = 0
allowframeloss = false
tossremainder = false


lastframe = tick()
script.Heartbeat:Fire()


game:GetService("RunService").Heartbeat:connect(function(s, p)
	tf = tf + s
	if tf >= frame then
		if allowframeloss then
			script.Heartbeat:Fire()
			lastframe = tick()
		else
			for i = 1, math.floor(tf / frame) do
				script.Heartbeat:Fire()
			end
			lastframe = tick()
		end
		if tossremainder then
			tf = 0
		else
			tf = tf - frame * math.floor(tf / frame)
		end
	end
end)
-------------------------------------------------------
--End HeartBeat--
-------------------------------------------------------

-------------------------------------------------------
--Start Important Functions--
-------------------------------------------------------
function swait(num)
	if num == 0 or num == nil then
		game:service("RunService").Stepped:wait(0)
	else
		for i = 0, num do
			game:service("RunService").Stepped:wait(0)
		end
	end
end
function thread(f)
	coroutine.resume(coroutine.create(f))
end
function clerp(a, b, t)
	local qa = {
		QuaternionFromCFrame(a)
	}
	local qb = {
		QuaternionFromCFrame(b)
	}
	local ax, ay, az = a.x, a.y, a.z
	local bx, by, bz = b.x, b.y, b.z
	local _t = 1 - t
	return QuaternionToCFrame(_t * ax + t * bx, _t * ay + t * by, _t * az + t * bz, QuaternionSlerp(qa, qb, t))
end
function QuaternionFromCFrame(cf)
	local mx, my, mz, m00, m01, m02, m10, m11, m12, m20, m21, m22 = cf:components()
	local trace = m00 + m11 + m22
	if trace > 0 then
		local s = math.sqrt(1 + trace)
		local recip = 0.5 / s
		return (m21 - m12) * recip, (m02 - m20) * recip, (m10 - m01) * recip, s * 0.5
	else
		local i = 0
		if m00 < m11 then
			i = 1
		end
		if m22 > (i == 0 and m00 or m11) then
			i = 2
		end
		if i == 0 then
			local s = math.sqrt(m00 - m11 - m22 + 1)
			local recip = 0.5 / s
			return 0.5 * s, (m10 + m01) * recip, (m20 + m02) * recip, (m21 - m12) * recip
		elseif i == 1 then
			local s = math.sqrt(m11 - m22 - m00 + 1)
			local recip = 0.5 / s
			return (m01 + m10) * recip, 0.5 * s, (m21 + m12) * recip, (m02 - m20) * recip
		elseif i == 2 then
			local s = math.sqrt(m22 - m00 - m11 + 1)
			local recip = 0.5 / s
			return (m02 + m20) * recip, (m12 + m21) * recip, 0.5 * s, (m10 - m01) * recip
		end
	end
end
function QuaternionToCFrame(px, py, pz, x, y, z, w)
	local xs, ys, zs = x + x, y + y, z + z
	local wx, wy, wz = w * xs, w * ys, w * zs
	local xx = x * xs
	local xy = x * ys
	local xz = x * zs
	local yy = y * ys
	local yz = y * zs
	local zz = z * zs
	return CFrame.new(px, py, pz, 1 - (yy + zz), xy - wz, xz + wy, xy + wz, 1 - (xx + zz), yz - wx, xz - wy, yz + wx, 1 - (xx + yy))
end
function QuaternionSlerp(a, b, t)
	local cosTheta = a[1] * b[1] + a[2] * b[2] + a[3] * b[3] + a[4] * b[4]
	local startInterp, finishInterp
	if cosTheta >= 1.0E-4 then
		if 1 - cosTheta > 1.0E-4 then
			local theta = math.acos(cosTheta)
			local invSinTheta = 1 / Sin(theta)
			startInterp = Sin((1 - t) * theta) * invSinTheta
			finishInterp = Sin(t * theta) * invSinTheta
		else
			startInterp = 1 - t
			finishInterp = t
		end
	elseif 1 + cosTheta > 1.0E-4 then
		local theta = math.acos(-cosTheta)
		local invSinTheta = 1 / Sin(theta)
		startInterp = Sin((t - 1) * theta) * invSinTheta
		finishInterp = Sin(t * theta) * invSinTheta
	else
		startInterp = t - 1
		finishInterp = t
	end
	return a[1] * startInterp + b[1] * finishInterp, a[2] * startInterp + b[2] * finishInterp, a[3] * startInterp + b[3] * finishInterp, a[4] * startInterp + b[4] * finishInterp
end
function rayCast(Position, Direction, Range, Ignore)
	return game:service("Workspace"):FindPartOnRay(Ray.new(Position, Direction.unit * (Range or 999.999)), Ignore)
end

-------------------------------------------------------
--Start Damage Function Customization--
-------------------------------------------------------
function ShowDamage(Pos, Text, Time, Color)
	local Rate = (1 / 30)
	local Pos = (Pos or Vector3.new(0, 0, 0))
	local Text = (Text or "")
	local Time = (Time or 2)
	local Color = (Color or Color3.new(1, 0, 1))
	local EffectPart = CFuncs.Part.Create(workspace, "SmoothPlastic", 0, 1, BrickColor.new(Color), "Effect", Vector3.new(0, 0, 0))
	EffectPart.Anchored = true
	local BillboardGui = Create("BillboardGui"){
		Size = UDim2.new(3, 0, 3, 0),
		Adornee = EffectPart,
		Parent = EffectPart,
	}
	local TextLabel = Create("TextLabel"){
		BackgroundTransparency = 1,
		Size = UDim2.new(1, 0, 1, 0),
		Text = Text,
		Font = "Bodoni",
		TextColor3 = Color,
		TextScaled = true,
		TextStrokeColor3 = Color3.fromRGB(0,0,0),
		Parent = BillboardGui,
	}
	game.Debris:AddItem(EffectPart, (Time))
	EffectPart.Parent = game:GetService("Workspace")
	delay(0, function()
		local Frames = (Time / Rate)
		for Frame = 1, Frames do
			wait(Rate)
			local Percent = (Frame / Frames)
			EffectPart.CFrame = CFrame.new(Pos) + Vector3.new(0, Percent, 0)
			TextLabel.TextTransparency = Percent
		end
		if EffectPart and EffectPart.Parent then
			EffectPart:Destroy()
		end
	end)
end
-------------------------------------------------------
--End Damage Function Customization--
-------------------------------------------------------

function MagniDamage(Part, magni, mindam, maxdam, knock, Type)
  for _, c in pairs(workspace:children()) do
    local hum = c:findFirstChild("Humanoid")
    if hum ~= nil then
      local head = c:findFirstChild("Head")
      if head ~= nil then
        local targ = head.Position - Part.Position
        local mag = targ.magnitude
        if magni >= mag and c.Name ~= plr.Name then
          Damage(head, head, mindam, maxdam, knock, Type, root, 0.1, "http://www.roblox.com/asset/?id=0", 1.2)
        end
      end
    end
  end
end


CFuncs = {
	Part = {
		Create = function(Parent, Material, Reflectance, Transparency, BColor, Name, Size)
			local Part = Create("Part")({
				Parent = Parent,
				Reflectance = Reflectance,
				Transparency = Transparency,
				CanCollide = false,
				Locked = true,
				BrickColor = BrickColor.new(tostring(BColor)),
				Name = Name,
				Size = Size,
				Material = Material
			})
			RemoveOutlines(Part)
			return Part
		end
	},
	Mesh = {
		Create = function(Mesh, Part, MeshType, MeshId, OffSet, Scale)
			local Msh = Create(Mesh)({
				Parent = Part,
				Offset = OffSet,
				Scale = Scale
			})
			if Mesh == "SpecialMesh" then
				Msh.MeshType = MeshType
				Msh.MeshId = MeshId
			end
			return Msh
		end
	},
	Mesh = {
		Create = function(Mesh, Part, MeshType, MeshId, OffSet, Scale)
			local Msh = Create(Mesh)({
				Parent = Part,
				Offset = OffSet,
				Scale = Scale
			})
			if Mesh == "SpecialMesh" then
				Msh.MeshType = MeshType
				Msh.MeshId = MeshId
			end
			return Msh
		end
	},
	Weld = {
		Create = function(Parent, Part0, Part1, C0, C1)
			local Weld = Create("Weld")({
				Parent = Parent,
				Part0 = Part0,
				Part1 = Part1,
				C0 = C0,
				C1 = C1
			})
			return Weld
		end
	},
	Sound = {
		Create = function(id, par, vol, pit)
			coroutine.resume(coroutine.create(function()
				local S = Create("Sound")({
					Volume = vol,
					Pitch = pit or 1,
					SoundId = id,
					Parent = par or workspace
				})
				wait()
				S:play()
				game:GetService("Debris"):AddItem(S, 6)
			end))
		end
	},
	ParticleEmitter = {
		Create = function(Parent, Color1, Color2, LightEmission, Size, Texture, Transparency, ZOffset, Accel, Drag, LockedToPart, VelocityInheritance, EmissionDirection, Enabled, LifeTime, Rate, Rotation, RotSpeed, Speed, VelocitySpread)
			local fp = Create("ParticleEmitter")({
				Parent = Parent,
				Color = ColorSequence.new(Color1, Color2),
				LightEmission = LightEmission,
				Size = Size,
				Texture = Texture,
				Transparency = Transparency,
				ZOffset = ZOffset,
				Acceleration = Accel,
				Drag = Drag,
				LockedToPart = LockedToPart,
				VelocityInheritance = VelocityInheritance,
				EmissionDirection = EmissionDirection,
				Enabled = Enabled,
				Lifetime = LifeTime,
				Rate = Rate,
				Rotation = Rotation,
				RotSpeed = RotSpeed,
				Speed = Speed,
				VelocitySpread = VelocitySpread
			})
			return fp
		end
	}
}
function RemoveOutlines(part)
	part.TopSurface, part.BottomSurface, part.LeftSurface, part.RightSurface, part.FrontSurface, part.BackSurface = 10, 10, 10, 10, 10, 10
end
function CreatePart(FormFactor, Parent, Material, Reflectance, Transparency, BColor, Name, Size)
	local Part = Create("Part")({
		formFactor = FormFactor,
		Parent = Parent,
		Reflectance = Reflectance,
		Transparency = Transparency,
		CanCollide = false,
		Locked = true,
		BrickColor = BrickColor.new(tostring(BColor)),
		Name = Name,
		Size = Size,
		Material = Material
	})
	RemoveOutlines(Part)
	return Part
end
function CreateMesh(Mesh, Part, MeshType, MeshId, OffSet, Scale)
	local Msh = Create(Mesh)({
		Parent = Part,
		Offset = OffSet,
		Scale = Scale
	})
	if Mesh == "SpecialMesh" then
		Msh.MeshType = MeshType
		Msh.MeshId = MeshId
	end
	return Msh
end
function CreateWeld(Parent, Part0, Part1, C0, C1)
	local Weld = Create("Weld")({
		Parent = Parent,
		Part0 = Part0,
		Part1 = Part1,
		C0 = C0,
		C1 = C1
	})
	return Weld
end


-------------------------------------------------------
--Start Effect Function--
-------------------------------------------------------
EffectModel = Instance.new("Model", char)
Effects = {
  Block = {
    Create = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay, Type)
      local prt = CFuncs.Part.Create(EffectModel, "SmoothPlastic", 0, 0, brickcolor, "Effect", Vector3.new())
      prt.Anchored = true
      prt.CFrame = cframe
      local msh = CFuncs.Mesh.Create("BlockMesh", prt, "", "", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
      game:GetService("Debris"):AddItem(prt, 10)
      if Type == 1 or Type == nil then
        table.insert(Effects, {
          prt,
          "Block1",
          delay,
          x3,
          y3,
          z3,
          msh
        })
      elseif Type == 2 then
        table.insert(Effects, {
          prt,
          "Block2",
          delay,
          x3,
          y3,
          z3,
          msh
        })
      else
        table.insert(Effects, {
          prt,
          "Block3",
          delay,
          x3,
          y3,
          z3,
          msh
        })
      end
    end
  },
  Sphere = {
    Create = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
      local prt = CFuncs.Part.Create(EffectModel, "Neon", 0, 0, brickcolor, "Effect", Vector3.new())
      prt.Anchored = true
      prt.CFrame = cframe
      local msh = CFuncs.Mesh.Create("SpecialMesh", prt, "Sphere", "", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
      game:GetService("Debris"):AddItem(prt, 10)
      table.insert(Effects, {
        prt,
        "Cylinder",
        delay,
        x3,
        y3,
        z3,
        msh
      })
    end
  },
  Cylinder = {
    Create = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
      local prt = CFuncs.Part.Create(EffectModel, "SmoothPlastic", 0, 0, brickcolor, "Effect", Vector3.new())
      prt.Anchored = true
      prt.CFrame = cframe
      local msh = CFuncs.Mesh.Create("CylinderMesh", prt, "", "", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
      game:GetService("Debris"):AddItem(prt, 10)
      table.insert(Effects, {
        prt,
        "Cylinder",
        delay,
        x3,
        y3,
        z3,
        msh
      })
    end
  },
  Wave = {
    Create = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
      local prt = CFuncs.Part.Create(EffectModel, "Neon", 0, 0, brickcolor, "Effect", Vector3.new())
      prt.Anchored = true
      prt.CFrame = cframe
      local msh = CFuncs.Mesh.Create("SpecialMesh", prt, "FileMesh", "rbxassetid://20329976", Vector3.new(0, 0, 0), Vector3.new(x1 / 60, y1 / 60, z1 / 60))
      game:GetService("Debris"):AddItem(prt, 10)
      table.insert(Effects, {
        prt,
        "Cylinder",
        delay,
        x3 / 60,
        y3 / 60,
        z3 / 60,
        msh
      })
    end
  },
  Ring = {
    Create = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
      local prt = CFuncs.Part.Create(EffectModel, "SmoothPlastic", 0, 0, brickcolor, "Effect", Vector3.new())
      prt.Anchored = true
      prt.CFrame = cframe
      local msh = CFuncs.Mesh.Create("SpecialMesh", prt, "FileMesh", "rbxassetid://3270017", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
      game:GetService("Debris"):AddItem(prt, 10)
      table.insert(Effects, {
        prt,
        "Cylinder",
        delay,
        x3,
        y3,
        z3,
        msh
      })
    end
  },
  Break = {
    Create = function(brickcolor, cframe, x1, y1, z1)
      local prt = CFuncs.Part.Create(EffectModel, "Neon", 0, 0, brickcolor, "Effect", Vector3.new(0.5, 0.5, 0.5))
      prt.Anchored = true
      prt.CFrame = cframe * CFrame.fromEulerAnglesXYZ(math.random(-50, 50), math.random(-50, 50), math.random(-50, 50))
      local msh = CFuncs.Mesh.Create("SpecialMesh", prt, "Sphere", "", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
      local num = math.random(10, 50) / 1000
      game:GetService("Debris"):AddItem(prt, 10)
      table.insert(Effects, {
        prt,
        "Shatter",
        num,
        prt.CFrame,
        math.random() - math.random(),
        0,
        math.random(50, 100) / 100
      })
    end
  },
Spiral = {
    Create = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
      local prt = CFuncs.Part.Create(EffectModel, "SmoothPlastic", 0, 0, brickcolor, "Effect", Vector3.new())
      prt.Anchored = true
      prt.CFrame = cframe
      local msh = CFuncs.Mesh.Create("SpecialMesh", prt, "FileMesh", "rbxassetid://1051557", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
      game:GetService("Debris"):AddItem(prt, 10)
      table.insert(Effects, {
        prt,
        "Cylinder",
        delay,
        x3,
        y3,
        z3,
        msh
      })
    end
  },
Push = {
    Create = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
      local prt = CFuncs.Part.Create(EffectModel, "SmoothPlastic", 0, 0, brickcolor, "Effect", Vector3.new())
      prt.Anchored = true
      prt.CFrame = cframe
      local msh = CFuncs.Mesh.Create("SpecialMesh", prt, "FileMesh", "rbxassetid://437347603", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
      game:GetService("Debris"):AddItem(prt, 10)
      table.insert(Effects, {
        prt,
        "Cylinder",
        delay,
        x3,
        y3,
        z3,
        msh
      })
    end
  }
}
function part(formfactor ,parent, reflectance, transparency, brickcolor, name, size)
	local fp = IT("Part")
	fp.formFactor = formfactor 
	fp.Parent = parent
	fp.Reflectance = reflectance
	fp.Transparency = transparency
	fp.CanCollide = false 
	fp.Locked = true
	fp.BrickColor = brickcolor
	fp.Name = name
	fp.Size = size
	fp.Position = tors.Position 
	RemoveOutlines(fp)
	fp.Material = "SmoothPlastic"
	fp:BreakJoints()
	return fp 
end 
 
function mesh(Mesh,part,meshtype,meshid,offset,scale)
	local mesh = IT(Mesh) 
	mesh.Parent = part
	if Mesh == "SpecialMesh" then
		mesh.MeshType = meshtype
	if meshid ~= "nil" then
		mesh.MeshId = "http://www.roblox.com/asset/?id="..meshid
		end
	end
	mesh.Offset = offset
	mesh.Scale = scale
	return mesh
end

function Magic(bonuspeed, type, pos, scale, value, color, MType)
	local type = type
	local rng = Instance.new("Part", char)
	rng.Anchored = true
	rng.BrickColor = color
	rng.CanCollide = false
	rng.FormFactor = 3
	rng.Name = "Ring"
	rng.Material = "Neon"
	rng.Size = Vector3.new(1, 1, 1)
	rng.Transparency = 0
	rng.TopSurface = 0
	rng.BottomSurface = 0
	rng.CFrame = pos
	local rngm = Instance.new("SpecialMesh", rng)
	rngm.MeshType = MType
	rngm.Scale = scale
	local scaler2 = 1
	if type == "Add" then
		scaler2 = 1 * value
	elseif type == "Divide" then
		scaler2 = 1 / value
	end
	coroutine.resume(coroutine.create(function()
		for i = 0, 10 / bonuspeed, 0.1 do
			swait()
			if type == "Add" then
				scaler2 = scaler2 - 0.01 * value / bonuspeed
			elseif type == "Divide" then
				scaler2 = scaler2 - 0.01 / value * bonuspeed
			end
			rng.Transparency = rng.Transparency + 0.01 * bonuspeed
			rngm.Scale = rngm.Scale + Vector3.new(scaler2 * bonuspeed, scaler2 * bonuspeed, scaler2 * bonuspeed)
		end
		rng:Destroy()
	end))
end

function Eviscerate(dude)
	if dude.Name ~= char then
		local bgf = IT("BodyGyro", dude.Head)
		bgf.CFrame = bgf.CFrame * CFrame.fromEulerAnglesXYZ(Rad(-90), 0, 0)
		local val = IT("BoolValue", dude)
		val.Name = "IsHit"
		local ds = coroutine.wrap(function()
			dude:WaitForChild("Head"):BreakJoints()
			wait(0.5)
			target = nil
			coroutine.resume(coroutine.create(function()
				for i, v in pairs(dude:GetChildren()) do
					if v:IsA("Accessory") then
						v:Destroy()
					end
					if v:IsA("Humanoid") then
						v:Destroy()
					end
					if v:IsA("CharacterMesh") then
						v:Destroy()
					end
					if v:IsA("Model") then
						v:Destroy()
					end
					if v:IsA("Part") or v:IsA("MeshPart") then
						for x, o in pairs(v:GetChildren()) do
							if o:IsA("Decal") then
								o:Destroy()
							end
						end
						coroutine.resume(coroutine.create(function()
							v.Material = "Neon"
							v.CanCollide = false
							local PartEmmit1 = IT("ParticleEmitter", v)
							PartEmmit1.LightEmission = 1
							PartEmmit1.Texture = "rbxassetid://284205403"
							PartEmmit1.Color = ColorSequence.new(maincolor.Color)
							PartEmmit1.Rate = 150
							PartEmmit1.Lifetime = NumberRange.new(1)
							PartEmmit1.Size = NumberSequence.new({
								NumberSequenceKeypoint.new(0, 0.75, 0),
								NumberSequenceKeypoint.new(1, 0, 0)
							})
							PartEmmit1.Transparency = NumberSequence.new({
								NumberSequenceKeypoint.new(0, 0, 0),
								NumberSequenceKeypoint.new(1, 1, 0)
							})
							PartEmmit1.Speed = NumberRange.new(0, 0)
							PartEmmit1.VelocitySpread = 30000
							PartEmmit1.Rotation = NumberRange.new(-500, 500)
							PartEmmit1.RotSpeed = NumberRange.new(-500, 500)
							local BodPoss = IT("BodyPosition", v)
							BodPoss.P = 3000
							BodPoss.D = 1000
							BodPoss.maxForce = Vector3.new(50000000000, 50000000000, 50000000000)
							BodPoss.position = v.Position + Vector3.new(Mrandom(-15, 15), Mrandom(-15, 15), Mrandom(-15, 15))
							v.Color = maincolor.Color
							coroutine.resume(coroutine.create(function()
								for i = 0, 49 do
									swait(1)
									v.Transparency = v.Transparency + 0.08
								end
								wait(0.5)
								PartEmmit1.Enabled = false
								wait(3)
								v:Destroy()
								dude:Destroy()
							end))
						end))
					end
				end
			end))
		end)
		ds()
	end
end

function FindNearestHead(Position, Distance, SinglePlayer)
	if SinglePlayer then
		return Distance > (SinglePlayer.Torso.CFrame.p - Position).magnitude
	end
	local List = {}
	for i, v in pairs(workspace:GetChildren()) do
		if v:IsA("Model") and v:findFirstChild("Head") and v ~= char and Distance >= (v.Head.Position - Position).magnitude then
			table.insert(List, v)
		end
	end
	return List
end

function Aura(bonuspeed, FastSpeed, type, pos, x1, y1, z1, value, color, outerpos, MType)
	local type = type
	local rng = Instance.new("Part", char)
	rng.Anchored = true
	rng.BrickColor = color
	rng.CanCollide = false
	rng.FormFactor = 3
	rng.Name = "Ring"
	rng.Material = "Neon"
	rng.Size = Vector3.new(1, 1, 1)
	rng.Transparency = 0
	rng.TopSurface = 0
	rng.BottomSurface = 0
	rng.CFrame = pos
	rng.CFrame = rng.CFrame + rng.CFrame.lookVector * outerpos
	local rngm = Instance.new("SpecialMesh", rng)
	rngm.MeshType = MType
	rngm.Scale = Vector3.new(x1, y1, z1)
	local scaler2 = 1
	local speeder = FastSpeed
	if type == "Add" then
		scaler2 = 1 * value
	elseif type == "Divide" then
		scaler2 = 1 / value
	end
	coroutine.resume(coroutine.create(function()
		for i = 0, 10 / bonuspeed, 0.1 do
			swait()
			if type == "Add" then
				scaler2 = scaler2 - 0.01 * value / bonuspeed
			elseif type == "Divide" then
				scaler2 = scaler2 - 0.01 / value * bonuspeed
			end
			speeder = speeder - 0.01 * FastSpeed * bonuspeed
			rng.CFrame = rng.CFrame + rng.CFrame.lookVector * speeder * bonuspeed
			rng.Transparency = rng.Transparency + 0.01 * bonuspeed
			rngm.Scale = rngm.Scale + Vector3.new(scaler2 * bonuspeed, scaler2 * bonuspeed, 0)
		end
		rng:Destroy()
	end))
end

function SoulSteal(dude)
if dude.Name ~= char then
local bgf = IT("BodyGyro", dude.Head)
bgf.CFrame = bgf.CFrame * CFrame.fromEulerAnglesXYZ(Rad(-90), 0, 0)
local val = IT("BoolValue", dude)
val.Name = "IsHit"
local torso = (dude:FindFirstChild'Head' or dude:FindFirstChild'Torso' or dude:FindFirstChild'UpperTorso' or dude:FindFirstChild'LowerTorso' or dude:FindFirstChild'HumanoidRootPart')
local soulst = coroutine.wrap(function()
local soul = Instance.new("Part",dude)
soul.Size = Vector3.new(1,1,1)
soul.CanCollide = false
soul.Anchored = false
soul.Position = torso.Position
soul.Transparency = 1
local PartEmmit1 = IT("ParticleEmitter", soul)
PartEmmit1.LightEmission = 1
PartEmmit1.Texture = "rbxassetid://569507414"
PartEmmit1.Color = ColorSequence.new(maincolor.Color)
PartEmmit1.Rate = 250
PartEmmit1.Lifetime = NumberRange.new(1.6)
PartEmmit1.Size = NumberSequence.new({
	NumberSequenceKeypoint.new(0, 1, 0),
	NumberSequenceKeypoint.new(1, 0, 0)
})
PartEmmit1.Transparency = NumberSequence.new({
	NumberSequenceKeypoint.new(0, 0, 0),
	NumberSequenceKeypoint.new(1, 1, 0)
})
PartEmmit1.Speed = NumberRange.new(0, 0)
PartEmmit1.VelocitySpread = 30000
PartEmmit1.Rotation = NumberRange.new(-360, 360)
PartEmmit1.RotSpeed = NumberRange.new(-360, 360)
local BodPoss = IT("BodyPosition", soul)
BodPoss.P = 3000
BodPoss.D = 1000
BodPoss.maxForce = Vector3.new(50000000000, 50000000000, 50000000000)
BodPoss.position = torso.Position + Vector3.new(Mrandom(-15, 15), Mrandom(-15, 15), Mrandom(-15, 15))
wait(1.6)
soul.Touched:connect(function(hit)
	if hit.Parent == char then
	soul:Destroy()
	end
end)
wait(1.2)
while soul do
	swait()
	PartEmmit1.Color = ColorSequence.new(maincolor.Color)
	BodPoss.Position = tors.Position
end
end)
	soulst()
	end
end
function FaceMouse()
local	Cam = workspace.CurrentCamera
	return {
		CFrame.new(char.Torso.Position, Vector3.new(mouse.Hit.p.x, char.Torso.Position.y, mouse.Hit.p.z)),
		Vector3.new(mouse.Hit.p.x, mouse.Hit.p.y, mouse.Hit.p.z)
	}
end
-------------------------------------------------------
--End Effect Function--
-------------------------------------------------------
function Cso(ID, PARENT, VOLUME, PITCH)
	local NSound = nil
	coroutine.resume(coroutine.create(function()
		NSound = IT("Sound", PARENT)
		NSound.Volume = VOLUME
		NSound.Pitch = PITCH
		NSound.SoundId = "http://www.roblox.com/asset/?id="..ID
		swait()
		NSound:play()
		game:GetService("Debris"):AddItem(NSound, 10)
	end))
	return NSound
end
function CameraEnshaking(Length, Intensity)
	coroutine.resume(coroutine.create(function()
		local intensity = 1 * Intensity
		local rotM = 0.01 * Intensity
		for i = 0, Length, 0.1 do
			swait()
			intensity = intensity - 0.05 * Intensity / Length
			rotM = rotM - 5.0E-4 * Intensity / Length
			hum.CameraOffset = Vector3.new(Rad(Mrandom(-intensity, intensity)), Rad(Mrandom(-intensity, intensity)), Rad(Mrandom(-intensity, intensity)))
			cam.CFrame = cam.CFrame * CF(Rad(Mrandom(-intensity, intensity)), Rad(Mrandom(-intensity, intensity)), Rad(Mrandom(-intensity, intensity))) * Euler(Rad(Mrandom(-intensity, intensity)) * rotM, Rad(Mrandom(-intensity, intensity)) * rotM, Rad(Mrandom(-intensity, intensity)) * rotM)
		end
		hum.CameraOffset = Vector3.new(0, 0, 0)
	end))
end
function chatfunc(text, color)
	local chat = coroutine.wrap(function()
		if char:FindFirstChild("TalkingBillBoard") ~= nil then
			char:FindFirstChild("TalkingBillBoard"):destroy()
		end
		local naeeym2 = Instance.new("BillboardGui", char)
		naeeym2.Size = UDim2.new(0, 100, 0, 40)
		naeeym2.StudsOffset = Vector3.new(0, 5, 0)
		naeeym2.Adornee = hed
		naeeym2.Name = "TalkingBillBoard"
		local tecks2 = Instance.new("TextLabel", naeeym2)
		tecks2.BackgroundTransparency = 1
		tecks2.BorderSizePixel = 0
		tecks2.Text = ""
		tecks2.Font = "SciFi"
		tecks2.TextSize = 30
		tecks2.TextStrokeTransparency = 0
		tecks2.TextColor3 = color
		tecks2.TextStrokeColor3 = Color3.new(0, 0, 0)
		tecks2.Size = UDim2.new(1, 0, 0.5, 0)
		coroutine.resume(coroutine.create(function()
			while true do
				swait(1)
				tecks2.Position = UDim2.new(0, math.random(-5, 5), 0, math.random(-5, 5))
				tecks2.Rotation = math.random(-5, 5)
			end
		end))
		for i = 1, string.len(text) do
			CFuncs.Sound.Create("rbxassetid://274118116", hed, 5.25, 0.115)
			tecks2.Text = string.sub(text, 1, i)
			swait(1)
		end
		wait(1)
		naeeym2:Destroy()
	end)
	chat()
end
-------------------------------------------------------
--End Important Functions--
-------------------------------------------------------


-------------------------------------------------------
--Start Customization--
-------------------------------------------------------
local Player_Size = 1
if Player_Size ~= 1 then
root.Size = root.Size * Player_Size
tors.Size = tors.Size * Player_Size
hed.Size = hed.Size * Player_Size
ra.Size = ra.Size * Player_Size
la.Size = la.Size * Player_Size
rl.Size = rl.Size * Player_Size
ll.Size = ll.Size * Player_Size
----------------------------------------------------------------------------------
rootj.Parent = root
neck.Parent = tors
RW.Parent = tors
LW.Parent = tors
RH.Parent = tors
LH.Parent = tors
----------------------------------------------------------------------------------
rootj.C0 = RootCF * CF(0 * Player_Size, 0 * Player_Size, 0 * Player_Size) * angles(Rad(0), Rad(0), Rad(0))
rootj.C1 = RootCF * CF(0 * Player_Size, 0 * Player_Size, 0 * Player_Size) * angles(Rad(0), Rad(0), Rad(0))
neck.C0 = necko * CF(0 * Player_Size, 0 * Player_Size, 0 + ((1 * Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0))
neck.C1 = CF(0 * Player_Size, -0.5 * Player_Size, 0 * Player_Size) * angles(Rad(-90), Rad(0), Rad(180))
RW.C0 = CF(1.5 * Player_Size, 0.5 * Player_Size, 0 * Player_Size) * angles(Rad(0), Rad(0), Rad(0)) --* RIGHTSHOULDERC0
LW.C0 = CF(-1.5 * Player_Size, 0.5 * Player_Size, 0 * Player_Size) * angles(Rad(0), Rad(0), Rad(0)) --* LEFTSHOULDERC0
----------------------------------------------------------------------------------
RH.C0 = CF(1 * Player_Size, -1 * Player_Size, 0 * Player_Size) * angles(Rad(0), Rad(90), Rad(0)) * angles(Rad(0), Rad(0), Rad(0))
LH.C0 = CF(-1 * Player_Size, -1 * Player_Size, 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(0)) * angles(Rad(0), Rad(0), Rad(0))
RH.C1 = CF(0.5 * Player_Size, 1 * Player_Size, 0 * Player_Size) * angles(Rad(0), Rad(90), Rad(0)) * angles(Rad(0), Rad(0), Rad(0))
LH.C1 = CF(-0.5 * Player_Size, 1 * Player_Size, 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(0)) * angles(Rad(0), Rad(0), Rad(0))
--hat.Parent = Character
end
----------------------------------------------------------------------------------
local SONG = 703597239
local SONG2 = 853707984
local Music = Instance.new("Sound",tors)
Music.Volume = 2.5
Music.Looped = true
Music.Pitch = 1 --Pitcher
----------------------------------------------------------------------------------
local equipped = false
local idle = 0
local change = 1
local val = 0
local toim = 0
local idleanim = 0.4
local sine = 0
local Sit = 1
----------------------------------------------------------------------------------
hum.WalkSpeed = 16
hum.JumpPower = 57
hum.Animator.Parent = nil
----------------------------------------------------------------------------------
local Blobby = Instance.new("Part", char)
Blobby.Name = "Blob"
Blobby.CanCollide = false
Blobby.BrickColor = BrickColor.new("Really black")
Blobby.Transparency = 0
Blobby.Material = "Plastic"
Blobby.Size = Vector3.new(1, 1, 2)
Blobby.TopSurface = Enum.SurfaceType.Smooth
Blobby.BottomSurface = Enum.SurfaceType.Smooth

local Weld = Instance.new("Weld", Blobby)
Weld.Part0 = ra
Weld.Part1 = Blobby
Weld.C1 = CFrame.new(0, -2, 1.1)
Weld.C0 = CFrame.Angles(Rad(-86),0,0)

local M2 = Instance.new("SpecialMesh")
M2.Parent = Blobby
M2.MeshId = "http://www.roblox.com/asset/?id=10604848"
M2.TextureId = "http://www.roblox.com/asset/?id=10605252"
M2.Scale = Vector3.new(1, 1, 1)

--[[local naeeym2 = Instance.new("BillboardGui",char)
naeeym2.AlwaysOnTop = true
naeeym2.Size = UDim2.new(5,35,2,15)
naeeym2.StudsOffset = Vector3.new(0, 3.5, 0)
naeeym2.Adornee = hed
naeeym2.Name = "Name"
--naeeym2.PlayerToHideFrom = Player
local tecks2 = Instance.new("TextLabel",naeeym2)
tecks2.BackgroundTransparency = 1
tecks2.TextScaled = true
tecks2.BorderSizePixel = 0
tecks2.Text = "Fight Me"
tecks2.Font = Enum.Font.Bodoni
tecks2.TextSize = 30
tecks2.TextStrokeTransparency = 0
tecks2.TextColor3 = Color3.new(0, 0, 0)
tecks2.TextStrokeColor3 = Color3.new(1, 1, 1)
tecks2.Size = UDim2.new(1,0,0.5,0)
tecks2.Parent = naeeym2]]
-------------------------------------------------------
--End Customization--
-------------------------------------------------------


-------------------------------------------------------
--Start Attacks N Stuff--
-------------------------------------------------------
function Ban()
	attack = true
	for i = 0, 2.6, 0.1 do
		swait()
		rootj.C0 = clerp(rootj.C0, RootCF * CF(0* Player_Size, 0* Player_Size, -0.1 + 0.1* Player_Size * Cos(sine / 20)) * angles(Rad(0), Rad(0), Rad(-60)), 0.2)
		tors.Neck.C0 = clerp(tors.Neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(-7.5 * Sin(sine / 30)), Rad(0), Rad(60)), 0.2)
		RH.C0 = clerp(RH.C0, CF(1* Player_Size, -0.9* Player_Size - 0.1 * Cos(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(84), Rad(0)) * angles(Rad(-6.5), Rad(0), Rad(0)), 0.2)
		LH.C0 = clerp(LH.C0, CF(-1* Player_Size, -0.9* Player_Size - 0.1 * Cos(sine / 20)* Player_Size, -.6* Player_Size) * angles(Rad(0), Rad(-84), Rad(0)) * angles(Rad(-6.5), Rad(0), Rad(20)), 0.2)
		RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.5 + 0.02 * Sin(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(160), Rad(-.6), Rad(13)), 0.2)
		LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.5 + 0.02 * Sin(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(15), Rad(-6), Rad(-25 - 4.5 * Sin(sine / 20))), 0.2)
	end
	Cso("147722910", tors, 10, 1)
	CameraEnshaking(2, 15)

	for i = 0, 3, 0.1 do
		swait()
		rootj.C0 = clerp(rootj.C0, RootCF * CF(0* Player_Size, 0* Player_Size, -0.1 + 0.1* Player_Size * Cos(sine / 20)) * angles(Rad(0), Rad(0), Rad(-15)), 0.3)
		tors.Neck.C0 = clerp(tors.Neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(25 - 7.5 * Sin(sine / 30)), Rad(0), Rad(15)), 0.3)
		RH.C0 = clerp(RH.C0, CF(1* Player_Size, -0.9* Player_Size - 0.1 * Cos(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(84), Rad(0)) * angles(Rad(-6.5), Rad(0), Rad(-20)), 0.3)
		LH.C0 = clerp(LH.C0, CF(-1* Player_Size, -0.9* Player_Size - 0.1 * Cos(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(-84), Rad(0)) * angles(Rad(-6.5), Rad(0), Rad(0)), 0.3)
		RW.C0 = clerp(RW.C0, CF(1* Player_Size, 0.3 + 0.02 * Sin(sine / 20)* Player_Size, -.6* Player_Size) * angles(Rad(5), Rad(-.6), Rad(-25)), 0.3)
		LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.5 + 0.02 * Sin(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(15), Rad(-6), Rad(-25 - 4.5 * Sin(sine / 20))), 0.3)
	end
	attack = false
end
function BigBan()
	attack = true
	Weld.C0 = CFrame.Angles(Rad(-90), Rad(-25), Rad(0))
	for i = 0, 3.6, 0.1 do
		swait()
		rootj.C0 = clerp(rootj.C0, RootCF * CF(0* Player_Size, 0* Player_Size, 1 + 0.1* Player_Size * Cos(sine / 20)) * angles(Rad(-20), Rad(0), Rad(0)), 0.2)
		tors.Neck.C0 = clerp(tors.Neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(-45 - 7.5 * Sin(sine / 30)), Rad(0), Rad(0)), 0.2)
		RH.C0 = clerp(RH.C0, CF(1* Player_Size, -0.9* Player_Size - 0.1 * Cos(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(84), Rad(0)) * angles(Rad(-6.5), Rad(0), Rad(-45)), 0.2)
		LH.C0 = clerp(LH.C0, CF(-1* Player_Size, -0.9* Player_Size - 0.1 * Cos(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(-84), Rad(0)) * angles(Rad(-6.5), Rad(0), Rad(45)), 0.2)
		RW.C0 = clerp(RW.C0, CF(1* Player_Size, 0.5 + 0.02 * Sin(sine / 20)* Player_Size, -.6* Player_Size) * angles(Rad(-225), Rad(-.6), Rad(-45)), 0.2)
		LW.C0 = clerp(LW.C0, CF(-1* Player_Size, 0.5 + 0.02 * Sin(sine / 20)* Player_Size, -.6* Player_Size) * angles(Rad(-225), Rad(-6), Rad(45)), 0.2)
	end
	Cso("147722910", tors, 10, 1)
	CameraEnshaking(2, 15)
	Effects.Wave.Create(BrickColor.new("Really black"), tors.CFrame * CF(0, -6, 0) * angles(math.rad(0), math.rad(math.random(0, 180)), math.rad(0)), 550.5, 100.5, 550.5, 200, 20, 200, 0.05)
  	Effects.Wave.Create(BrickColor.new("Really black"), tors.CFrame * CF(0, -6, 0) * angles(math.rad(0), math.rad(math.random(0, 180)), math.rad(0)), 550.5, 100.5, 550.5, 200, 20, 200, 0.05)
  	Effects.Wave.Create(BrickColor.new("Really black"), tors.CFrame * CF(0, -6, 0) * angles(math.rad(0), math.rad(math.random(0, 180)), math.rad(0)), 550.5, 100.5, 550.5, 200, 20, 200, 0.05)
 	for i, v in pairs(FindNearestHead(Blobby.CFrame.p, 14.5)) do
		if v:FindFirstChild("Head") then
			Eviscerate(v)
		end
	end
	for i = 0, 2.6, 0.1 do
		swait()
		rootj.C0 = clerp(rootj.C0, RootCF * CF(0* Player_Size, 0* Player_Size, 1 + 0.1* Player_Size * Cos(sine / 20)) * angles(Rad(75), Rad(0), Rad(0)), 0.2)
		tors.Neck.C0 = clerp(tors.Neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(45 - 7.5 * Sin(sine / 30)), Rad(0), Rad(0)), 0.2)
		RH.C0 = clerp(RH.C0, CF(1* Player_Size, -0.9* Player_Size - 0.1 * Cos(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(84), Rad(0)) * angles(Rad(-6.5), Rad(0), Rad(-45)), 0.2)
		LH.C0 = clerp(LH.C0, CF(-1* Player_Size, -0.9* Player_Size - 0.1 * Cos(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(-84), Rad(0)) * angles(Rad(-6.5), Rad(0), Rad(45)), 0.2)
		RW.C0 = clerp(RW.C0, CF(1* Player_Size, 0.5 + 0.02 * Sin(sine / 20)* Player_Size, -.6* Player_Size) * angles(Rad(-325), Rad(-.6), Rad(-45)), 0.2)
		LW.C0 = clerp(LW.C0, CF(-1* Player_Size, 0.5 + 0.02 * Sin(sine / 20)* Player_Size, -.6* Player_Size) * angles(Rad(-325), Rad(-6), Rad(45)), 0.2)
	end
	Weld.C0 = CFrame.Angles(Rad(-86),0,0)
	attack = false
end
function BANN()
	attack = true
	M2.Scale = Vector3.new(2, 2, 2)
	for i = 0, 4.6, 0.1 do
		swait()
		rootj.C0 = clerp(rootj.C0, RootCF * CF(0* Player_Size, 0* Player_Size, 1 + 0.1* Player_Size * Cos(sine / 20)) * angles(Rad(0), Rad(0), Rad(-60)), 0.2)
		tors.Neck.C0 = clerp(tors.Neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(-7.5 * Sin(sine / 30)), Rad(0), Rad(60)), 0.2)
		RH.C0 = clerp(RH.C0, CF(1* Player_Size, -0.9* Player_Size - 0.1 * Cos(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(84), Rad(0)) * angles(Rad(-16.5), Rad(0), Rad(-20)), 0.2)
		LH.C0 = clerp(LH.C0, CF(-1* Player_Size, -0.9* Player_Size - 0.1 * Cos(sine / 20)* Player_Size, -.6* Player_Size) * angles(Rad(0), Rad(-84), Rad(0)) * angles(Rad(-16.5), Rad(0), Rad(20)), 0.2)
		RW.C0 = clerp(RW.C0, CF(.6* Player_Size, 0.5 + 0.02 * Sin(sine / 20)* Player_Size, -.4* Player_Size) * angles(Rad(160), Rad(-.6), Rad(13)), 0.2)
		LW.C0 = clerp(LW.C0, CF(-.8* Player_Size, 0.5 + 0.02 * Sin(sine / 20)* Player_Size, -.4* Player_Size) * angles(Rad(156), Rad(-.6), Rad(45)), 0.2)
	end
	Cso("147722910", char, 10, 1)
	CameraEnshaking(2, 35)
	Effects.Wave.Create(BrickColor.new("Really black"), tors.CFrame * CF(0, -5, 0) * angles(math.rad(0), math.rad(math.random(0, 180)), math.rad(0)), 550.5, 100.5, 550.5, 200, 20, 200, 0.05)
  	Effects.Wave.Create(BrickColor.new("Really black"), tors.CFrame * CF(0, -5, 0) * angles(math.rad(0), math.rad(math.random(0, 180)), math.rad(0)), 550.5, 100.5, 550.5, 200, 20, 200, 0.05)
  	Effects.Wave.Create(BrickColor.new("Really black"), tors.CFrame * CF(0, -5, 0) * angles(math.rad(0), math.rad(math.random(0, 180)), math.rad(0)), 550.5, 100.5, 550.5, 200, 20, 200, 0.05)
	Effects.Ring.Create(BrickColor.new("Really black"), root.CFrame * CF(0, -2, 0) * angles(math.rad(90), math.rad(0), math.rad(0)), 0.5, 0.5, 0.1, 2, 2, 0, 0.04)
  	Effects.Sphere.Create(BrickColor.new("Really black"), root.CFrame * CF(0, -2, 0), 10, 7, 10, 15, -0.1, 15, 0.04)
  	Effects.Sphere.Create(BrickColor.new("Really black"), root.CFrame * CF(0, -2, 0), 10, 6, 10, 15, -0.1, 15, 0.02)
  	Effects.Sphere.Create(BrickColor.new("Really black"), root.CFrame * CF(0, -2, 0), 10, 4, 10, 15, -0.1, 15, 0.01)
 	for i, v in pairs(FindNearestHead(Blobby.CFrame.p, 19.5)) do
		if v:FindFirstChild("Head") then
			Eviscerate(v)
		end
	end
	for i = 0, 3, 0.1 do
		swait()
		rootj.C0 = clerp(rootj.C0, RootCF * CF(0* Player_Size, 0* Player_Size, -0.1 + 0.1* Player_Size * Cos(sine / 20)) * angles(Rad(0), Rad(0), Rad(-15)), 0.3)
		tors.Neck.C0 = clerp(tors.Neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(25 - 7.5 * Sin(sine / 30)), Rad(0), Rad(15)), 0.3)
		RH.C0 = clerp(RH.C0, CF(1* Player_Size, -0.9* Player_Size - 0.1 * Cos(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(84), Rad(0)) * angles(Rad(-6.5), Rad(0), Rad(-20)), 0.3)
		LH.C0 = clerp(LH.C0, CF(-1* Player_Size, -0.9* Player_Size - 0.1 * Cos(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(-84), Rad(0)) * angles(Rad(-6.5), Rad(0), Rad(0)), 0.3)
		RW.C0 = clerp(RW.C0, CF(1* Player_Size, 0.3 + 0.02 * Sin(sine / 20)* Player_Size, -.6* Player_Size) * angles(Rad(5), Rad(-.6), Rad(-25)), 0.3)
		LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.5 + 0.02 * Sin(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(15), Rad(-6), Rad(-25 - 4.5 * Sin(sine / 20))), 0.3)
	end
	M2.Scale = Vector3.new(1, 1, 1)
	attack = false
end
-------------------------------------------------------
--End Attacks N Stuff--
-------------------------------------------------------
mouse.KeyDown:connect(function(key)
    if string.byte(key) == 48 then
        Swing = 2
        hum.WalkSpeed = 38.82
	end
end)
mouse.KeyUp:connect(function(key)
    if string.byte(key) == 48 then
        Swing = 1
        hum.WalkSpeed = 16
	end
end)
mouse.KeyDown:connect(function(key)
	if attack == false then
		if key == 'e' then
			BigBan()
		elseif key == 'r' then
			BANN()
		elseif key == 't' then
			Cso("1450018171", hed, 10, 1)
		end
	end
end)
mouse.Button1Down:connect(function(key)
	if attack == false then
		Ban()
	end
end)
 






-------------------------------------------------------
--Start Animations--
-------------------------------------------------------
while true do
	swait()
	sine = sine + change
	local torvel = (root.Velocity * Vector3.new(1, 0, 1)).magnitude
	local velderp = root.Velocity.y
	hitfloor, posfloor = rayCast(root.Position, CFrame.new(root.Position, root.Position - Vector3.new(0, 1, 0)).lookVector, 4* Player_Size, char)
	if equipped == true or equipped == false then
		if attack == false then
			idle = idle + 1
		else
			idle = 0
		end
		--Aura(5, 0.15, "Add", root.CFrame * CFrame.new(math.random(-5, 5), -10, math.random(-5, 5)) * CFrame.Angles(math.rad(90), 0, 0), 1.5, 1.5, 10, -0.015, maincolor, 0, "Sphere")
		if 1 < root.Velocity.y and hitfloor == nil then
			Anim = "Jump"
			if attack == false then
				rootj.C0 = clerp(rootj.C0, RootCF * CF(0* Player_Size, 0* Player_Size, -0.1 + 0.1 * Cos(sine / 20)* Player_Size) * angles(Rad(-16), Rad(0), Rad(0)), 0.15)
				neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(10 - 2.5 * Sin(sine / 30)), Rad(0), Rad(0)), 0.3)
				RH.C0 = clerp(RH.C0, CF(1* Player_Size, -.2 - 0.1 * Cos(sine / 20)* Player_Size, -.3* Player_Size) * RHCF * angles(Rad(-2.5), Rad(0), Rad(0)), 0.15)
				LH.C0 = clerp(LH.C0, CF(-1* Player_Size, -.9 - 0.1 * Cos(sine / 20), -.5* Player_Size) * LHCF * angles(Rad(-2.5), Rad(0), Rad(0)), 0.15)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.5 + 0.02 * Sin(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(25), Rad(-.6), Rad(13 + 4.5 * Sin(sine / 20))), 0.1)
				LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.5 + 0.02 * Sin(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(25), Rad(-.6), Rad(-13 - 4.5 * Sin(sine / 20))), 0.1)
			end
		elseif -1 > root.Velocity.y and hitfloor == nil then
			Anim = "Fall"
			if attack == false then
				rootj.C0 = clerp(rootj.C0, RootCF * CF(0* Player_Size, 0* Player_Size, -0.1 + 0.1 * Cos(sine / 20)* Player_Size) * angles(Rad(24), Rad(0), Rad(0)), 0.15)
				neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(10 - 2.5 * Sin(sine / 30)), Rad(0), Rad(0)), 0.3)
				RH.C0 = clerp(RH.C0, CF(1* Player_Size, -1 - 0.1 * Cos(sine / 20)* Player_Size, -.3* Player_Size) * RHCF * angles(Rad(-3.5), Rad(0), Rad(0)), 0.15)
				LH.C0 = clerp(LH.C0, CF(-1* Player_Size, -.8 - 0.1 * Cos(sine / 20)* Player_Size, -.3* Player_Size) * LHCF * angles(Rad(-3.5), Rad(0), Rad(0)), 0.15)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.5 + 0.02 * Sin(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(65), Rad(-.6), Rad(45 + 4.5 * Sin(sine / 20))), 0.1)
				LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.5 + 0.02 * Sin(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(55), Rad(-.6), Rad(-45 - 4.5 * Sin(sine / 20))), 0.1)
			end
		elseif torvel < 1 and hitfloor ~= nil then
			Anim = "Idle"
			change = 1
			if attack == false then
				rootj.C0 = clerp(rootj.C0, RootCF * CF(0* Player_Size, 0* Player_Size, -0.1 + 0.1* Player_Size * Cos(sine / 20)) * angles(Rad(0), Rad(0), Rad(0)), 0.15)
				tors.Neck.C0 = clerp(tors.Neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(-7.5 * Sin(sine / 30)), Rad(0), Rad(0)), 0.3)
				RH.C0 = clerp(RH.C0, CF(1* Player_Size, -0.9* Player_Size - 0.1 * Cos(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(84), Rad(0)) * angles(Rad(-6.5), Rad(0), Rad(0)), 0.15)
				LH.C0 = clerp(LH.C0, CF(-1* Player_Size, -0.9* Player_Size - 0.1 * Cos(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(-84), Rad(0)) * angles(Rad(-6.5), Rad(0), Rad(0)), 0.15)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.5 + 0.02 * Sin(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(190), Rad(-.6), Rad(13)), 0.1)
				LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.5 + 0.02 * Sin(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(15), Rad(-6), Rad(-25 - 4.5 * Sin(sine / 20))), 0.1)
			end
		elseif torvel > 2 and torvel < 25 and hitfloor ~= nil then
			Anim = "Walk"
			change = 1
			if attack == false then
				rootj.C0 = clerp(rootj.C0, RootCF * CF(0* Player_Size, 0* Player_Size, -0.175 + 0.025 * Cos(sine / 3.5) + -Sin(sine / 3.5) / 7* Player_Size) * angles(Rad(3 - 2.5 * Cos(sine / 3.5)), Rad(0) - root.RotVelocity.Y / 75, Rad(8 * Cos(sine / 7))), 0.15)
				tors.Neck.C0 = clerp(tors.Neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(6 - 6.5 * Sin(sine / 7)), Rad(0), Rad(0) - hed.RotVelocity.Y / 15), 0.3)
				RH.C0 = clerp(RH.C0, CF(1* Player_Size, -0.8* Player_Size - 0.5 * Cos(sine / 7) / 2* Player_Size, 0.6 * Cos(sine / 7) / 2* Player_Size)  * angles(Rad(-10 - 25 * Cos(sine / 7)) - rl.RotVelocity.Y / 75 + -Sin(sine / 7) / 2.5, Rad(90 - 10 * Cos(sine / 7)), Rad(0)) * angles(Rad(0 + 2 * Cos(sine / 7)), Rad(0), Rad(0)), 0.3)
         		LH.C0 = clerp(LH.C0, CF(-1* Player_Size, -0.8* Player_Size + 0.5 * Cos(sine / 7) / 2* Player_Size, -0.6 * Cos(sine / 7) / 2* Player_Size) * angles(Rad(-10 + 25 * Cos(sine / 7)) + ll.RotVelocity.Y / 75 + Sin(sine / 7) / 2.5, Rad(-90 - 10 * Cos(sine / 7)), Rad(0)) * angles(Rad(0 - 2 * Cos(sine / 7)), Rad(0), Rad(0)), 0.3)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.5 + 0.05 * Sin(sine / 7)* Player_Size, 0* Player_Size) * angles(Rad(190) , Rad(8 * Cos(sine / 7)), Rad(13) - ra.RotVelocity.Y / 75), 0.1)
				LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.5 + 0.05 * Sin(sine / 7)* Player_Size, 0* Player_Size) * angles(Rad(-37)  * Cos(sine / 7) , Rad(8 * Cos(sine / 7)) ,	Rad(-6) + la.RotVelocity.Y / 75), 0.1)
			end
		elseif torvel >= 25 and hitfloor ~= nil then
			Anim = "Sprint"
			change = 1.35
			if attack == false then
			rootj.C0 = clerp(rootj.C0, RootCF * CF(0* Player_Size, 0* Player_Size, -0.175 + 0.025 * Cos(sine / 3.5) + -Sin(sine / 3.5) / 7* Player_Size) * angles(Rad(26 - 4.5 * Cos(sine / 3.5)), Rad(0) - root.RotVelocity.Y / 75, Rad(15 * Cos(sine / 7))), 0.15)
			tors.Neck.C0 = clerp(tors.Neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(-45 - 2.5 * Sin(sine / 20)), Rad(0), Rad(0) - hed.RotVelocity.Y / 15), 0.3)
			RH.C0 = clerp(RH.C0, CF(1* Player_Size, -0.925* Player_Size - 0.5* Player_Size * Cos(sine / 7) / 2* Player_Size, 0.7 * Cos(sine / 7) / 2* Player_Size) * angles(Rad(-15 - 55 * Cos(sine / 7)) - rl.RotVelocity.Y / 75 + -Sin(sine / 7) / 2.5, Rad(90 - 0.1 * Cos(sine / 7)), Rad(0)) * angles(Rad(0 + 0.1 * Cos(sine / 7)), Rad(0), Rad(0)), 0.3)
         	LH.C0 = clerp(LH.C0, CF(-1* Player_Size, -0.925* Player_Size + 0.5* Player_Size * Cos(sine / 7) / 2* Player_Size, -0.7 * Cos(sine / 7) / 2* Player_Size) * angles(Rad(-15 + 55 * Cos(sine / 7)) + ll.RotVelocity.Y / 75 + Sin(sine / 7) / 2.5, Rad(-90 - 0.1 * Cos(sine / 7)), Rad(0)) * angles(Rad(0 - 0.1 * Cos(sine / 7)), Rad(0), Rad(0)), 0.3)
			RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.5 + 0.05 * Sin(sine / 30)* Player_Size, 0.34 * Cos(sine / 7* Player_Size)) * angles(Rad(215) , Rad(8 * Cos(sine / 7)), Rad(13) - ra.RotVelocity.Y / 75), 0.15)
			LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.5 + 0.05 * Sin(sine / 30)* Player_Size, -0.34 * Cos(sine / 7* Player_Size)) * angles(Rad(-75) , Rad(8 * Cos(sine / 7)) ,	Rad(-13) + la.RotVelocity.Y / 75), 0.15)
			end
		end
	end
	Music.SoundId = "rbxassetid://"..SONG
	Music.Looped = true
	Music.Pitch = 1
	Music.Volume = 1.5
	Music.Parent = tors
	Music:Resume()
	if 0 < #Effects then
		for e = 1, #Effects do
			if Effects[e] ~= nil then
				local Thing = Effects[e]
				if Thing ~= nil then
					local Part = Thing[1]
					local Mode = Thing[2]
					local Delay = Thing[3]
					local IncX = Thing[4]
					local IncY = Thing[5]
					local IncZ = Thing[6]
					if 1 >= Thing[1].Transparency then
						if Thing[2] == "Block1" then
							Thing[1].CFrame = Thing[1].CFrame * CFrame.fromEulerAnglesXYZ(math.random(-50, 50), math.random(-50, 50), math.random(-50, 50))
							local Mesh = Thing[1].Mesh
							Mesh.Scale = Mesh.Scale + Vector3.new(Thing[4], Thing[5], Thing[6])
							Thing[1].Transparency = Thing[1].Transparency + Thing[3]
						elseif Thing[2] == "Block2" then
							Thing[1].CFrame = Thing[1].CFrame + Vector3.new(0, 0, 0)
							local Mesh = Thing[7]
							Mesh.Scale = Mesh.Scale + Vector3.new(Thing[4], Thing[5], Thing[6])
							Thing[1].Transparency = Thing[1].Transparency + Thing[3]
						elseif Thing[2] == "Block3" then
							Thing[1].CFrame = Thing[1].CFrame * CFrame.fromEulerAnglesXYZ(math.random(-50, 50), math.random(-50, 50), math.random(-50, 50)) + Vector3.new(0, 0.15, 0)
							local Mesh = Thing[7]
							Mesh.Scale = Mesh.Scale + Vector3.new(Thing[4], Thing[5], Thing[6])
							Thing[1].Transparency = Thing[1].Transparency + Thing[3]
						elseif Thing[2] == "Cylinder" then
							local Mesh = Thing[1].Mesh
							Mesh.Scale = Mesh.Scale + Vector3.new(Thing[4], Thing[5], Thing[6])
							Thing[1].Transparency = Thing[1].Transparency + Thing[3]
						elseif Thing[2] == "Blood" then
							local Mesh = Thing[7]
							Thing[1].CFrame = Thing[1].CFrame * Vector3.new(0, 0.5, 0)
							Mesh.Scale = Mesh.Scale + Vector3.new(Thing[4], Thing[5], Thing[6])
							Thing[1].Transparency = Thing[1].Transparency + Thing[3]
						elseif Thing[2] == "Elec" then
							local Mesh = Thing[1].Mesh
							Mesh.Scale = Mesh.Scale + Vector3.new(Thing[7], Thing[8], Thing[9])
							Thing[1].Transparency = Thing[1].Transparency + Thing[3]
						elseif Thing[2] == "Disappear" then
							Thing[1].Transparency = Thing[1].Transparency + Thing[3]
						elseif Thing[2] == "Shatter" then
							Thing[1].Transparency = Thing[1].Transparency + Thing[3]
							Thing[4] = Thing[4] * CFrame.new(0, Thing[7], 0)
							Thing[1].CFrame = Thing[4] * CFrame.fromEulerAnglesXYZ(Thing[6], 0, 0)
							Thing[6] = Thing[6] + Thing[5]
						end
					else
						Part.Parent = nil
						table.remove(Effects, e)
					end
				end
			end
		end
	end
end
-------------------------------------------------------
--End Animations And Script--
-------------------------------------------------------
end)

local Tab = Window:NewTab("Script ServerSide")

local CSection = Tab:NewSection("Script ServerSide Here")

CSection:NewButton("Trolling Gui", "[????]", function()
    

local g = game
if not g:IsLoaded() then
	g.Loaded:Wait()
end

local plrs = g:GetService("Players")
local lp = plrs.LocalPlayer
local mouse = lp:GetMouse()
local ws = g:GetService("Workspace")
local cg = g:GetService("CoreGui")
local pg = lp:FindFirstChildOfClass("PlayerGui")
local rs = g:GetService("RunService")
local uis = g:GetService("UserInputService")
local stepped = rs.Stepped
local renderstepped = rs.RenderStepped
local heartbeat = rs.Heartbeat
local currentplayer = lp
local fenv = getfenv()
local shp = fenv.sethiddenproperty or fenv.set_hidden_property or fenv.sethiddenprop or fenv.set_hidden_prop
local ssr = fenv.setsimulationradius or fenv.setsimradius or fenv.set_simulation_radius
local v3 = Vector3.new
local v3_0 = v3(0, 0, 0)
local cf = CFrame.new
local flycf = false
local twait, tspawn, tdelay = task.wait, task.spawn, task.delay
local schar, mrandom = string.char, math.random
local tfind, tinsert, tremove = table.find, table.insert, table.remove
local instancenew = Instance.new

local function gp(parent, name, className)
    if typeof(parent) == "Instance" then
		for _, v in pairs(parent:GetChildren()) do
			if (v.Name == name) and v:IsA(className) then
				return v
			end
		end
	end
	return nil
end

local function randomstring(len)
    len = len or mrandom(8, 15)
    local ret = ""
    for i=1, len do
        if mrandom(1, 2) == 1 then
            ret = ret .. schar(mrandom(97, 122)):lower()
        else
            ret = ret .. schar(mrandom(97, 122)):upper()
        end
    end
    return ret
end

local guiname = g.PlaceId .. "_info"

local gui = nil
pcall(function()
	gui = gp(cg, guiname, "ScreenGui")
end)
gui = gui or gp(pg, guiname, "ScreenGui")
if gui then
	gui:Destroy()
end

renderstepped:Wait()

gui = instancenew("ScreenGui")
gui.Name = guiname
gui.ResetOnSpawn = false
gui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
gui.Enabled = false
gui.IgnoreGuiInset = true
pcall(function()
	gui.Parent = cg
end)
if gui.Parent ~= cg then
	gui.Parent = pg
end
gui:GetPropertyChangedSignal("Parent"):Connect(function()
	if not (gui and gui.Parent) then
		gui = false
	end
end)
local mainFrame = instancenew("Frame")
mainFrame.Name = randomstring()
mainFrame.Parent = gui
mainFrame.BackgroundColor3 = Color3.fromRGB(21, 21, 21)
mainFrame.BorderSizePixel = 0
mainFrame.Position = UDim2.new(0, 0, 1, -200)
mainFrame.Size = UDim2.new(1, 0, 0, 200)
local mf = instancenew("Frame")
mf.Name = randomstring()
mf.Parent = mainFrame
mf.BackgroundColor3 = mainFrame.BackgroundColor3
mf.BorderSizePixel = 0
mf.Position = UDim2.new(0, 0, 1, 0)
mf.Size = UDim2.new(1, 0, 1, 0)
local scriptName = instancenew("TextLabel")
scriptName.Name = randomstring()
scriptName.Parent = mainFrame
scriptName.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
scriptName.BackgroundTransparency = 1.000
scriptName.BorderSizePixel = 0
scriptName.Size = UDim2.new(1, 0, 0, 20)
scriptName.Font = Enum.Font.SourceSans
scriptName.Text = "Trolling Server Gui Made By Mr Scripter White"
scriptName.TextColor3 = Color3.fromRGB(181, 181, 181)
scriptName.TextSize = 20.000
scriptName.TextWrapped = true
local line = instancenew("Frame")
line.Name = randomstring()
line.Parent = scriptName
line.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
line.BackgroundTransparency = 0.700
line.BorderSizePixel = 0
line.Position = UDim2.new(0, 5, 1, 0)
line.Size = UDim2.new(1, -10, 0, 1)
local showhide = instancenew("TextButton")
showhide.Name = randomstring()
showhide.Parent = mainFrame
showhide.BackgroundColor3 = Color3.fromRGB(21, 21, 21)
showhide.BorderSizePixel = 0
showhide.Position = UDim2.new(0.5, -25, 0, -30)
showhide.Size = UDim2.new(0, 50, 0, 30)
showhide.Font = Enum.Font.SourceSans
showhide.Text = "\\/"
showhide.TextColor3 = Color3.fromRGB(235, 235, 235)
showhide.TextSize = 20.000
local scrollingFrame = instancenew("ScrollingFrame")
scrollingFrame.Name = randomstring()
scrollingFrame.Parent = mainFrame
scrollingFrame.Active = true
scrollingFrame.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
scrollingFrame.BackgroundTransparency = 1.000
scrollingFrame.BorderSizePixel = 0
scrollingFrame.ClipsDescendants = false
scrollingFrame.Position = UDim2.new(0, 5, 0, 30)
scrollingFrame.Size = UDim2.new(1, -10, 1, -35)
scrollingFrame.CanvasSize = UDim2.new(0, 0, 0, 0)
scrollingFrame.ScrollBarThickness = 10
scrollingFrame.AutomaticCanvasSize = Enum.AutomaticSize.X
local UIListLayout = instancenew("UIListLayout")
UIListLayout.Parent = scrollingFrame
UIListLayout.FillDirection = Enum.FillDirection.Horizontal
UIListLayout.SortOrder = Enum.SortOrder.LayoutOrder
UIListLayout.Padding = UDim.new(0, 10)

local sn = scriptName.Text
local function notify(msg)
	local msg1 = sn .. " - " .. msg
	scriptName.Text = msg1
	tdelay(3, function()
		if scriptName.Text == msg1 then
			scriptName.Text = sn
		end
	end)
end

if gui.Parent == pg then
	notify("gui in playerGui")
end

local ancprt = nil
local function weldtp(part, cfr)
	if not (part and part.Parent and part:IsA("BasePart") and (not part:IsGrounded())) then
		return nil
	end
	if not (ancprt and ancprt.Parent and ancprt:IsA("BasePart") and ancprt:IsGrounded() and ancprt:IsDescendantOf(ws)) then
		for i, v in pairs(ws:GetDescendants()) do
			if v and v.Parent and v:IsA("BasePart") and v:IsGrounded() then
				ancprt = v
				break
			end
		end
	end
	if not ancprt then
		ancprt = instancenew("Part", ws)
		ancprt.Anchored = true
		ancprt.Transparency = 1
		ancprt.CanCollide = false
		ancprt.Name = "weldtp part"
	end
	local weld = instancenew("Weld")
	weld.Name = randomstring()
	weld.Part0 = part
	weld.C0 = cfr:Inverse()
	weld.Part1 = ancprt
	weld.C1 = ancprt.CFrame:Inverse()
	weld.Parent = ws
	stepped:Wait()
	pcall(function()
		weld:Destroy()
	end)
end

local function respawnRequest()
	local ccfr = ws.CurrentCamera.CFrame
	local c = lp.Character
	lp.Character = nil
	lp.Character = c
	ws.CurrentCamera:GetPropertyChangedSignal("CFrame"):Wait()
	ws.CurrentCamera.CFrame = ccfr
end

local function removehats(c)
    c = c or lp.Character
    if not c then return end
    for i, v in pairs(c:GetChildren()) do
        if v:IsA("Accessory") then
            local handle = gp(v, "Handle", "BasePart")
            if handle then
                handle:Destroy()
                v:Destroy()
            end
        end
    end
end

local function makeFrame(parent, text, color)
	local frame = instancenew("Frame")
	frame.Name = randomstring()
	frame.Parent = parent
	frame.BackgroundColor3 = color
	frame.Size = UDim2.new(0, 300, 0, 145)
	frame.BorderSizePixel = 0
	local framelabel = instancenew("TextLabel")
	framelabel.Name = randomstring()
	framelabel.Parent = frame
	framelabel.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
	framelabel.BackgroundTransparency = 1.000
	framelabel.BorderSizePixel = 0
	framelabel.Size = UDim2.new(1, 0, 0, 20)
	framelabel.Font = Enum.Font.SourceSans
	framelabel.Text = text
	framelabel.TextColor3 = Color3.fromRGB(197, 197, 197)
	framelabel.TextSize = 14.000
	local line = instancenew("Frame")
	line.Name = randomstring()
	line.Parent = framelabel
	line.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
	line.BackgroundTransparency = 0.700
	line.BorderSizePixel = 0
	line.Position = UDim2.new(0, 5, 1, 0)
	line.Size = UDim2.new(1, -10, 0, 1)
	local ScrollingFrame = instancenew("ScrollingFrame")
	ScrollingFrame.Parent = frame
	ScrollingFrame.Active = true
	ScrollingFrame.Name = randomstring()
	ScrollingFrame.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
	ScrollingFrame.BackgroundTransparency = 1.000
	ScrollingFrame.BorderSizePixel = 0
	ScrollingFrame.Position = UDim2.new(0, 5, 0, 25)
	ScrollingFrame.Size = UDim2.new(1, -5, 1, -30)
	ScrollingFrame.CanvasSize = UDim2.new(0, 0, 0, 0)
	ScrollingFrame.ScrollBarThickness = 7
	ScrollingFrame.AutomaticCanvasSize = Enum.AutomaticSize.Y
	local UIListLayout = instancenew("UIListLayout")
	UIListLayout.Parent = ScrollingFrame
	UIListLayout.SortOrder = Enum.SortOrder.LayoutOrder
	UIListLayout.Padding = UDim.new(0, 5)
	renderstepped:Wait()
	return frame
end

showhide.MouseButton1Click:Connect(function()
	if showhide.Text == "/\\" then
		showhide.Text = "\\/"
		mainFrame:TweenPosition(UDim2.new(0, 0, 1, -200), "Out", "Elastic", 1)
	else
		showhide.Text = "/\\"
		mainFrame:TweenPosition(UDim2.new(0, 0, 1, -5), "Out", "Elastic", 1)
	end
end)

local cbring = {}
local controllable = {}
local lastc = nil
local con = nil
con = lp.CharacterAdded:Connect(function(c)
	if not gui then
		con:Disconnect()
		return
	end
	if lastc == c then
		return
	end
	if c and c.Parent then
		lastc = c
		controllable = {}
		for i, v in pairs(plrs:GetPlayers()) do
			local c = v.Character
			if c and c.Parent then
				tinsert(controllable, c)
			end
		end
	end
end)

local viewedPlayer = nil
local viewbutton = {Text = ""}

local playersframe = makeFrame(scrollingFrame, "Players", Color3.fromRGB(12, 59, 100))
local playercframe = makeFrame(playersframe, "playerscontrol", Color3.fromRGB(12, 59, 100))
playercframe.BorderSizePixel = 1.000
playercframe.BorderColor3 = Color3.fromRGB(27, 42, 53)
playercframe.Position = UDim2.new(0, 10, -1, -40)
playercframe.BackgroundColor3 = Color3.fromRGB(100, 100, 100)
playercframe.Visible = true
local playerframef = makeFrame(playercframe, "friends", Color3.fromRGB(0, 150, 0))
playerframef.Position = UDim2.new(1, 10, 0, 5)

local function addbtn(parent, plr)
	local playerbutton = instancenew("TextButton")
	playerbutton.Name = plr.Name
	playerbutton.Parent = parent
	if plr == lp then
		playerbutton.BackgroundColor3 = Color3.fromRGB(100, 200, 200)
	else
		playerbutton.BackgroundColor3 = Color3.fromRGB(136, 136, 136)
	end
	playerbutton.BorderSizePixel = 0
	playerbutton.Size = UDim2.new(1, -10, 0, 20)
	playerbutton.Font = Enum.Font.SourceSans
	playerbutton.Text = plr.Name
	if plr.Name ~= plr.DisplayName then
		playerbutton.Text = playerbutton.Text .. " (" .. plr.DisplayName .. ")"
	end
	playerbutton.TextColor3 = Color3.fromRGB(0, 0, 0)
	playerbutton.TextSize = 15.000
	playerbutton.MouseButton1Click:Connect(function()
		playercframe:FindFirstChildOfClass("TextLabel").Text = "player: " .. playerbutton.Text
		currentplayer = plr
		playercframe.Visible = true
		playerframef.Visible = false
		viewbutton.Text = ((viewedPlayer == plr) and "unview") or "view"
	end)
end

local function unview()
	viewedPlayer = nil
	viewbutton.Text = "view"
	local c = lp.Character
	if c and c.Parent then
		local subject = c:FindFirstChildOfClass("Humanoid") or c:FindFirstChildWhichIsA("BasePart")
		if subject then
			ws.CurrentCamera.CameraType = Enum.CameraType.Custom
			ws.CurrentCamera.CameraSubject = subject
		else
			notify("no part to view")
		end
	else
		notify("character not found")
	end
end

local playersScroll = playersframe:FindFirstChildOfClass("ScrollingFrame")

for i, v in pairs(plrs:GetPlayers()) do
	addbtn(playersScroll, v)
end
local reset = function() end
local con = nil
con = plrs.PlayerAdded:Connect(function(plr)
	if gui then
		addbtn(playersScroll, plr)
		if playerframef.Visible then
    	    tspawn(function()
        	    if plr and plr.Parent and currentplayer:IsFriendsWith(plr.UserId) then
        			addbtn(playerframef:FindFirstChildOfClass("ScrollingFrame"), plr)
        	    end
    	    end)
    	end
	else
		con:Disconnect()
	end
end)
local con = nil
con = plrs.PlayerRemoving:Connect(function(plr)
	if gui then
		local playerbutton = gp(playersScroll, plr.Name, "TextButton")
		if playerbutton then
			playerbutton:Destroy()
		end
		if plr == currentplayer then
			playercframe.Visible = false
		end
		if plr == viewedPlayer then
			unview()
		end
	else
		con:Disconnect()
	end
end)
local hideplayerc = instancenew("TextButton")
hideplayerc.Name = randomstring()
hideplayerc.Parent = playercframe:FindFirstChildOfClass("TextLabel")
hideplayerc.BackgroundColor3 = Color3.fromRGB(59, 59, 59)
hideplayerc.BorderSizePixel = 0
hideplayerc.Position = UDim2.new(1, -17, 0, 2)
hideplayerc.Size = UDim2.new(0, 15, 0, 15)
hideplayerc.Font = Enum.Font.SourceSans
hideplayerc.Text = "X"
hideplayerc.TextColor3 = Color3.fromRGB(206, 206, 206)
hideplayerc.TextSize = 14.000
hideplayerc.MouseButton1Click:Connect(function()
	playercframe.Visible = false
end)
local function makeplrbutton(buttontext)
	local button = instancenew("TextButton")
	button.Name = randomstring()
	button.Parent = playercframe:FindFirstChildOfClass("ScrollingFrame")
	button.BackgroundColor3 = Color3.fromRGB(53, 53, 53)
	button.BorderSizePixel = 0
	button.Size = UDim2.new(1, -10, 0, 20)
	button.Font = Enum.Font.SourceSans
	button.Text = buttontext
	button.TextColor3 = Color3.fromRGB(226, 226, 226)
	button.TextSize = 15.000
	return button
end
makeplrbutton("goto").MouseButton1Click:Connect(function()
	local c = lp.Character
	if c and c.Parent then
		local tp = gp(c, "HumanoidRootPart", "BasePart") or gp(c, "Head", "BasePart") or c:FindFirstChildWhichIsA("BasePart")
		if tp then
			local c1 = currentplayer.Character
			if c1 and c1.Parent then
				local to = gp(c1, "HumanoidRootPart", "BasePart") or gp(c1, "Head", "BasePart") or c1:FindFirstChildWhichIsA("BasePart")
				if to then
					if flycf then
						flycf = to.CFrame
					else
						weldtp(tp, to.CFrame)
						if viewedPlayer == currentplayer then
					        unview()
					    end
					end
					notify("goto: " .. currentplayer.Name)
				else
					notify("no target part found")
				end
			else
				notify("target character not found")
			end
		else
			notify("no part found")
		end
	else
		notify("character not found")
	end
end)
viewbutton = makeplrbutton("view")
viewbutton.MouseButton1Click:Connect(function()
	if viewedPlayer == currentplayer then
		unview()
	else
		viewedPlayer = currentplayer
		viewbutton.Text = "unview"
	end
end)

local cbringb = makeplrbutton("cbring")

local function noanimations()
	local c = lp.Character
	if c and c.Parent then
		local hum = c:FindFirstChildOfClass("Humanoid")
		if hum then
			local animate = gp(c, "Animate", "LocalScript")
			if animate then
				animate.Disabled = true
			end
			for i, v in pairs(hum:GetPlayingAnimationTracks()) do
				v:Stop()
			end
		else
			notify("humanoid not found")
		end
	else
		notify("character not found")
	end
end

local function isConnected(part0, part1, tested)
	if not ((typeof(part0) == "Instance") and part0:IsA("BasePart")) then
		return false
	end
	if not ((typeof(part1) == "Instance") and part1:IsA("BasePart")) then
		return false
	end
	if not tested then
		tested = {}
	end
	local ret = false
	tinsert(tested, part0)
	for i, v in pairs(part0:GetConnectedParts()) do
		if part1 == v then
			return true
		elseif not tfind(tested, v) then
			ret = ret or isConnected(v, part1, tested)
		end
	end
	return ret
end

local function attach(c1)
	local bck = lp:FindFirstChildOfClass("Backpack")
	local c = lp.Character
	--checks for: model, humanoid, arm, torso for main character:
	if not (c and c.Parent) then
		notify("character not found")
		return false
	end
	local hum = c:FindFirstChildOfClass("Humanoid")
	if not hum then
		notify("humanoid not found")
		return false
	end 
	local arm = gp(c, "Right Arm", "BasePart") or gp(c, "RightHand", "BasePart")
	if not arm then
		notify("arm not found")
		return false
	end
	local torso = gp(c, "Torso", "BasePart") or gp(c, "UpperTorso", "BasePart")
	if not torso then
		notify("torso not found")
		return
	end
	if torso:IsGrounded() then
		notify("torso is grounded")
		return
	end
	if not isConnected(arm, torso) then
		notify("arm and toso not connected")
		return
	end
	--checks for: tool:
	local tool, handle = nil, nil
	for i, v in pairs(c:GetChildren()) do
	    if v:IsA("Tool") then
	        handle = gp(v, "Handle", "BasePart") 
	        if handle then 
	            tool = v
	            break
	        end
	    end
	end
	if (not tool) and bck then 
        for i, v in pairs(bck:GetChildren()) do
    	    if v:IsA("Tool") then
    	        handle = gp(v, "Handle", "BasePart") 
    	        if handle then 
    	            tool = v
    	            break
    	        end
    	    end
        end
	end
	if not tool then
	    notify("no tools with handle found")
	    return false
	end
	--checks for: model, humanoid, arm, torso for target character:
	if not (c1 and c1.Parent) then
		notify("target character not found")
		return false
	end
	local hum1 = c1:FindFirstChildOfClass("Humanoid")
	if not hum1 then
		notify("target humanoid not found")
		return false
	end
	local arm1 = gp(c1, "Right Arm", "BasePart") or gp(c1, "RightHand", "BasePart")
	if not arm1 then
		notify("target arm not found")
		return false
	end
	local torso1 = gp(c1, "Torso", "BasePart") or gp(c1, "UpperTorso", "BasePart")
	if not torso1 then
		notify("target torso not found")
		return
	end
	if torso1:IsGrounded() then
		notify("target torso is grounded")
		return
	end
	if not isConnected(arm1, torso1) then
		notify("target arm and toso not connected")
		return
	end
	--all checks good
	if bck then
		for i, v in pairs(c:GetChildren()) do
			if v:IsA("Tool") then
				v.Parent = bck
			end
		end
	end
	removehats(c)
	local nhum = hum:Clone()
	hum:Destroy()
	hum = nhum
	hum.Parent = c
	hum:EquipTool(tool)
	for i, v in pairs(c1:GetDescendants()) do
		if v and v.Parent and v:IsA("BasePart") then
			v.Massless = true
		end
	end
	local attaching = true
	tspawn(function()
		while renderstepped:Wait() and attaching do
			--checks for: model, humanoid, arm, torso for main character:
			if not (c and c.Parent) then
				handle = nil
				tool.Parent = bck
				return notify("character removed")
			end
			if (not hum and hum.Parent) then
				handle = nil
				tool.Parent = bck
				return notify("humanoid removed")
			end
			if not (arm and arm.Parent) then
				handle = nil
				tool.Parent = bck
				return notify("arm removed")
			end
			if not (torso and torso.Parent) then
				handle = nil
				tool.Parent = bck
				return notify("torso removed")
			end
			if torso:IsGrounded() then
				handle = nil
				tool.Parent = bck
				return notify("torso got grounded")
			end
			if not isConnected(arm, torso) then
				handle = nil
				tool.Parent = bck
				return notify("arm and toso connection removed")
			end
			--checks for: model, humanoid, arm, torso for target character:
			if not (c1 and c1.Parent) then
				handle = nil
				tool.Parent = bck
				return notify("target character removed")
			end
			if not (hum1 and hum1.Parent) then
				handle = nil
				tool.Parent = bck
				return notify("target humanoid removed")
			end
			if not (arm1 and arm1.Parent) then
				handle = nil
				tool.Parent = bck
				return notify("target arm removed")
			end
			if not (torso1 and torso1.Parent) then
				handle = nil
				tool.Parent = bck
				return notify("target torso removed")
			end
			if torso:IsGrounded() then
				handle = nil
				tool.Parent = bck
				return notify("target torso got grounded")
			end
			if not isConnected(arm1, torso1) then
				handle = nil
				tool.Parent = bck
				return notify("target arm and toso connection removed")
			end
			--checks for: tool
			if not (tool and tool.Parent) then
				handle = nil
				tool.Parent = bck
				return notify("tool removed")
			end
			if not (handle and handle.Parent) then
				handle = nil
				tool.Parent = bck
				return notify("tool handle removed")
			end
			if (tool.Parent ~= c) and (tool.Parent ~= c1) and (tool.Parent ~= bck) then
				handle = nil
				tool.Parent = bck
				return notify("unexpected tool parent")
			end
			weldtp(arm1, handle.CFrame)
		end
	end)
	while tool do
		tool.AncestryChanged:Wait()
		attaching = false
		break
	end
	return handle
end

makeplrbutton("bring").MouseButton1Click:Connect(function()
	local plr = currentplayer
	local c1 = plr.Character
	if not (c1 and c1.Parent) then
		notify("target character not found")
		return
	end
	if not tfind(controllable, c1) then
		reset(true)
		twait(0.1)
	end
	if not (plr and plr.Parent) then
		notify("target player left")
		return
	end
	if not (c1 and c1.Parent) then
		c1 = plr.Character
	end
	if not (c1 and c1.Parent) then
		notify("target character not found")
		return
	end
	local c = lp.Character
	if not (c and c.Parent) then
		notify("character not found")
		return
	end
	local part = gp(c, "HumanoidRootPart", "BasePart") or gp(c, "Torso", "BasePart") or gp(c, "UpperTorso", "BasePart") or gp(c, "Head", "BasePart")
	if not part then
		notify("part not found")
		return
	end
	local cfr = part.CFrame
	local joint = attach(plr.Character)
	if not joint then
		return
	end
	weldtp(part, cfr)
	twait(0.5)
	if c and c.Parent and part and part.Parent and joint and joint.Parent then
		weldtp(part, cfr)
		if not (joint and joint.Parent) then
			notify("joint removed")
			reset(false)
			return
		end
		joint:BreakJoints()
		reset(false)
		if viewedPlayer == plr then
		    unview()
		end
		notify("brought " .. plr.Name)
	end
end)

local fekill = nil
fekill = function(c1)
	if not (c1 and c1.Parent) then
		return notify("target character not found")
	end
	local torso = gp(c1, "Torso", "BasePart") or gp(c1, "UpperTorso", "BasePart")
	if not torso then
		return notify("target torso not found")
	end
	local head = gp(c1, "Head", "BasePart")
	if not head then
		return notify("target head not found")
	end
	if not isConnected(torso, head) then
		return notify("torso and head not connected")
	end
	if not tfind(controllable, c1) then
		reset(true)
		twait(0.1)
	end
	if (plrs.RespawnTime < 15) and (plrs.RespawnTime > 1) then
		notify("preparing fast respawn")
		respawnRequest()
		twait(plrs.RespawnTime - 1)
	end
	if not (c1 and c1.Parent) then
		return notify("target character removed")
	end
	local c = lp.Character
	if not (c and c.Parent) then
		return notify("character not found")
	end
	local part = gp(c, "HumanoidRootPart", "BasePart") or gp(c, "Torso", "BasePart") or gp(c, "UpperTorso", "BasePart") or gp(c, "Head", "BasePart")
	if not part then
		return notify("part not found")
	end
	local hum = c1:FindFirstChildOfClass("Humanoid")
	if not hum then
		return notify("humanoid not found")
	end
	if not isConnected(torso, head) then
		return notify("torso and head joint removed")
	end
	local cfr = part.CFrame
	local part1 = gp(c1, "HumanoidRootPart", "BasePart") or gp(c1, "Torso", "BasePart") or gp(c1, "UpperTorso", "BasePart") or gp(c1, "Head", "BasePart")
	if part1 then
		weldtp(part, part1.CFrame)
	end
	if hum.Health > 0 then
		hum.BreakJointsOnDeath = false
	end
	stepped:Wait()
	local joint = attach(c1)
	if not joint then
		return weldtp(part, cfr)
	end
	stepped:Wait()
	hum:ChangeState(Enum.HumanoidStateType.Dead)
	twait(0.3)
	if joint then
		joint:BreakJoints()
	end
	weldtp(part, cfr)
	reset(false)
	notify("kill attempt failed")
	local t = tick() + 1
	local con = nil
	con = stepped:Connect(function()
		if tick() > t then
			return con:Disconnect()
		end
		if not isConnected(torso, head) then
			con:Disconnect()
			notify("killed succesfully")
		end
	end)
end

makeplrbutton("kill").MouseButton1Click:Connect(function()
	fekill(currentplayer.Character)
end)

makeplrbutton("attach").MouseButton1Click:Connect(function()
	return attach(currentplayer.Character) and notify("attached to " .. currentplayer.Name)
end)

makeplrbutton("view friends").MouseButton1Click:Connect(function()
	playerframef.Visible = not playerframef.Visible
	if not playerframef.Visible then
		return
	end
	playerframef:FindFirstChildOfClass("TextLabel").Text = "friends of: " .. currentplayer.Name
	local scroll = playerframef:FindFirstChildOfClass("ScrollingFrame")
	for i, v in pairs(scroll:GetChildren()) do
		if v and v.Parent and v:IsA("TextButton") then
			v:Destroy()
		end
	end
	for i, v in pairs(plrs:GetPlayers()) do
		tspawn(function()
			if v and v.Parent and currentplayer:IsFriendsWith(v.UserId) then
				addbtn(playerframef:FindFirstChildOfClass("ScrollingFrame"), v)
			end
		end)
	end
end)

local function makeflingbutton(partname)
	makeplrbutton("fling (" .. partname .. ")").MouseButton1Click:Connect(function()
		local c = lp.Character
		if c and c.Parent then
			local hrp = gp(c, partname, "BasePart")
			if hrp then
				local c1 = currentplayer.Character
				if c1 and c1.Parent then
					local hrp1 = gp(c1, partname, "BasePart")
					if hrp1 then						
						c:BreakJoints()
						hrp.CustomPhysicalProperties = PhysicalProperties.new(0.01, 0.01, 0.01, 0.01, 0.01)
						for i, v in pairs(c:GetChildren()) do
							if (v ~= hrp) and v and v.Parent and v:IsA("BasePart") then
								v:Destroy()
							end
						end
						hrp.Transparency = 0.5
						while heartbeat:Wait() and c and c.Parent and hrp and hrp.Parent and c1 and c1.Parent and hrp1 and hrp1.Parent do
							local pos = {x=0, y=0, z=0}
							pos.x = hrp1.Position.X
							pos.y = hrp1.Position.Y
							pos.z = hrp1.Position.Z
							pos.x += hrp1.Velocity.X / 2
							pos.y += hrp1.Velocity.Y / 2
							pos.z += hrp1.Velocity.Z / 2
							local heightlock = ws.FallenPartsDestroyHeight + 5
							if pos.y < heightlock then
								pos.y = heightlock
							end
							hrp.CanCollide = false
							hrp.Position = v3(pos.x, pos.y, pos.z)
							hrp.Velocity = v3(0, 1000, 0)
							hrp.RotVelocity = v3(10000, 10000, 10000)
							ws.CurrentCamera.CameraSubject = hrp1
						end
						twait(0.1)
						local c = lp.Character
						if (c and c.Parent) then
							ws.CurrentCamera.CameraSubject = c:FindFirstChildOfClass("Humanoid") or c:FindFirstChildWhichIsA("BasePart") or c
						end
					else
						notify("target part not found")
					end
				else
					notify("target character not found")
				end
			else
				notify("part not found")
			end
		else
			notify("character not found")
		end
	end)
end
makeflingbutton("Head")
makeflingbutton("HumanoidRootPart")
makeflingbutton("Torso")

local graphicsframe = makeFrame(scrollingFrame, "Graphics", Color3.fromRGB(84, 45, 162))
local function makegraphicsbutton(buttontext)
	local button = instancenew("TextButton")
	button.Name = randomstring()
	button.Parent = graphicsframe:FindFirstChildOfClass("ScrollingFrame")
	button.BackgroundColor3 = Color3.fromRGB(53, 53, 53)
	button.BorderSizePixel = 0
	button.Size = UDim2.new(1, -10, 0, 20)
	button.Font = Enum.Font.SourceSans
	button.Text = buttontext
	button.TextColor3 = Color3.fromRGB(226, 226, 226)
	button.TextSize = 15.000
	return button
end
local lig = g:GetService("Lighting")
makegraphicsbutton("remove fog").MouseButton1Click:Connect(function()
	lig.FogStart = 9e9
	lig.FogEnd = 9e9
end)
local function setupremove(button, classname)
	button.MouseButton1Click:Connect(function()
		for i, v in pairs(g:GetDescendants()) do
			if v:IsA(classname) then
				v:Destroy()
			end
		end
	end)
end
setupremove(makegraphicsbutton("remove atmosphere effects"), "Atmosphere")
setupremove(makegraphicsbutton("remove blur"), "BlurEffect")
setupremove(makegraphicsbutton("remove decals"), "Decal")
setupremove(makegraphicsbutton("default sky"), "Sky")
setupremove(makegraphicsbutton("remove sun rays"), "SunRaysEffect")
setupremove(makegraphicsbutton("remove particles"), "ParticleEmitter")
setupremove(makegraphicsbutton("remove color correction effects"), "ColorCorrectionEffect")

local cfly = nil
local fhrp = nil
local flyspeed = 60

local positionsframe = makeFrame(scrollingFrame, "Positions", Color3.fromRGB(162, 108, 42))
local addpositionbutton = instancenew("TextButton")
addpositionbutton.Name = randomstring()
addpositionbutton.Parent = positionsframe:FindFirstChildOfClass("TextLabel")
addpositionbutton.BackgroundColor3 = Color3.fromRGB(59, 59, 59)
addpositionbutton.BorderSizePixel = 0
addpositionbutton.Position = UDim2.new(1, -77, 0, 2)
addpositionbutton.Size = UDim2.new(0, 75, 1, -4)
addpositionbutton.Font = Enum.Font.SourceSans
addpositionbutton.Text = "+ add current"
addpositionbutton.TextColor3 = Color3.fromRGB(206, 206, 206)
addpositionbutton.TextSize = 14.000
addpositionbutton.MouseButton1Click:Connect(function()
	local c = lp.Character
	if c and c.Parent then
		local hrp = gp(c, "HumanoidRootPart", "BasePart") or gp(c, "Head", "BasePart") or c:FindFirstChildWhichIsA("BasePart")
		if hrp then
			local cfr = hrp.CFrame
			local positionframe = instancenew("Frame")
			local loadposbutton = instancenew("TextButton")
			local removeposbutton = instancenew("TextButton")
			local positionName = instancenew("TextBox")
			positionframe.Name = randomstring()
			positionframe.Parent = positionsframe:FindFirstChildOfClass("ScrollingFrame")
			positionframe.BackgroundColor3 = Color3.fromRGB(106, 106, 106)
			positionframe.BorderSizePixel = 0
			positionframe.Size = UDim2.new(1, -10, 0, 30)
			loadposbutton.Name = randomstring()
			loadposbutton.Parent = positionframe
			loadposbutton.BackgroundColor3 = Color3.fromRGB(47, 47, 47)
			loadposbutton.BorderSizePixel = 0
			loadposbutton.Position = UDim2.new(1, -70, 0, 5)
			loadposbutton.Size = UDim2.new(0, 40, 1, -10)
			loadposbutton.Font = Enum.Font.SourceSans
			loadposbutton.Text = "load"
			loadposbutton.TextColor3 = Color3.fromRGB(223, 223, 223)
			loadposbutton.TextSize = 16.000
			removeposbutton.Name = randomstring()
			removeposbutton.Parent = positionframe
			removeposbutton.BackgroundColor3 = Color3.fromRGB(47, 47, 47)
			removeposbutton.BorderSizePixel = 0
			removeposbutton.Position = UDim2.new(1, -25, 0, 5)
			removeposbutton.Size = UDim2.new(0, 20, 1, -10)
			removeposbutton.Font = Enum.Font.SourceSans
			removeposbutton.Text = "X"
			removeposbutton.TextColor3 = Color3.fromRGB(223, 223, 223)
			removeposbutton.TextSize = 16.000
			positionName.Name = randomstring()
			positionName.Parent = positionframe
			positionName.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
			positionName.BackgroundTransparency = 1.000
			positionName.BorderSizePixel = 0
			positionName.Position = UDim2.new(0, 5, 0, 5)
			positionName.Size = UDim2.new(1, -80, 1, -10)
			positionName.Font = Enum.Font.SourceSans
			positionName.Text = "Position1"
			positionName.ClearTextOnFocus = false
			positionName.TextColor3 = Color3.fromRGB(0, 0, 0)
			positionName.TextSize = 25.000
			positionName.TextXAlignment = Enum.TextXAlignment.Left
			loadposbutton.MouseButton1Click:Connect(function()
				c = lp.Character
				if c and c.Parent then
					hrp = gp(c, "HumanoidRootPart", "BasePart") or gp(c, "Head", "BasePart") or c:FindFirstChildWhichIsA("BasePart")
					if hrp then
						if flycf then
							flycf = cfr
						else
							weldtp(hrp, cfr)
						end
					else
						notify("part not found")
					end
				else
					notify("character not found")
				end
			end)
			removeposbutton.MouseButton1Click:Connect(function()
				positionframe:Destroy()
			end)
		end
	end
end)

local charframe = makeFrame(scrollingFrame, "Character", Color3.fromRGB(99, 15, 15))
local function makecharbutton(buttontext)
	local button = instancenew("TextButton")
	button.Name = randomstring()
	button.Parent = charframe:FindFirstChildOfClass("ScrollingFrame")
	button.BackgroundColor3 = Color3.fromRGB(53, 53, 53)
	button.BorderSizePixel = 0
	button.Size = UDim2.new(1, -10, 0, 20)
	button.Font = Enum.Font.SourceSans
	button.Text = buttontext
	button.TextColor3 = Color3.fromRGB(226, 226, 226)
	button.TextSize = 15.000
	return button
end
local loopr = false
local fakevoidp = nil
reset = function(respawn)
	if fakevoidp then
		fakevoidp = nil
		twait(0.3)
	end
	local c = lp.Character
	local partName, cfr, ccfr = nil, nil, nil
	if not (c and c.Parent) then
		respawnRequest()
		if not loopr then
			notify("character not found, trying to respawn")
		end
		return
	end
	local part = gp(c, "HumanoidRootPart", "BasePart") or gp(c, "Torso", "BasePart") or gp(c, "Head", "BasePart") or c:FindFirstChildWhichIsA("BasePart")
	if not part then
		respawnRequest()
		if not loopr then
			notify("no part found in the character, trying to respawn")
		end
		return
	end
	partName, cfr, ccfr = part.Name, part.CFrame, ws.CurrentCamera.CFrame
	tspawn(function()
		local c, part = c, nil
		while c and c.Parent do
			heartbeat:Wait()
		end
		while true do
			c = lp.Character
			if c and c.Parent then 
			    break
			end
			heartbeat:Wait()
		end
		while c and c.Parent do
			part = gp(c, partName, "BasePart")
			if part then 
			    break
			end
			heartbeat:Wait()
		end
		if not part then
			if not loopr then
				notify("failed to tp back")
			end
			return
		end
		weldtp(part, cfr)
		ws.CurrentCamera.CFrame = ccfr
		cfr = nil
		if not loopr then
			notify("respawned")
		end
	end)
	if respawn and (not loopr) then
		notify("respawning...")
	end
	if respawn then
		tspawn(function()
			while c and c.Parent do
				if part and part.Parent then
					cfr = part.CFrame
				end
				ccfr = ws.CurrentCamera.CFrame
				stepped:Wait()
			end
		end)
		if plrs.RespawnTime > 0.5 then
			for i=1, 3 do
			    twait(0.1)
			    if c and c.Parent then
				    respawnRequest()
				else
				    break 
				end
			end
			twait(plrs.RespawnTime - 0.5)
		else
			respawnRequest()
		end
		part = nil
	end
	if c and c.Parent then
		if respawn then
		    local hum = c:FindFirstChildOfClass("Humanoid")
		    if hum then
		        hum.BreakJointsOnDeath = false
		        hum:ChangeState(Enum.HumanoidStateType.Dead)
		        hum.Health = 0
		        hum:SetStateEnabled(Enum.HumanoidStateType.Dead, false)
    		end
    		tdelay(1, function()
    		    if c and c.Parent then
    		        c:BreakJoints()
    		        respawnRequest()
    		    end
    		end)
		else
		    c:BreakJoints()
		end
		while gui and cfr do
			stepped:Wait()
		end
	end
end
makecharbutton("respawn").MouseButton1Click:Connect(function()
	if not loopr then
		reset(true)
	end
end)
makecharbutton("reset").MouseButton1Click:Connect(function()
	reset(false)
end)
local looprb = makecharbutton("loop respawn")
tspawn(function()
	while wait() and gui do
		if loopr then
			reset(true)
		end
	end
end)
looprb.MouseButton1Click:Connect(function()
	loopr = not loopr
	looprb.Text = "loop respawn" .. ((loopr and " (Enabled)") or "")
end)
makecharbutton("remove meshes").MouseButton1Click:Connect(function()
	local c = lp.Character
	if c and c.Parent then
		for i, v in pairs(c:GetDescendants()) do
			if v and v.Parent and (v:IsA("Mesh") or v:IsA("SpecialMesh") or v:IsA("CharacterMesh")) then
				v:Destroy()
			end
		end
		notify("removed meshes")
	else
		notify("no character")
	end
end)
makecharbutton("break joints").MouseButton1Click:Connect(function()
	local c = lp.Character
	if c and c.Parent then
		c:BreakJoints()
		notify("broken joints")
	else
		notify("no character")
	end
end)
local noclipb = makecharbutton("noclip")
local noclip = false
noclipb.MouseButton1Click:Connect(function()
	noclip = not noclip
	noclipb.Text = "noclip" .. ((noclip and " (Enabled)") or "")
end)
local fakevoidb = makecharbutton("fake void")
fakevoidb.MouseButton1Click:Connect(function()
	if fakevoidp then
		fakevoidp = nil
		fakevoidb.Text = "fake void"
	else
		local c = lp.Character
		if not (c and c.Parent) then
			notify("character not found")
			return
		end
		local part = gp(c, "HumanoidRootPart", "BasePart") or gp(c, "Torso", "BasePart") or gp(c, "UpperTorso", "BasePart") or gp(c, "Head", "BasePart") or c:FindFirstChildWhichIsA("BasePart")
		if not part then
			notify("no part found")
			return
		end
		fakevoidp = part
		fakevoidb.Text = "fake void (Enabled)"
		notify("character teleported under FallenPartsDestroyHeight")

		local dh = ws.FallenPartsDestroyHeight
		local cfr = fakevoidp.CFrame
		local newcf = cf(0, dh - 100, 0)
		local camcf = ws.CurrentCamera.CFrame
		ws.CurrentCamera.CameraType = Enum.CameraType.Scriptable
		ws.FallenPartsDestroyHeight = dh - 200
		while stepped:Wait() and gui and c and c.Parent and fakevoidp and fakevoidp.Parent do
			weldtp(fakevoidp, newcf)
		end
		ws.FallenPartsDestroyHeight = dh
		fakevoidb.Text = "fake void"
		if c and c.Parent then
			unview()
			ws.CurrentCamera.CFrame = camcf
			if part and part.Parent then
				weldtp(part, cfr)
				notify("teleported back")
			else
				notify("part removed")
			end
		else
			notify("character removed")
		end
	end
end)
makecharbutton("block tool").MouseButton1Click:Connect(function()
	local c = lp.Character
	if c and c.Parent then
		local tool = c:FindFirstChildOfClass("Tool")
		if tool then
			local found = false
			for i, v in pairs(tool:GetDescendants()) do
				if v and v.Parent and v:IsA("Mesh") or v:IsA("SpecialMesh") then
					v:Destroy()
				end
			end
			if found then
				notify("removed tool meshes")
			else
				notify("no meshes found")
			end
		else
			notify("tool not found")
		end
	else
		notify("no character")
	end
end)
local infjumpb = makecharbutton("infjump")
local infjump = false
local con = nil
con = g:GetService("UserInputService").JumpRequest:Connect(function()
	if not gui then
		con:Disconnect()
		return
	end
	if infjump then
		local c = lp.Character
		if c and c.Parent then
			local hum = c:FindFirstChildOfClass("Humanoid")
			if hum then
				hum:ChangeState("Jumping")
			end
		end
	end
end)
infjumpb.MouseButton1Click:Connect(function()
	infjump = not infjump
	infjumpb.Text = "infjump" .. ((infjump and " (Enabled)") or "")
end)
makecharbutton("god (remove humanoid)").MouseButton1Click:Connect(function()
	local c = lp.Character
	if c and c.Parent then
		local hum = c:FindFirstChildOfClass("Humanoid")
		if hum then
			hum.Archivable = true
			local hum1 = hum:Clone()
			hum:Destroy()
			hum1.Parent = c
			notify("humanoid client sided")
		else
			notify("humanoid not found")
		end
	else
		notify("character not found")
	end
end)
local loopgb = makecharbutton("loop god mode")
local loopg = false
tspawn(function()
	while wait() and gui do
		if loopg then
			local c = lp.Character
			if c and c.Parent then
				local part = gp(c, "HumanoidRootPart", "BasePart") or gp(c, "Head", "BasePart") or c:FindFirstChildWhichIsA("BasePart")
				if part then
					local hum = c:FindFirstChildOfClass("Humanoid")
					if hum then
						local partName = part.Name
						local new = hum:Clone()
						hum:Destroy()
						new.Parent = c
						ws.CurrentCamera.CameraSubject = new
						local currentcfr = part.CFrame
						local camcfr = ws.CurrentCamera.CFrame
						while twait() and c and c.Parent and part and part.Parent do
							currentcfr = part.CFrame
							camcfr = ws.CurrentCamera.CFrame
							removehats(c)
							local ff = c:FindFirstChildOfClass("ForceField")
							if ff then
								ff:Destroy()
							end
						end
						part = nil
						while not (part and part.Parent) do
							twait()
							c = lp.Character
							part = gp(c, partName, "BasePart")
						end
						weldtp(part, currentcfr)
						ws.CurrentCamera.CFrame = camcfr
					end
				end
			end
		end
	end
end)
loopgb.MouseButton1Click:Connect(function()
	loopg = not loopg
	loopgb.Text = "loop god mode" .. ((loopg and " (Enabled)") or "")
end)
local flyb = makecharbutton("fly")
flyb.MouseButton1Click:Connect(function()
	if cfly and cfly.Parent then
		cfly = nil
	else
		cfly = lp.Character
		flyb.Text = "fly (Enabled)"
	end
end)

local ctrlf = {
	["w"] = false,
	["a"] = false,
	["s"] = false,
	["d"] = false
}
local con = nil
con = mouse.KeyDown:Connect(function(key)
	if not gui then
		con:Disconnect()
		return
	end
	key = key:lower()
	if ctrlf[key] ~= nil then
		ctrlf[key] = true
	end
end)
local con = nil
con = mouse.KeyUp:Connect(function(key)
	if not gui then
		con:Disconnect()
		return
	end
	key = key:lower()
	if ctrlf[key] ~= nil then
		ctrlf[key] = false
	end
end)
local con = nil
con = renderstepped:Connect(function(deltaTime)
	if not gui then
		con:Disconnect()
		return
	end
	if not flycf then
		return
	end
	local fb = ((ctrlf["w"] and flyspeed) or 0) + ((ctrlf["s"] and -flyspeed) or 0)
	local lr = ((ctrlf["a"] and -flyspeed) or 0) + ((ctrlf["d"] and flyspeed) or 0)
	local camcf = ws.CurrentCamera.CFrame
	local caX, caY, caZ, ca1, ca2, ca3, ca4, ca5, ca6, ca7, ca8, ca9 = camcf:GetComponents()
	flycf = cf(flycf.X, flycf.Y, flycf.Z, ca1, ca2, ca3, ca4, ca5, ca6, ca7, ca8, ca9)
	flycf += camcf.LookVector * fb * deltaTime
	flycf += camcf.RightVector * lr * deltaTime
end)
tspawn(function()
	while stepped:Wait() and gui do
		if cfly and cfly.Parent then
			fhrp = (fhrp and (fhrp.Parent == cfly) and fhrp) or gp(cfly, "HumanoidRootPart", "BasePart") or gp(cfly, "Head", "BasePart") or cfly:FindFirstChildWhichIsA("BasePart")
			if fhrp then
				flycf = flycf or fhrp.CFrame
				weldtp(fhrp, flycf)
			end
		else
			flycf = false
			fhrp = nil
			flyb.Text = "fly"
		end
	end
end)

local hiddenfling = false
tspawn(function()
	local hrp, c, vel, movel = nil, nil, nil, 0.1
	while gui do
		heartbeat:Wait()
		if hiddenfling then
			while gui and hiddenfling and not (c and c.Parent and hrp and hrp.Parent) do
				heartbeat:Wait()
				c = lp.Character
				hrp = gp(c, "HumanoidRootPart", "BasePart") or gp(c, "Torso", "BasePart") or gp(c, "UpperTorso", "BasePart")
			end
			if gui and hiddenfling then 
				vel = hrp.Velocity
				hrp.Velocity = vel * 10000 + v3(0, 10000, 0)
				renderstepped:Wait()
				if c and c.Parent and hrp and hrp.Parent then
					hrp.Velocity = vel
				end
				stepped:Wait()
				if c and c.Parent and hrp and hrp.Parent then
					hrp.Velocity = vel + v3(0, movel, 0)
					movel = movel * -1
				end
			end
		end
	end
end)

local hiddenflingB = makecharbutton("hidden fling")
hiddenflingB.MouseButton1Click:Connect(function()
	hiddenfling = not hiddenfling
	hiddenflingB.Text = "hidden fling" .. ((hiddenfling and " (Enabled)") or "")
end)

makecharbutton("anti respawn (wait RespawnTime)").MouseButton1Click:Connect(respawnRequest)
makecharbutton("no animations").MouseButton1Click:Connect(noanimations)
makecharbutton("sit").MouseButton1Click:Connect(function()
	local c = lp.Character
	if c and c.Parent then
		local hum = c:FindFirstChildOfClass("Humanoid")
		if hum then
			hum.Sit = not hum.Sit
		else
			notify("humanoid not found")
		end
	else
		notify("character not found")
	end
end)
makecharbutton("fake sit").MouseButton1Click:Connect(function()
	local c = lp.Character
	if c and c.Parent then
		local hum = c:FindFirstChildOfClass("Humanoid")
		if hum then
			hum:SetStateEnabled(Enum.HumanoidStateType.Seated, false)
			hum.Sit = true
			notify("humanoid.Sit set to true")
		else
			notify("humanoid not found")
		end
	else
		notify("character not found")
	end
end)
makecharbutton("remove humanoidroot").MouseButton1Click:Connect(function()
	local c = lp.Character
	if c then
		local cpar = c.Parent
		if cpar then
			local hrp = gp(c, "HumanoidRootPart", "BasePart")
			if hrp then
				c.Parent = nil
				hrp:Destroy()
				c.Parent = cpar
				notify("hrp removed")
			else
				notify("hrp not found")
			end
		else
			notify("character not found")
		end
	else
		notify("character not found")
	end
end)
makecharbutton("set CanTouch to false").MouseButton1Click:Connect(function()
	local c = lp.Character
	if c and c.Parent then
		local tool = c:FindFirstChildOfClass("Tool")
		for i, v in pairs(c:GetDescendants()) do
			if v and v.Parent and v:IsA("BasePart") and ((not tool) or (not v:IsDescendantOf(tool))) then
				v.CanTouch = false
			end
		end
		notify("CanTouch has been set to false")
	else
		notify("character not found")
	end
end)
local ctrltp = false
local clicktpbutton = makecharbutton("ctrl click tp")
clicktpbutton.MouseButton1Click:Connect(function()
	ctrltp = not ctrltp
	clicktpbutton.Text = "ctrl click tp" .. ((ctrltp and " (Enabled)") or "")
end)
local con = nil
con = mouse.Button1Down:Connect(function()
	if not gui then
		con:Disconnect()
		return
	end
	if not ctrltp then
		return
	end
	if not (mouse.Target and uis:IsKeyDown(Enum.KeyCode.LeftControl)) then
		return
	end
	local to = mouse.Hit.Position + v3(0, 3, 0)
	to = cf(to, to + v3(1, 0, 1) * ws.CurrentCamera.CFrame.LookVector)
	if flycf then
		flycf = to
		return
	end
	local c = lp.Character
	if not (c and c.Parent) then
		return
	end
	local hrp = gp(c, "HumanoidRootPart", "BasePart") or gp(c, "Torso", "BasePart") or gp(c, "UpperTorso", "BasePart") or gp(c, "Head", "BasePart") or c:FindFirstChildWhichIsA("BasePart")
	if hrp then
		weldtp(hrp, to)
	end
end)
makecharbutton("view").MouseButton1Click:Connect(unview)

local utilframe = makeFrame(scrollingFrame, "Utilities", Color3.fromRGB(0, 150, 150))
local utilscroll = utilframe:FindFirstChildOfClass("ScrollingFrame")

local function makeutilbutton(buttontext)
	local button = instancenew("TextButton")
	button.Name = randomstring()
	button.Parent = utilscroll
	button.BackgroundColor3 = Color3.fromRGB(53, 53, 53)
	button.BorderSizePixel = 0
	button.Size = UDim2.new(1, -10, 0, 20)
	button.Font = Enum.Font.SourceSans
	button.Text = buttontext
	button.TextColor3 = Color3.fromRGB(226, 226, 226)
	button.TextSize = 15.000
	return button
end

local espb = makeutilbutton("esp")
local esp = false
espb.MouseButton1Click:Connect(function()
	esp = not esp
	espb.Text = "esp" .. ((esp and " (Enabled)") or "")
end)
local teamcheckb = makeutilbutton("esp team check")
local espTeamCheck = false
teamcheckb.MouseButton1Click:Connect(function()
	espTeamCheck = not espTeamCheck
	teamcheckb.Text = "esp team check" .. ((espTeamCheck and " (Enabled)") or "")
end)

local espcolor = Color3.fromRGB(255, 0, 0)

local vpf = instancenew("ViewportFrame", gui)
vpf.BackgroundTransparency = 1
vpf.BorderSizePixel = 0
vpf.ImageTransparency = 0.5
vpf.ImageColor3 = espcolor
vpf.BackgroundColor3 = espcolor
vpf.Size = UDim2.new(1, 0, 1, 0)
vpf.Visible = true
vpf.Name = randomstring()

local net = false
local con = nil
con = renderstepped:Connect(function()
	if not gui then
		con:Disconnect()
		return
	end
	if net then
		net(1000)
	end
	vpf:ClearAllChildren()
	if esp then
		vpf.CurrentCamera = ws.CurrentCamera
		for i, plr in pairs(plrs:GetPlayers()) do
			if ( (not espTeamCheck) or (plr.Team ~= lp.Team) ) and (plr ~= lp) then
				local c = plr.Character
				if c and c.Parent then
					for i, part in pairs(c:GetDescendants()) do
						if part:IsA("BasePart") then
							local part1 = instancenew("Part", vpf)
							part1.Color = espcolor
							part1.Size = part.Size
							part1.CFrame = part.CFrame
						end
					end
				end
			end
		end
	end
	if viewedPlayer then
	    if tfind(cbring, viewedPlayer.Name) then
	        return unview()
	    end
		local c = viewedPlayer.Character
		if c and c.Parent then
			local subject = c:FindFirstChildOfClass("Humanoid") or c:FindFirstChildWhichIsA("BasePart") or c
			if subject then
				ws.CurrentCamera.CameraType = Enum.CameraType.Custom
				ws.CurrentCamera.CameraSubject = subject
			end
		end
	end
end)

local antiflingb = makeutilbutton("anti fling")
local antifling = false
antiflingb.MouseButton1Click:Connect(function()
	antifling = not antifling
	antiflingb.Text = "anti fling" .. ((antifling and " (Enabled)") or "")
end)

local con0, con1 = nil, nil
local function antiflingF()
	if not gui then
		con0:Disconnect()
		con1:Disconnect()
		return
	end
	if antifling then
		for i, v in pairs(plrs:GetPlayers()) do
			if v ~= lp then
				local c = v.Character
				if c and c.Parent then
					for i1, v1 in pairs(c:GetDescendants()) do
						if v1:IsA("BasePart") then
							v1.CanCollide = false
							v1.Velocity = v3_0
							v1.RotVelocity = v3_0
						end
					end
				end
			end
		end
	end
end
con0 = stepped:Connect(antiflingF)
con1 = heartbeat:Connect(antiflingF)

local antiattb = makeutilbutton("anti attach")
local antiatt = false
antiattb.MouseButton1Click:Connect(function()
	antiatt = not antiatt
	antiattb.Text = "anti attach" .. ((antiatt and " (Enabled)") or "")
end)
local charcon = nil
local currentcon = nil
local function onchar(c)
	if not gui then
		charcon:Disconnect()
		return
	end
	if typeof(c) ~= "Instance" then
		return
	end
	if currentcon then
		currentcon:Disconnect()
	end
	currentcon = c.ChildAdded:Connect(function(t)
		if not (antiatt and gui) then
			return
		end
		if not t:IsA("Tool") then return end
		local h = gp(t, "Handle", "BasePart") or t:FindFirstChildWhichIsA("BasePart")
		if not h then return end
		for i, v in pairs(h:GetConnectedParts()) do
			if not v:IsDescendantOf(c) then
				h:BreakJoints()
				stepped:Wait()
				if t and (t.Parent == c) then
					t.Parent = lp:FindFirstChildOfClass("Backpack") or ws
				end
				return
			end
		end
	end)
end
onchar(lp.Character)
charcon = lp.CharacterAdded:Connect(onchar)

local netb = makeutilbutton("net bypass")
netb.MouseButton1Click:Connect(function()
	if net then
		net = false
	else
		net = shp and function(Radius) 
			shp(lp, "SimulationRadius", Radius) 
		end
		net = net or ssr
		if not net then
			notify("exploit not supported")
		end
	end
	netb.Text = "net bypass" .. ((net and " (Enabled)") or "")
end)

makeutilbutton("rejoin").MouseButton1Click:Connect(function()
	g:GetService("TeleportService"):TeleportToPlaceInstance(g.PlaceId, g.JobId, lp)
end)

makeutilbutton("serverhop").MouseButton1Click:Connect(function()
	local servers = nil
	pcall(function()
		servers = g:GetService("HttpService"):JSONDecode(g:HttpGetAsync("https://games.roblox.com/v1/games/" .. g.PlaceId .. "/servers/Public?sortOrder=Asc&limit=100")).data
	end)
	if type(servers) ~= "table" then
		notify("error getting server list")
		return
	end
	local jobIds = {}
	for i, v in pairs(servers) do
		if type(v) == "table" and v.maxPlayers > v.playing and v.id ~= g.JobId then
			tinsert(jobIds, v.id)
		end
	end
	if #jobIds > 0 then
		g:GetService("TeleportService"):TeleportToPlaceInstance(g.PlaceId, jobIds[mrandom(1, #jobIds)])
	else
		notify("no server found")
	end
end)

makeutilbutton("instant leave").MouseButton1Click:Connect(function()
	lp:Kick()
	twait()
	g:Shutdown()
end)


local cbringframe = makeFrame(scrollingFrame, "cbring", Color3.fromRGB(15, 100, 15))
local cbringscroll = cbringframe:FindFirstChildOfClass("ScrollingFrame")

local togglecbring = nil

local function makecbringframe(name)
	local plrcbringf = instancenew("Frame")
	local uncbringbtn = instancenew("TextButton")
	local cbringplrname = instancenew("TextBox")
	plrcbringf.Name = name
	plrcbringf.BackgroundColor3 = Color3.fromRGB(106, 106, 106)
	plrcbringf.BorderSizePixel = 0
	plrcbringf.Size = UDim2.new(1, -10, 0, 30)
	plrcbringf.Parent = cbringscroll
	uncbringbtn.Name = randomstring()
	uncbringbtn.Parent = plrcbringf
	uncbringbtn.BackgroundColor3 = Color3.fromRGB(47, 47, 47)
	uncbringbtn.BorderSizePixel = 0
	uncbringbtn.Position = UDim2.new(1, -25, 0, 5)
	uncbringbtn.Size = UDim2.new(0, 20, 1, -10)
	uncbringbtn.Font = Enum.Font.SourceSans
	uncbringbtn.Text = "X"
	uncbringbtn.TextColor3 = Color3.fromRGB(223, 223, 223)
	uncbringbtn.TextSize = 16.000
	cbringplrname.Parent = plrcbringf
	cbringplrname.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
	cbringplrname.BackgroundTransparency = 1.000
	cbringplrname.BorderSizePixel = 0
	cbringplrname.Position = UDim2.new(0, 5, 0, 5)
	cbringplrname.Size = UDim2.new(1, -80, 1, -10)
	cbringplrname.Font = Enum.Font.SourceSans
	cbringplrname.Text = name
	cbringplrname.TextColor3 = Color3.fromRGB(0, 0, 0)
	cbringplrname.TextSize = 25.000
	cbringplrname.TextXAlignment = Enum.TextXAlignment.Left
	uncbringbtn.MouseButton1Click:Connect(function()
		togglecbring(name)
	end)
	return plrcbringf
end

togglecbring = function(name)
	local frame = gp(cbringscroll, name, "Frame")
	if frame then
		pcall(function()
			tremove(cbring, tfind(cbring, name))
		end)
		frame:Destroy()
		notify("removed " .. name .. " from cbring")
	else
		tinsert(cbring, name)
		makecbringframe(name)
		notify("added " .. name .. " to cbring")
	end
end

cbringb.MouseButton1Click:Connect(function()
	togglecbring(currentplayer.Name)
end)

local cbringallbtn = instancenew("TextButton")
cbringallbtn.Name = randomstring()
cbringallbtn.Parent = cbringframe:FindFirstChildOfClass("TextLabel")
cbringallbtn.BackgroundColor3 = Color3.fromRGB(59, 59, 59)
cbringallbtn.BorderSizePixel = 0
cbringallbtn.Position = UDim2.new(1, -57, 0, 2)
cbringallbtn.Size = UDim2.new(0, 55, 1, -4)
cbringallbtn.Font = Enum.Font.SourceSans
cbringallbtn.Text = "+ add all"
cbringallbtn.TextColor3 = Color3.fromRGB(206, 206, 206)
cbringallbtn.TextSize = 14.000
cbringallbtn.MouseButton1Click:Connect(function()
	for i, v in pairs(plrs:GetPlayers()) do
		if (v ~= lp) and v and v.Parent and (not tfind(cbring, v.Name)) then
			togglecbring(v.Name)
		end
	end
end)

tspawn(function()
	while gui do
		local waited = false
		local lpc = lp.Character
		if lpc and lpc.Parent then
			local part0 = gp(lpc, "Torso", "BasePart") or gp(lpc, "HumanoidRootPart", "BasePart") or gp(lpc, "Head", "BasePart") or lpc:FindFirstChildWhichIsA("BasePart")
			if part0 then
				for i, v in pairs(plrs:GetPlayers()) do
					if v ~= lp then
						local c = v.Character
						if c and c.Parent then
							if tfind(cbring, v.Name) then
								local part1 = gp(c, part0.Name, "BasePart") or gp(c, "Torso", "BasePart") or gp(c, "HumanoidRootPart", "BasePart") or gp(c, "Head", "BasePart") or c:FindFirstChildWhichIsA("BasePart")
								if part1 then
									local p1cf = part0.CFrame
									waited = true
									weldtp(part1, p1cf + p1cf.LookVector * 2)
								end
							end
						end
					end
				end
			end
		end
		if not waited then
			stepped:Wait()
		end
	end
end)

local con = nil
con = stepped:Connect(function()
	if not gui then
		con:Disconnect()
		return
	end
	local lpc = lp.Character
	if noclip and lpc and lpc.Parent then
		for i, v in pairs(lpc:GetDescendants()) do
			if v:IsA("BasePart") then
				v.CanCollide = false
			end
		end
	end
end)

gui.Enabled = true
renderstepped:Wait()
playercframe.Visible = false
end)

local Tab = Window:NewTab("Script [????]")

local DSection = Tab:NewSection("Script [????] Here")

DSection:NewButton("Ender v10", "[????]", function()
    
end)

local Tab = Window:NewTab("Script Undertale")

local ESection = Tab:NewSection("Script To Undertale Here")

ESection:NewButton("Sans", "[????]", function()
    
end)

local Tab = Window:NewTab("Script [OP]")

local GSection = Tab:NewSection("Script [OP] Here")

GSection:NewButton("Hammer Tall", "[????]", function()
    
end)

local Tab = Window:NewTab("Script Btools")

local HSection = Tab:NewSection("Script Btools Here")

HSection:NewButton("Btools", "[????]", function()
    
end)

local Tab = Window:NewTab("Script Trolling")

local ISection = Tab:NewSection("Script For Trolling Here")

ISection:NewButton("Pandora", "[LOL]", function()
    --//====================================================\\--
--||			   CREATED BY SHACKLUSTER
--\\====================================================//--
---convert By Im Patrick
---using Myworld Reinimate

for i,v in next, game:GetService("Players").LocalPlayer.Character:GetDescendants() do if v:IsA("BasePart") and v.Name ~="HumanoidRootPart" then game:GetService("RunService").Heartbeat:connect(function() v.Velocity = Vector3.new(-30,0,0) end) end end game:GetService("StarterGui"):SetCore("SendNotification", { Title = "Im Patrick"; Text = "Netless Loaded!"; Icon = "rbxthumb://type=Asset&id=5107182114&w=150&h=150"}) Duration = 16;

local Vector3_101 = Vector3.new(1, 0, 1)
local netless_Y = Vector3.new(0, 25.1, 0)
local function getNetlessVelocity(realPartVelocity) --change this if you have a better method
    local mag = realPartVelocity.Magnitude
    if (mag > 1) and (mag < 100) then
        local unit = realPartVelocity.Unit
        if (unit.Y > 0.25) or (unit.Y < -0.75) then
            return realPartVelocity * (25.1 / realPartVelocity.Y)
        end
        realPartVelocity = unit * 100
    end
    return (realPartVelocity * Vector3_101) + netless_Y
end
local simradius = "shp" --simulation radius (net bypass) method
--"shp" - sethiddenproperty
--"ssr" - setsimulationradius
--false - disable
local noclipAllParts = true --set it to true if you want noclip
local antiragdoll = true --removes hingeConstraints and ballSocketConstraints from your character
local newanimate = true --disables the animate script and enables after reanimation
local discharscripts = true --disables all localScripts parented to your character before reanimation
local R15toR6 = true --tries to convert your character to r6 if its r15
local hatcollide = false --makes hats cancollide (credit to ShownApe) (works only with reanimate method 0)
local humState16 = true --enables collisions for limbs before the humanoid dies (using hum:ChangeState)
local addtools = false --puts all tools from backpack to character and lets you hold them after reanimation
local hedafterneck = true --disable aligns for head and enable after neck or torso is removed
local loadtime = game:GetService("Players").RespawnTime + 0.5 --anti respawn delay
local method = 3 --reanimation method
--methods:
--0 - breakJoints (takes [loadtime] seconds to laod)
--1 - limbs
--2 - limbs + anti respawn
--3 - limbs + breakJoints after [loadtime] seconds
--4 - remove humanoid + breakJoints
--5 - remove humanoid + limbs
local alignmode = 2 --AlignPosition mode
--modes:
--1 - AlignPosition rigidity enabled true
--2 - 2 AlignPositions rigidity enabled both true and false
--3 - AlignPosition rigidity enabled false
local flingpart = "HumanoidRootPart" --name of the part or the hat used for flinging
--the fling function
--usage: fling(target, duration, velocity)
--target can be set to: basePart, CFrame, Vector3, character model or humanoid (flings at mouse.Hit if argument not provided))
--duration (fling time in seconds) can be set to: a number or a string convertable to the number (0.5s if not provided),
--velocity (fling part rotation velocity) can be set to a vector3 value (Vector3.new(20000, 20000, 20000) if not provided)

local lp = game:GetService("Players").LocalPlayer
local rs = game:GetService("RunService")
local stepped = rs.Stepped
local heartbeat = rs.Heartbeat
local renderstepped = rs.RenderStepped
local sg = game:GetService("StarterGui")
local ws = game:GetService("Workspace")
local cf = CFrame.new
local v3 = Vector3.new
local v3_0 = Vector3.zero
local inf = math.huge

local c = lp.Character

if not (c and c.Parent) then
	return
end

c:GetPropertyChangedSignal("Parent"):Connect(function()
    if not (c and c.Parent) then
	    c = nil
	end
end)

local function gp(parent, name, className)
	if typeof(parent) == "Instance" then
		for i, v in pairs(parent:GetChildren()) do
			if (v.Name == name) and v:IsA(className) then
				return v
			end
		end
	end
	return nil
end

if type(getNetlessVelocity) ~= "function" then
    getNetlessVelocity = nil
end

local function align(Part0, Part1)
	Part0.CustomPhysicalProperties = PhysicalProperties.new(0, 0, 0, 0, 0)

	local att0 = Instance.new("Attachment")
	att0.Orientation = v3_0
	att0.Position = v3_0
	att0.Name = "att0_" .. Part0.Name
	local att1 = Instance.new("Attachment")
	att1.Orientation = v3_0
	att1.Position = v3_0
	att1.Name = "att1_" .. Part1.Name

	if (alignmode == 1) or (alignmode == 2) then
		local ape = Instance.new("AlignPosition", att0)
		ape.ApplyAtCenterOfMass = false
		ape.MaxForce = inf
		ape.MaxVelocity = inf
		ape.ReactionForceEnabled = false
		ape.Responsiveness = 200
		ape.Attachment1 = att1
		ape.Attachment0 = att0
		ape.Name = "AlignPositionRtrue"
		ape.RigidityEnabled = true
	end

	if (alignmode == 2) or (alignmode == 3) then
		local apd = Instance.new("AlignPosition", att0)
		apd.ApplyAtCenterOfMass = false
		apd.MaxForce = inf
		apd.MaxVelocity = inf
		apd.ReactionForceEnabled = false
		apd.Responsiveness = 200
		apd.Attachment1 = att1
		apd.Attachment0 = att0
		apd.Name = "AlignPositionRfalse"
		apd.RigidityEnabled = false
	end

	local ao = Instance.new("AlignOrientation", att0)
	ao.MaxAngularVelocity = inf
	ao.MaxTorque = inf
	ao.PrimaryAxisOnly = false
	ao.ReactionTorqueEnabled = false
	ao.Responsiveness = 200
	ao.Attachment1 = att1
	ao.Attachment0 = att0
	ao.RigidityEnabled = false

	if getNetlessVelocity then
	    local vel = Part0.Velocity
	    local velpart = Part1
        local rsteppedcon = renderstepped:Connect(function()
            Part0.Velocity = vel
        end)
        local heartbeatcon = heartbeat:Connect(function()
            vel = Part0.Velocity
            Part0.Velocity = getNetlessVelocity(velpart.Velocity)
        end)
        local attcon = nil
        Part0:GetPropertyChangedSignal("Parent"):Connect(function()
            if not (Part0 and Part0.Parent) then
                rsteppedcon:Disconnect()
                heartbeatcon:Disconnect()
                attcon:Disconnect()
            end
        end)
        attcon = att1:GetPropertyChangedSignal("Parent"):Connect(function()
	        if not (att1 and att1.Parent) then
	            attcon:Disconnect()
                velpart = Part0
	        else
	            velpart = att1.Parent
	            if not velpart:IsA("BasePart") then
	                velpart = Part0
	            end
	        end
	    end)
	end
	
	att0.Parent = Part0
    att1.Parent = Part1
end

local function respawnrequest()
	local ccfr = ws.CurrentCamera.CFrame
	local c = lp.Character
	lp.Character = nil
	lp.Character = c
	local con = nil
	con = ws.CurrentCamera.Changed:Connect(function(prop)
	    if (prop ~= "Parent") and (prop ~= "CFrame") then
	        return
	    end
	    ws.CurrentCamera.CFrame = ccfr
	    con:Disconnect()
    end)
end

local destroyhum = (method == 4) or (method == 5)
local breakjoints = (method == 0) or (method == 4)
local antirespawn = (method == 0) or (method == 2) or (method == 3)

hatcollide = hatcollide and (method == 0)

addtools = addtools and gp(lp, "Backpack", "Backpack")

local fenv = getfenv()
local shp = fenv.sethiddenproperty or fenv.set_hidden_property or fenv.set_hidden_prop or fenv.sethiddenprop
local ssr = fenv.setsimulationradius or fenv.set_simulation_radius or fenv.set_sim_radius or fenv.setsimradius or fenv.set_simulation_rad or fenv.setsimulationrad

if shp and (simradius == "shp") then
	spawn(function()
		while c and heartbeat:Wait() do
			shp(lp, "SimulationRadius", inf)
		end
	end)
elseif ssr and (simradius == "ssr") then
	spawn(function()
		while c and heartbeat:Wait() do
			ssr(inf)
		end
	end)
end

antiragdoll = antiragdoll and function(v)
	if v:IsA("HingeConstraint") or v:IsA("BallSocketConstraint") then
		v.Parent = nil
	end
end

if antiragdoll then
	for i, v in pairs(c:GetDescendants()) do
		antiragdoll(v)
	end
	c.DescendantAdded:Connect(antiragdoll)
end

if antirespawn then
	respawnrequest()
end

if method == 0 then
	wait(loadtime)
	if not c then
		return
	end
end

if discharscripts then
	for i, v in pairs(c:GetChildren()) do
		if v:IsA("LocalScript") then
			v.Disabled = true
		end
	end
elseif newanimate then
	local animate = gp(c, "Animate", "LocalScript")
	if animate and (not animate.Disabled) then
		animate.Disabled = true
	else
		newanimate = false
	end
end

if addtools then
	for i, v in pairs(addtools:GetChildren()) do
		if v:IsA("Tool") then
			v.Parent = c
		end
	end
end

pcall(function()
	settings().Physics.AllowSleep = false
	settings().Physics.PhysicsEnvironmentalThrottle = Enum.EnviromentalPhysicsThrottle.Disabled
end)

local OLDscripts = {}

for i, v in pairs(c:GetDescendants()) do
	if v.ClassName == "Script" then
		table.insert(OLDscripts, v)
	end
end

local scriptNames = {}

for i, v in pairs(c:GetDescendants()) do
	if v:IsA("BasePart") then
		local newName = tostring(i)
		local exists = true
		while exists do
			exists = false
			for i, v in pairs(OLDscripts) do
				if v.Name == newName then
					exists = true
				end
			end
			if exists then
				newName = newName .. "_"    
			end
		end
		table.insert(scriptNames, newName)
		Instance.new("Script", v).Name = newName
	end
end

c.Archivable = true
local hum = c:FindFirstChildOfClass("Humanoid")
if hum then
	for i, v in pairs(hum:GetPlayingAnimationTracks()) do
		v:Stop()
	end
end
local cl = c:Clone()
if hum and humState16 then
    hum:ChangeState(Enum.HumanoidStateType.Physics)
    if destroyhum then
        wait(1.6)
    end
end
if hum and hum.Parent and destroyhum then
    hum:Destroy()
end

if not c then
    return
end

local head = gp(c, "Head", "BasePart")
local torso = gp(c, "Torso", "BasePart") or gp(c, "UpperTorso", "BasePart")
local root = gp(c, "HumanoidRootPart", "BasePart")
if hatcollide and c:FindFirstChildOfClass("Accessory") then
    local anything = c:FindFirstChildOfClass("BodyColors") or gp(c, "Health", "Script")
    if not (torso and root and anything) then
        return
    end
    torso:Destroy()
    root:Destroy()
    if shp then
        for i,v in pairs(c:GetChildren()) do
            if v:IsA("Accessory") then
                shp(v, "BackendAccoutrementState", 0)
            end 
        end
    end
    anything:Destroy()
end

local model = Instance.new("Model", c)
model.Name = model.ClassName

model:GetPropertyChangedSignal("Parent"):Connect(function()
    if not (model and model.Parent) then
	    model = nil
    end
end)

for i, v in pairs(c:GetChildren()) do
	if v ~= model then
		if addtools and v:IsA("Tool") then
			for i1, v1 in pairs(v:GetDescendants()) do
				if v1 and v1.Parent and v1:IsA("BasePart") then
					local bv = Instance.new("BodyVelocity", v1)
					bv.Velocity = v3_0
					bv.MaxForce = v3(1000, 1000, 1000)
					bv.P = 1250
					bv.Name = "bv_" .. v.Name
				end
			end
		end
		v.Parent = model
	end
end

if breakjoints then
	model:BreakJoints()
else
	if head and torso then
		for i, v in pairs(model:GetDescendants()) do
			if v:IsA("Weld") or v:IsA("Snap") or v:IsA("Glue") or v:IsA("Motor") or v:IsA("Motor6D") then
				local save = false
				if (v.Part0 == torso) and (v.Part1 == head) then
					save = true
				end
				if (v.Part0 == head) and (v.Part1 == torso) then
					save = true
				end
				if save then
					if hedafterneck then
						hedafterneck = v
					end
				else
					v:Destroy()
				end
			end
		end
	end
	if method == 3 then
		spawn(function()
			wait(loadtime)
			if model then
				model:BreakJoints()
			end
		end)
	end
end

cl.Parent = c
for i, v in pairs(cl:GetChildren()) do
	v.Parent = c
end
cl:Destroy()

local noclipmodel = (noclipAllParts and c) or model
local noclipcon = nil
local function uncollide()
	if noclipmodel then
		for i, v in pairs(noclipmodel:GetDescendants()) do
		    if v:IsA("BasePart") then
			    v.CanCollide = false
		    end
		end
	else
		noclipcon:Disconnect()
	end
end
noclipcon = stepped:Connect(uncollide)
uncollide()

for i, scr in pairs(model:GetDescendants()) do
	if (scr.ClassName == "Script") and table.find(scriptNames, scr.Name) then
		local Part0 = scr.Parent
		if Part0:IsA("BasePart") then
			for i1, scr1 in pairs(c:GetDescendants()) do
				if (scr1.ClassName == "Script") and (scr1.Name == scr.Name) and (not scr1:IsDescendantOf(model)) then
					local Part1 = scr1.Parent
					if (Part1.ClassName == Part0.ClassName) and (Part1.Name == Part0.Name) then
						align(Part0, Part1)
						scr:Destroy()
						scr1:Destroy()
						break
					end
				end
			end
		end
	end
end

for i, v in pairs(c:GetDescendants()) do
	if v and v.Parent and (not v:IsDescendantOf(model)) then
		if v:IsA("Decal") then
		    v.Transparency = 1
		elseif v:IsA("BasePart") then
			v.Transparency = 1
			v.Anchored = false
		elseif v:IsA("ForceField") then
			v.Visible = false
		elseif v:IsA("Sound") then
			v.Playing = false
		elseif v:IsA("BillboardGui") or v:IsA("SurfaceGui") or v:IsA("ParticleEmitter") or v:IsA("Fire") or v:IsA("Smoke") or v:IsA("Sparkles") then
			v.Enabled = false
		end
	end
end

if newanimate then
	local animate = gp(c, "Animate", "LocalScript")
	if animate then
		animate.Disabled = false
	end
end

if addtools then
	for i, v in pairs(c:GetChildren()) do
		if v:IsA("Tool") then
			v.Parent = addtools
		end
	end
end

local hum0 = model:FindFirstChildOfClass("Humanoid")
if hum0 then
    hum0:GetPropertyChangedSignal("Parent"):Connect(function()
        if not (hum0 and hum0.Parent) then
            hum0 = nil
        end
    end)
end

local hum1 = c:FindFirstChildOfClass("Humanoid")
if hum1 then
    hum1:GetPropertyChangedSignal("Parent"):Connect(function()
        if not (hum1 and hum1.Parent) then
            hum1 = nil
        end
    end)
    
	ws.CurrentCamera.CameraSubject = hum1
	local camSubCon = nil
	local function camSubFunc()
		camSubCon:Disconnect()
		if c and hum1 then
			ws.CurrentCamera.CameraSubject = hum1
		end
	end
	camSubCon = renderstepped:Connect(camSubFunc)
	if hum0 then
		hum0:GetPropertyChangedSignal("Jump"):Connect(function()
			if hum1 then
				hum1.Jump = hum0.Jump
			end
		end)
	else
		respawnrequest()
	end
end

local rb = Instance.new("BindableEvent", c)
rb.Event:Connect(function()
	rb:Destroy()
	sg:SetCore("ResetButtonCallback", true)
	if destroyhum then
		c:BreakJoints()
		return
	end
	if hum0 and (hum0.Health > 0) then
		model:BreakJoints()
		hum0.Health = 0
	end
	if antirespawn then
	    respawnrequest()
	end
end)
sg:SetCore("ResetButtonCallback", rb)

spawn(function()
	while c do
		if hum0 and hum1 then
			hum1.Jump = hum0.Jump
		end
		wait()
	end
	sg:SetCore("ResetButtonCallback", true)
end)

R15toR6 = R15toR6 and hum1 and (hum1.RigType == Enum.HumanoidRigType.R15)
if R15toR6 then
    local part = gp(c, "HumanoidRootPart", "BasePart") or gp(c, "UpperTorso", "BasePart") or gp(c, "LowerTorso", "BasePart") or gp(c, "Head", "BasePart") or c:FindFirstChildWhichIsA("BasePart")
	if part then
	    local cfr = part.CFrame
		local R6parts = { 
			head = {
				Name = "Head",
				Size = v3(2, 1, 1),
				R15 = {
					Head = 0
				}
			},
			torso = {
				Name = "Torso",
				Size = v3(2, 2, 1),
				R15 = {
					UpperTorso = 0.2,
					LowerTorso = -0.8
				}
			},
			root = {
				Name = "HumanoidRootPart",
				Size = v3(2, 2, 1),
				R15 = {
					HumanoidRootPart = 0
				}
			},
			leftArm = {
				Name = "Left Arm",
				Size = v3(1, 2, 1),
				R15 = {
					LeftHand = -0.849,
					LeftLowerArm = -0.174,
					LeftUpperArm = 0.415
				}
			},
			rightArm = {
				Name = "Right Arm",
				Size = v3(1, 2, 1),
				R15 = {
					RightHand = -0.849,
					RightLowerArm = -0.174,
					RightUpperArm = 0.415
				}
			},
			leftLeg = {
				Name = "Left Leg",
				Size = v3(1, 2, 1),
				R15 = {
					LeftFoot = -0.85,
					LeftLowerLeg = -0.29,
					LeftUpperLeg = 0.49
				}
			},
			rightLeg = {
				Name = "Right Leg",
				Size = v3(1, 2, 1),
				R15 = {
					RightFoot = -0.85,
					RightLowerLeg = -0.29,
					RightUpperLeg = 0.49
				}
			}
		}
		for i, v in pairs(c:GetChildren()) do
			if v:IsA("BasePart") then
				for i1, v1 in pairs(v:GetChildren()) do
					if v1:IsA("Motor6D") then
						v1.Part0 = nil
					end
				end
			end
		end
		part.Archivable = true
		for i, v in pairs(R6parts) do
			local part = part:Clone()
			part:ClearAllChildren()
			part.Name = v.Name
			part.Size = v.Size
			part.CFrame = cfr
			part.Anchored = false
			part.Transparency = 1
			part.CanCollide = false
			for i1, v1 in pairs(v.R15) do
				local R15part = gp(c, i1, "BasePart")
				local att = gp(R15part, "att1_" .. i1, "Attachment")
				if R15part then
					local weld = Instance.new("Weld", R15part)
					weld.Name = "Weld_" .. i1
					weld.Part0 = part
					weld.Part1 = R15part
					weld.C0 = cf(0, v1, 0)
					weld.C1 = cf(0, 0, 0)
					R15part.Massless = true
					R15part.Name = "R15_" .. i1
					R15part.Parent = part
					if att then
						att.Parent = part
						att.Position = v3(0, v1, 0)
					end
				end
			end
			part.Parent = c
			R6parts[i] = part
		end
		local R6joints = {
			neck = {
				Parent = R6parts.torso,
				Name = "Neck",
				Part0 = R6parts.torso,
				Part1 = R6parts.head,
				C0 = cf(0, 1, 0, -1, 0, 0, 0, 0, 1, 0, 1, -0),
				C1 = cf(0, -0.5, 0, -1, 0, 0, 0, 0, 1, 0, 1, -0)
			},
			rootJoint = {
				Parent = R6parts.root,
				Name = "RootJoint" ,
				Part0 = R6parts.root,
				Part1 = R6parts.torso,
				C0 = cf(0, 0, 0, -1, 0, 0, 0, 0, 1, 0, 1, -0),
				C1 = cf(0, 0, 0, -1, 0, 0, 0, 0, 1, 0, 1, -0)
			},
			rightShoulder = {
				Parent = R6parts.torso,
				Name = "Right Shoulder",
				Part0 = R6parts.torso,
				Part1 = R6parts.rightArm,
				C0 = cf(1, 0.5, 0, 0, 0, 1, 0, 1, -0, -1, 0, 0),
				C1 = cf(-0.5, 0.5, 0, 0, 0, 1, 0, 1, -0, -1, 0, 0)
			},
			leftShoulder = {
				Parent = R6parts.torso,
				Name = "Left Shoulder",
				Part0 = R6parts.torso,
				Part1 = R6parts.leftArm,
				C0 = cf(-1, 0.5, 0, 0, 0, -1, 0, 1, 0, 1, 0, 0),
				C1 = cf(0.5, 0.5, 0, 0, 0, -1, 0, 1, 0, 1, 0, 0)
			},
			rightHip = {
				Parent = R6parts.torso,
				Name = "Right Hip",
				Part0 = R6parts.torso,
				Part1 = R6parts.rightLeg,
				C0 = cf(1, -1, 0, 0, 0, 1, 0, 1, -0, -1, 0, 0),
				C1 = cf(0.5, 1, 0, 0, 0, 1, 0, 1, -0, -1, 0, 0)
			},
			leftHip = {
				Parent = R6parts.torso,
				Name = "Left Hip" ,
				Part0 = R6parts.torso,
				Part1 = R6parts.leftLeg,
				C0 = cf(-1, -1, 0, 0, 0, -1, 0, 1, 0, 1, 0, 0),
				C1 = cf(-0.5, 1, 0, 0, 0, -1, 0, 1, 0, 1, 0, 0)
			}
		}
		for i, v in pairs(R6joints) do
			local joint = Instance.new("Motor6D")
			for prop, val in pairs(v) do
				joint[prop] = val
			end
			R6joints[i] = joint
		end
		if hum1 then
    		hum1.RigType = Enum.HumanoidRigType.R6
    		hum1.HipHeight = 0
		end
	end
end

local torso1 = torso
torso = gp(c, "Torso", "BasePart") or ((not R15toR6) and gp(c, torso.Name, "BasePart"))
if (typeof(hedafterneck) == "Instance") and head and torso and torso1 then
	local conNeck = nil
	local conTorso = nil
	local contorso1 = nil
	local aligns = {}
	local function enableAligns()
	    conNeck:Disconnect()
        conTorso:Disconnect()
        conTorso1:Disconnect()
		for i, v in pairs(aligns) do
			v.Enabled = true
		end
	end
	conNeck = hedafterneck.Changed:Connect(function(prop)
	    if table.find({"Part0", "Part1", "Parent"}, prop) then
	        enableAligns()
		end
	end)
	conTorso = torso:GetPropertyChangedSignal("Parent"):Connect(enableAligns)
	conTorso1 = torso1:GetPropertyChangedSignal("Parent"):Connect(enableAligns)
	for i, v in pairs(head:GetDescendants()) do
		if v:IsA("AlignPosition") or v:IsA("AlignOrientation") then
			i = tostring(i)
			aligns[i] = v
			v:GetPropertyChangedSignal("Parent"):Connect(function()
			    aligns[i] = nil
			end)
			v.Enabled = false
		end
	end
end

local flingpart0 = gp(model, flingpart, "BasePart") or gp(gp(model, flingpart, "Accessory"), "Handle", "BasePart")
local flingpart1 = gp(c, flingpart, "BasePart") or gp(gp(c, flingpart, "Accessory"), "Handle", "BasePart")

local fling = function() end
if flingpart0 and flingpart1 then
    flingpart0:GetPropertyChangedSignal("Parent"):Connect(function()
        if not (flingpart0 and flingpart0.Parent) then
            flingpart0 = nil
            fling = function() end
        end
    end)
    flingpart0.Archivable = true
    flingpart1:GetPropertyChangedSignal("Parent"):Connect(function()
        if not (flingpart1 and flingpart1.Parent) then
            flingpart1 = nil
            fling = function() end
        end
    end)
    local att0 = gp(flingpart0, "att0_" .. flingpart0.Name, "Attachment")
    local att1 = gp(flingpart1, "att1_" .. flingpart1.Name, "Attachment")
    if att0 and att1 then
        att0:GetPropertyChangedSignal("Parent"):Connect(function()
            if not (att0 and att0.Parent) then
                att0 = nil
                fling = function() end
            end
        end)
        att1:GetPropertyChangedSignal("Parent"):Connect(function()
            if not (att1 and att1.Parent) then
                att1 = nil
                fling = function() end
            end
        end)
        local lastfling = nil
        local mouse = lp:GetMouse()
        fling = function(target, duration, rotVelocity)
            if typeof(target) == "Instance" then
                if target:IsA("BasePart") then
                    target = target.Position
                elseif target:IsA("Model") then
                    target = gp(target, "HumanoidRootPart", "BasePart") or gp(target, "Torso", "BasePart") or gp(target, "UpperTorso", "BasePart") or target:FindFirstChildWhichIsA("BasePart")
                    if target then
                        target = target.Position
                    else
                        return
                    end
                elseif target:IsA("Humanoid") then
                    local parent = target.Parent
                    if not (parent and parent:IsA("Model")) then
                        return
                    end
                    target = gp(target, "HumanoidRootPart", "BasePart") or gp(target, "Torso", "BasePart") or gp(target, "UpperTorso", "BasePart") or target:FindFirstChildWhichIsA("BasePart")
                    if target then
                        target = target.Position
                    else
                        return
                    end
                else
                    return
                end
            elseif typeof(target) == "CFrame" then
                target = target.Position
            elseif typeof(target) ~= "Vector3" then
                target = mouse.Hit
                if target then
                    target = target.Position
                else
                    return
                end
            end
            lastfling = target
            if type(duration) ~= "number" then
                duration = tonumber(duration) or 0.5
            end
            if typeof(rotVelocity) ~= "Vector3" then
                rotVelocity = v3(20000, 20000, 20000)
            end
            if not (target and flingpart0 and flingpart1 and att0 and att1) then
                return
            end
            local flingpart = flingpart0:Clone()
            flingpart.Transparency = 1
            flingpart.Size = v3(0.01, 0.01, 0.01)
            flingpart.CanCollide = false
            flingpart.Name = "flingpart_" .. flingpart0.Name
            flingpart.Anchored = true
            flingpart.Velocity = v3_0
            flingpart.RotVelocity = v3_0
            flingpart:GetPropertyChangedSignal("Parent"):Connect(function()
                if not (flingpart and flingpart.Parent) then
                    flingpart = nil
                end
            end)
            flingpart.Parent = flingpart1
            if flingpart0.Transparency > 0.5 then
                flingpart0.Transparency = 0.5
            end
            att1.Parent = flingpart
            for i, v in pairs(att0:GetChildren()) do
                if v:IsA("AlignOrientation") then
                    v.Enabled = false
                end
            end
            local con = nil
            con = heartbeat:Connect(function()
                if target and (lastfling == target) and flingpart and flingpart0 and flingpart1 and att0 and att1 then
                    flingpart0.RotVelocity = rotVelocity
                    flingpart.Position = target
                else
                    con:Disconnect()
                end
            end)
            local rsteppedRotVel = v3(
                ((rotVelocity.X > 0) and -1) or 1,
                ((rotVelocity.Y > 0) and -1) or 1,
                ((rotVelocity.Z > 0) and -1) or 1
            )
            local con = nil
            con = renderstepped:Connect(function()
                if target and (lastfling == target) and flingpart and flingpart0 and flingpart1 and att0 and att1 then
                    flingpart0.RotVelocity = rsteppedRotVel
                    flingpart.Position = target
                else
                    con:Disconnect()
                end
            end)
            wait(duration)
            if lastfling ~= target then
                if flingpart then
                    if att1 and (att1.Parent == flingpart) then
                        att1.Parent = flingpart1
                    end
                    flingpart:Destroy()
                end
                return
            end
            target = nil
            if not (flingpart and flingpart0 and flingpart1 and att0 and att1) then
                return
            end
            flingpart0.RotVelocity = v3_0
            att1.Parent = flingpart1
            for i, v in pairs(att0:GetChildren()) do
                if v:IsA("AlignOrientation") then
                    v.Enabled = true
                end
            end
            if flingpart then
                flingpart:Destroy()
            end
        end
    end
end

Player = game:GetService("Players").LocalPlayer
PlayerGui = Player.PlayerGui
Cam = workspace.CurrentCamera
Backpack = Player.Backpack
Character = Player.Character
Humanoid = Character.Humanoid
Mouse = Player:GetMouse()
RootPart = Character["HumanoidRootPart"]
Torso = Character["Torso"]
Head = Character["Head"]
RightArm = Character["Right Arm"]
LeftArm = Character["Left Arm"]
RightLeg = Character["Right Leg"]
LeftLeg = Character["Left Leg"]
RootJoint = RootPart["RootJoint"]
Neck = Torso["Neck"]
RightShoulder = Torso["Right Shoulder"]
LeftShoulder = Torso["Left Shoulder"]
RightHip = Torso["Right Hip"]
LeftHip = Torso["Left Hip"]
Character.Archivable = true
Player:ClearCharacterAppearance()

IT = Instance.new
CF = CFrame.new
VT = Vector3.new
RAD = math.rad
C3 = Color3.new
UD2 = UDim2.new
BRICKC = BrickColor.new
ANGLES = CFrame.Angles
EULER = CFrame.fromEulerAnglesXYZ
COS = math.cos
ACOS = math.acos
SIN = math.sin
ASIN = math.asin
ABS = math.abs
MRANDOM = math.random
FLOOR = math.floor

--//=================================\\
--|| 	      USEFUL VALUES
--\\=================================//

Animation_Speed = 3
Frame_Speed = 1 / 60 -- (1 / 30) OR (1 / 60)
local Speed = 20
local SIZE = 1.4
local ROOTC0 = CF(0, 0, 0) * ANGLES(RAD(-90), RAD(0), RAD(180))
local NECKC0 = CF(0, 1, 0) * ANGLES(RAD(-90), RAD(0), RAD(180))
local RIGHTSHOULDERC0 = CF(-0.5, 0, 0) * ANGLES(RAD(0), RAD(90), RAD(0))
local LEFTSHOULDERC0 = CF(0.5, 0, 0) * ANGLES(RAD(0), RAD(-90), RAD(0))
local DAMAGEMULTIPLIER = 0
local ANIM = "Idle"
local ATTACK = false
local EQUIPPED = false
local HOLD = false
local COMBO = 1
local Rooted = false
local SINE = 0
local KEYHOLD = false
local CHANGE = 2 / Animation_Speed
local WALKINGANIM = false
local VALUE1 = false
local VALUE2 = false
local ROBLOXIDLEANIMATION = IT("Animation")
ROBLOXIDLEANIMATION.Name = "Roblox Idle Animation"
ROBLOXIDLEANIMATION.AnimationId = "http://www.roblox.com/asset/?id=180435571"
local ATANIM = IT("Animation")
ATANIM.Name = "Attack Animation"
ATANIM.AnimationId = "http://www.roblox.com/asset/?id=74894663"
--ROBLOXIDLEANIMATION.Parent = Humanoid
local WEAPONGUI = IT("ScreenGui", PlayerGui)
WEAPONGUI.Name = "Weapon GUI"
local Weapon = IT("Model")
Weapon.Name = "Adds"
local Effects = IT("Folder", Weapon)
Effects.Name = "Effects"
local ANIMATOR = Humanoid.Animator
local ANIMATE = Character.Animate
local UNANCHOR = true
local CLOCKLOOP = 0
local SONG = 1382488262
local CLOCKTARGET = nil
local CLOCKSPEED = 1
script.Parent = WEAPONGUI
local CLONE = Character:Clone()
CLONE.Parent = nil
Character.Archivable = false
local sick = Instance.new("Sound",Torso)

--//=================================\\
--\\=================================//


--//=================================\\
--|| SAZERENOS' ARTIFICIAL HEARTBEAT
--\\=================================//

ArtificialHB = Instance.new("BindableEvent", script)
ArtificialHB.Name = "ArtificialHB"

script:WaitForChild("ArtificialHB")

frame = Frame_Speed
tf = 0
allowframeloss = false
tossremainder = false
lastframe = tick()
script.ArtificialHB:Fire()

game:GetService("RunService").Heartbeat:connect(function(s, p)
	tf = tf + s
	if tf >= frame then
		if allowframeloss then
			script.ArtificialHB:Fire()
			lastframe = tick()
		else
			for i = 1, math.floor(tf / frame) do
				script.ArtificialHB:Fire()
			end
		lastframe = tick()
		end
		if tossremainder then
			tf = 0
		else
			tf = tf - frame * math.floor(tf / frame)
		end
	end
end)

--//=================================\\
--\\=================================//

--//=================================\\
--|| 	      SOME FUNCTIONS
--\\=================================//

function Raycast(POSITION, DIRECTION, RANGE, IGNOREDECENDANTS)
	return workspace:FindPartOnRay(Ray.new(POSITION, DIRECTION.unit * RANGE), IGNOREDECENDANTS)
end

function PositiveAngle(NUMBER)
	if NUMBER >= 0 then
		NUMBER = 0
	end
	return NUMBER
end

function NegativeAngle(NUMBER)
	if NUMBER <= 0 then
		NUMBER = 0
	end
	return NUMBER
end

function Swait(NUMBER)
	if NUMBER == 0 or NUMBER == nil then
		ArtificialHB.Event:wait()
	else
		for i = 1, NUMBER do
			ArtificialHB.Event:wait()
		end
	end
end

function CreateMesh(MESH, PARENT, MESHTYPE, MESHID, TEXTUREID, SCALE, OFFSET)
	local NEWMESH = IT(MESH)
	if MESH == "SpecialMesh" then
		NEWMESH.MeshType = MESHTYPE
		if MESHID ~= "nil" and MESHID ~= "" then
			NEWMESH.MeshId = "http://www.roblox.com/asset/?id="..MESHID
		end
		if TEXTUREID ~= "nil" and TEXTUREID ~= "" then
			NEWMESH.TextureId = "http://www.roblox.com/asset/?id="..TEXTUREID
		end
	end
	NEWMESH.Offset = OFFSET or VT(0, 0, 0)
	NEWMESH.Scale = SCALE
	NEWMESH.Parent = PARENT
	return NEWMESH
end

function CreatePart(FORMFACTOR, PARENT, MATERIAL, REFLECTANCE, TRANSPARENCY, BRICKCOLOR, NAME, SIZE, ANCHOR)
	local NEWPART = IT("Part")
	NEWPART.formFactor = FORMFACTOR
	NEWPART.Reflectance = REFLECTANCE
	NEWPART.Transparency = TRANSPARENCY
	NEWPART.CanCollide = false
	NEWPART.Locked = true
	NEWPART.Anchored = true
	if ANCHOR == false then
		NEWPART.Anchored = false
	end
	NEWPART.BrickColor = BRICKC(tostring(BRICKCOLOR))
	NEWPART.Name = NAME
	NEWPART.Size = SIZE
	NEWPART.Position = Torso.Position
	NEWPART.Material = MATERIAL
	NEWPART:BreakJoints()
	NEWPART.Parent = PARENT
	return NEWPART
end

	local function weldBetween(a, b)
	    local weldd = Instance.new("ManualWeld")
	    weldd.Part0 = a
	    weldd.Part1 = b
	    weldd.C0 = CFrame.new()
	    weldd.C1 = b.CFrame:inverse() * a.CFrame
	    weldd.Parent = a
	    return weldd
	end


function QuaternionFromCFrame(cf)
	local mx, my, mz, m00, m01, m02, m10, m11, m12, m20, m21, m22 = cf:components()
	local trace = m00 + m11 + m22
	if trace > 0 then 
		local s = math.sqrt(1 + trace)
		local recip = 0.5 / s
		return (m21 - m12) * recip, (m02 - m20) * recip, (m10 - m01) * recip, s * 0.5
	else
		local i = 0
		if m11 > m00 then
			i = 1
		end
		if m22 > (i == 0 and m00 or m11) then
			i = 2
		end
		if i == 0 then
			local s = math.sqrt(m00 - m11 - m22 + 1)
			local recip = 0.5 / s
			return 0.5 * s, (m10 + m01) * recip, (m20 + m02) * recip, (m21 - m12) * recip
		elseif i == 1 then
			local s = math.sqrt(m11 - m22 - m00 + 1)
			local recip = 0.5 / s
			return (m01 + m10) * recip, 0.5 * s, (m21 + m12) * recip, (m02 - m20) * recip
		elseif i == 2 then
			local s = math.sqrt(m22 - m00 - m11 + 1)
			local recip = 0.5 / s return (m02 + m20) * recip, (m12 + m21) * recip, 0.5 * s, (m10 - m01) * recip
		end
	end
end
 
function QuaternionToCFrame(px, py, pz, x, y, z, w)
	local xs, ys, zs = x + x, y + y, z + z
	local wx, wy, wz = w * xs, w * ys, w * zs
	local xx = x * xs
	local xy = x * ys
	local xz = x * zs
	local yy = y * ys
	local yz = y * zs
	local zz = z * zs
	return CFrame.new(px, py, pz, 1 - (yy + zz), xy - wz, xz + wy, xy + wz, 1 - (xx + zz), yz - wx, xz - wy, yz + wx, 1 - (xx + yy))
end
 
function QuaternionSlerp(a, b, t)
	local cosTheta = a[1] * b[1] + a[2] * b[2] + a[3] * b[3] + a[4] * b[4]
	local startInterp, finishInterp;
	if cosTheta >= 0.0001 then
		if (1 - cosTheta) > 0.0001 then
			local theta = ACOS(cosTheta)
			local invSinTheta = 1 / SIN(theta)
			startInterp = SIN((1 - t) * theta) * invSinTheta
			finishInterp = SIN(t * theta) * invSinTheta
		else
			startInterp = 1 - t
			finishInterp = t
		end
	else
		if (1 + cosTheta) > 0.0001 then
			local theta = ACOS(-cosTheta)
			local invSinTheta = 1 / SIN(theta)
			startInterp = SIN((t - 1) * theta) * invSinTheta
			finishInterp = SIN(t * theta) * invSinTheta
		else
			startInterp = t - 1
			finishInterp = t
		end
	end
	return a[1] * startInterp + b[1] * finishInterp, a[2] * startInterp + b[2] * finishInterp, a[3] * startInterp + b[3] * finishInterp, a[4] * startInterp + b[4] * finishInterp
end

function Clerp(a, b, t)
	local qa = {QuaternionFromCFrame(a)}
	local qb = {QuaternionFromCFrame(b)}
	local ax, ay, az = a.x, a.y, a.z
	local bx, by, bz = b.x, b.y, b.z
	local _t = 1 - t
	return QuaternionToCFrame(_t * ax + t * bx, _t * ay + t * by, _t * az + t * bz, QuaternionSlerp(qa, qb, t))
end

function CreateFrame(PARENT, TRANSPARENCY, BORDERSIZEPIXEL, POSITION, SIZE, COLOR, BORDERCOLOR, NAME)
	local frame = IT("Frame")
	frame.BackgroundTransparency = TRANSPARENCY
	frame.BorderSizePixel = BORDERSIZEPIXEL
	frame.Position = POSITION
	frame.Size = SIZE
	frame.BackgroundColor3 = COLOR
	frame.BorderColor3 = BORDERCOLOR
	frame.Name = NAME
	frame.Parent = PARENT
	return frame
end

function CreateLabel(PARENT, TEXT, TEXTCOLOR, TEXTFONTSIZE, TEXTFONT, TRANSPARENCY, BORDERSIZEPIXEL, STROKETRANSPARENCY, NAME)
	local label = IT("TextLabel")
	label.BackgroundTransparency = 1
	label.Size = UD2(1, 0, 1, 0)
	label.Position = UD2(0, 0, 0, 0)
	label.TextColor3 = TEXTCOLOR
	label.TextStrokeTransparency = STROKETRANSPARENCY
	label.TextTransparency = TRANSPARENCY
	label.FontSize = TEXTFONTSIZE
	label.Font = TEXTFONT
	label.BorderSizePixel = BORDERSIZEPIXEL
	label.TextStrokeColor3 = C3(1,1,1)
	label.TextScaled = false
	label.Text = TEXT
	label.Name = NAME
	label.Parent = PARENT
	return label
end

function NoOutlines(PART)
	PART.TopSurface, PART.BottomSurface, PART.LeftSurface, PART.RightSurface, PART.FrontSurface, PART.BackSurface = 10, 10, 10, 10, 10, 10
end

function CreateWeldOrSnapOrMotor(TYPE, PARENT, PART0, PART1, C0, C1)
	local NEWWELD = IT(TYPE)
	NEWWELD.Part0 = PART0
	NEWWELD.Part1 = PART1
	NEWWELD.C0 = C0
	NEWWELD.C1 = C1
	NEWWELD.Parent = PARENT
	return NEWWELD
end

local S = IT("Sound")
function CreateSound(ID, PARENT, VOLUME, PITCH, DOESLOOP)
	local NEWSOUND = nil
	coroutine.resume(coroutine.create(function()
		NEWSOUND = S:Clone()
		NEWSOUND.Parent = PARENT
		NEWSOUND.Volume = VOLUME
		NEWSOUND.Pitch = PITCH
		NEWSOUND.SoundId = "http://www.roblox.com/asset/?id="..ID
		NEWSOUND:play()
		if DOESLOOP == true then
			NEWSOUND.Looped = true
		else
			repeat wait(1) until NEWSOUND.Playing == false
			NEWSOUND:remove()
		end
	end))
	return NEWSOUND
end

function CFrameFromTopBack(at, top, back)
	local right = top:Cross(back)
	return CF(at.x, at.y, at.z, right.x, top.x, back.x, right.y, top.y, back.y, right.z, top.z, back.z)
end

--WACKYEFFECT({EffectType = "", Size = VT(1,1,1), Size2 = VT(0,0,0), Transparency = 0, Transparency2 = 1, CFrame = CF(), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = C3(1,1,1), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
function WACKYEFFECT(Table)
	local TYPE = (Table.EffectType or "Sphere")
	local SIZE = (Table.Size or VT(1,1,1))
	local ENDSIZE = (Table.Size2 or VT(0,0,0))
	local TRANSPARENCY = (Table.Transparency or 0)
	local ENDTRANSPARENCY = (Table.Transparency2 or 1)
	local CFRAME = (Table.CFrame or Torso.CFrame)
	local MOVEDIRECTION = (Table.MoveToPos or nil)
	local ROTATION1 = (Table.RotationX or 0)
	local ROTATION2 = (Table.RotationY or 0)
	local ROTATION3 = (Table.RotationZ or 0)
	local MATERIAL = (Table.Material or "Neon")
	local COLOR = (Table.Color or C3(1,1,1))
	local TIME = (Table.Time or 45)
	local SOUNDID = (Table.SoundID or nil)
	local SOUNDPITCH = (Table.SoundPitch or nil)
	local SOUNDVOLUME = (Table.SoundVolume or nil)
	coroutine.resume(coroutine.create(function()
		local PLAYSSOUND = false
		local SOUND = nil
		local EFFECT = CreatePart(3, Effects, MATERIAL, 0, TRANSPARENCY, BRICKC("Pearl"), "Effect", VT(1,1,1), true)
		if SOUNDID ~= nil and SOUNDPITCH ~= nil and SOUNDVOLUME ~= nil then
			PLAYSSOUND = true
			SOUND = CreateSound(SOUNDID, EFFECT, SOUNDVOLUME, SOUNDPITCH, false)
		end
		EFFECT.Color = COLOR
		local MSH = nil
		if TYPE == "Sphere" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "Sphere", "", "", SIZE, VT(0,0,0))
		elseif TYPE == "Block" then
			MSH = IT("BlockMesh",EFFECT)
			MSH.Scale = VT(SIZE.X,SIZE.X,SIZE.X)
		elseif TYPE == "Wave" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "20329976", "", SIZE, VT(0,0,-SIZE.X/8))
		elseif TYPE == "Ring" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "559831844", "", VT(SIZE.X,SIZE.X,0.1), VT(0,0,0))
		elseif TYPE == "Slash" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "662586858", "", VT(SIZE.X/10,0,SIZE.X/10), VT(0,0,0))
		elseif TYPE == "Round Slash" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "662585058", "", VT(SIZE.X/10,0,SIZE.X/10), VT(0,0,0))
		elseif TYPE == "Swirl" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "1051557", "", SIZE, VT(0,0,0))
		elseif TYPE == "Skull" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "4770583", "", SIZE, VT(0,0,0))
		elseif TYPE == "Crystal" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "9756362", "", SIZE, VT(0,0,0))
		end
		if MSH ~= nil then
			local MOVESPEED = nil
			if MOVEDIRECTION ~= nil then
				MOVESPEED = (CFRAME.p - MOVEDIRECTION).Magnitude/TIME
			end
			local GROWTH = SIZE - ENDSIZE
			local TRANS = TRANSPARENCY - ENDTRANSPARENCY
			if TYPE == "Block" then
				EFFECT.CFrame = CFRAME*ANGLES(RAD(MRANDOM(0,360)),RAD(MRANDOM(0,360)),RAD(MRANDOM(0,360)))
			else
				EFFECT.CFrame = CFRAME
			end
			for LOOP = 1, TIME+1 do
				Swait()
				MSH.Scale = MSH.Scale - GROWTH/TIME
				if TYPE == "Wave" then
					MSH.Offset = VT(0,0,-MSH.Scale.X/8)
				end
				EFFECT.Transparency = EFFECT.Transparency - TRANS/TIME
				if TYPE == "Block" then
					EFFECT.CFrame = CFRAME*ANGLES(RAD(MRANDOM(0,360)),RAD(MRANDOM(0,360)),RAD(MRANDOM(0,360)))
				else
					EFFECT.CFrame = EFFECT.CFrame*ANGLES(RAD(ROTATION1),RAD(ROTATION2),RAD(ROTATION3))
				end
				if MOVEDIRECTION ~= nil then
					local ORI = EFFECT.Orientation
					EFFECT.CFrame = CF(EFFECT.Position,MOVEDIRECTION)*CF(0,0,-MOVESPEED)
					EFFECT.Orientation = ORI
				end
			end
			if PLAYSSOUND == false then
				EFFECT:remove()
			else
				repeat Swait() until SOUND.Playing == false
				EFFECT:remove()
			end
		else
			if PLAYSSOUND == false then
				EFFECT:remove()
			else
				repeat Swait() until SOUND.Playing == false
				EFFECT:remove()
			end
		end
	end))
end

function MakeForm(PART,TYPE)
	if TYPE == "Cyl" then
		local MSH = IT("CylinderMesh",PART)
	elseif TYPE == "Ball" then
		local MSH = IT("SpecialMesh",PART)
		MSH.MeshType = "Sphere"
	elseif TYPE == "Wedge" then
		local MSH = IT("SpecialMesh",PART)
		MSH.MeshType = "Wedge"
	end
end

Debris = game:GetService("Debris")

function CastProperRay(StartPos, EndPos, Distance, Ignore)
	local DIRECTION = CF(StartPos,EndPos).lookVector
	return Raycast(StartPos, DIRECTION, Distance, Ignore)
end

function turnto(position)
	RootPart.CFrame=CFrame.new(RootPart.CFrame.p,VT(position.X,RootPart.Position.Y,position.Z)) * CFrame.new(0, 0, 0)
end

--//=================================\\
--||	     WEAPON CREATION
--\\=================================//

Humanoid.Parent = nil
RootPart.Size = RootPart.Size*SIZE
Torso.Size = Torso.Size*SIZE
RightArm.Size = RightArm.Size*SIZE
RightLeg.Size = RightLeg.Size*SIZE
LeftArm.Size = LeftArm.Size*SIZE
LeftLeg.Size = LeftLeg.Size*SIZE
RootJoint.C0 = ROOTC0 * CF(0 * SIZE, 0 * SIZE, 0 * SIZE) * ANGLES(RAD(0), RAD(0), RAD(0))
RootJoint.C1 = ROOTC0 * CF(0 * SIZE, 0 * SIZE, 0 * SIZE) * ANGLES(RAD(0), RAD(0), RAD(0))
Neck.C0 = NECKC0 * CF(0 * SIZE, 0 * SIZE, 0 + ((1 * SIZE) - 1)) * ANGLES(RAD(0), RAD(0), RAD(0))
Neck.C1 = CF(0 * SIZE, -0.5 * SIZE, 0 * SIZE) * ANGLES(RAD(-90), RAD(0), RAD(180))
RightShoulder.C1 = CF(0 * SIZE, 0.5 * SIZE, -0.35 * SIZE)
LeftShoulder.C1 = CF(0 * SIZE, 0.5 * SIZE, -0.35 * SIZE)
RightHip.C0 = CF(1 * SIZE, -1 * SIZE, 0 * SIZE) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0))
LeftHip.C0 = CF(-1 * SIZE, -1 * SIZE, 0 * SIZE) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0))
RightHip.C1 = CF(0.5 * SIZE, 1 * SIZE, 0 * SIZE) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0))
LeftHip.C1 = CF(-0.5 * SIZE, 1 * SIZE, 0 * SIZE) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0))
Head.Size = Head.Size*SIZE
RootJoint.Parent = RootPart
Neck.Parent = Torso
RightShoulder.Parent = Torso
LeftShoulder.Parent = Torso
RightHip.Parent = Torso
LeftHip.Parent = Torso

Humanoid.DisplayDistanceType = "None"
local naeeym2 = IT("BillboardGui",Character)
naeeym2.AlwaysOnTop = true
naeeym2.Size = UDim2.new(5,35,2,15)
naeeym2.StudsOffset = Vector3.new(0,2,0)
naeeym2.MaxDistance = 75
naeeym2.Adornee = Character.Head
naeeym2.Name = "Name"
local tecks2 = IT("TextLabel",naeeym2)
tecks2.BackgroundTransparency = 1
tecks2.TextScaled = true
tecks2.BorderSizePixel = 0
tecks2.Text = "Pandora"
tecks2.Font = "Fantasy"
tecks2.TextSize = 30
tecks2.TextStrokeTransparency = 0
tecks2.TextColor3 = C3(1,1,1)
tecks2.TextStrokeColor3 = C3(159/255, 111/255, 183/255)
tecks2.Size = UDim2.new(1,0,0.5,0)
tecks2.Parent = naeeym2
local top = Instance.new("Shirt")
top.ShirtTemplate = "rbxassetid://1533635803"
top.Parent = Character
top.Name = "Cloth"
local bottom = Instance.new("Pants")
bottom.PantsTemplate = "rbxassetid://1460022985"
bottom.Parent = Character
bottom.Name = "Cloth"
local PRT = CreatePart(3, Weapon, "Fabric", 0, 0, "Really black", "Hat", VT(1,1,1),false)
PRT.Color = C3(0,0,0)
CreateWeldOrSnapOrMotor("Weld", Head, Head, PRT, CF(0,0.72*SIZE,0.1) * ANGLES(RAD(15), RAD(0), RAD(0)), CF(0, 0, 0))
CreateMesh("SpecialMesh", PRT, "FileMesh", "26768040", "", VT(1,1,1)*SIZE, VT(0,0,0))
local PRT = CreatePart(3, Character, "Fabric", 0, 0, "Really black", "Detail", VT(1,1,1),false)
PRT.Color = C3(1,1,1)
CreateWeldOrSnapOrMotor("Weld", Head, Head, PRT, CF(0,0,-.5*SIZE), CF(0, 0, 0))
CreateMesh("SpecialMesh", PRT, "FileMesh", "13520257", "", VT(1,1,1)*SIZE, VT(0,0,0))
local PRT = CreatePart(3, Character, "Neon", 0, 0, "Really black", "Detail", VT(1,1.2,0.2),false)
PRT.Color = C3(159/255, 111/255, 183/255)
MakeForm(PRT,"Ball")
CreateWeldOrSnapOrMotor("Weld", Head, Head, PRT, CF(0,0,-.5*SIZE), CF(0, 0, 0))
local PRT = CreatePart(3, Character, "Neon", 0, 0, "Really black", "Detail", VT(0.5,0.4,0.5),false)
PRT.Color = C3(159/255, 111/255, 183/255)
MakeForm(PRT,"Ball")
CreateWeldOrSnapOrMotor("Weld", Head, Head, PRT, CF(0,-0.3,-.5*SIZE), CF(0, 0, 0))
local PRT = CreatePart(3, Character, "Neon", 0, 0, "Really black", "Detail", VT(0.5,0.3,0.3),false)
PRT.Color = C3(159/255, 111/255, 183/255)
MakeForm(PRT,"Ball")
CreateWeldOrSnapOrMotor("Weld", Head, Head, PRT, CF(0.25,0.25,-.5*SIZE), CF(0, 0, 0))
local PRT = CreatePart(3, Character, "Neon", 0, 0, "Really black", "Detail", VT(0.5,0.3,0.3),false)
PRT.Color = C3(159/255, 111/255, 183/255)
MakeForm(PRT,"Ball")
CreateWeldOrSnapOrMotor("Weld", Head, Head, PRT, CF(-0.25,0.25,-.5*SIZE), CF(0, 0, 0))
local PRT = CreatePart(3, Character, "Neon", 0, 0, "Really black", "Detail", VT(0.4,0.4,0.3),false)
PRT.Color = C3(159/255, 111/255, 183/255)
MakeForm(PRT,"Ball")
CreateWeldOrSnapOrMotor("Weld", Head, Head, PRT, CF(-0.17,-0.25,-.5*SIZE) * ANGLES(RAD(-15), RAD(15), RAD(0)), CF(0, 0, 0))
local PRT = CreatePart(3, Character, "Neon", 0, 0, "Really black", "Detail", VT(0.4,0.4,0.3),false)
PRT.Color = C3(159/255, 111/255, 183/255)
MakeForm(PRT,"Ball")
CreateWeldOrSnapOrMotor("Weld", Head, Head, PRT, CF(0.17,-0.25,-.5*SIZE) * ANGLES(RAD(-15), RAD(-15), RAD(0)), CF(0, 0, 0))

local LASTPART = Head
for i = 1, 24 do
	local MATH = (1-(i/30))
	if LASTPART == Head then
		local Horn = CreatePart(3, Character, "SmoothPlastic", 0, 0, "Dirt brown", "Detail", VT(0.25*MATH,0.15,0.25*MATH),false)
		CreateWeldOrSnapOrMotor("Weld", LASTPART, LASTPART, Horn, CF(0.8, 0.3, -0.4) * ANGLES(RAD(-25), RAD(220), RAD(90)), CF(0, 0, 0))
		LASTPART = Horn
		Horn.Color = C3(1-((i*4-4)/255),1-((i*6-6)/255),1-((i*3-3)/255))
	else
		local Horn = CreatePart(3, Character, "SmoothPlastic", 0, 0, "Dirt brown", "Detail", VT(0.25*MATH,0.15,0.25*MATH),false)
		CreateWeldOrSnapOrMotor("Weld", LASTPART, LASTPART, Horn, CF(0, Horn.Size.Y/2, 0) * ANGLES(RAD(5), RAD(3), RAD(0)), CF(0, -Horn.Size.Y/2, 0))
		LASTPART = Horn
		Horn.Color = C3(1-((i*4-4)/255),1-((i*6-6)/255),1-((i*3-3)/255))
	end
end
local LASTPART = Head
for i = 1, 24 do
	local MATH = (1-(i/30))
	if LASTPART == Head then
		local Horn = CreatePart(3, Character, "SmoothPlastic", 0, 0, "Dirt brown", "Detail", VT(0.25*MATH,0.15,0.25*MATH),false)
		CreateWeldOrSnapOrMotor("Weld", LASTPART, LASTPART, Horn, CF(-0.8, 0.3, -0.4) * ANGLES(RAD(-25), RAD(-220), RAD(-90)), CF(0, 0, 0))
		LASTPART = Horn
		Horn.Color = C3(1-((i*4-4)/255),1-((i*6-6)/255),1-((i*3-3)/255))
	else
		local Horn = CreatePart(3, Character, "SmoothPlastic", 0, 0, "Dirt brown", "Detail", VT(0.25*MATH,0.15,0.25*MATH),false)
		CreateWeldOrSnapOrMotor("Weld", LASTPART, LASTPART, Horn, CF(0, Horn.Size.Y/2, 0) * ANGLES(RAD(5), RAD(-3), RAD(0)), CF(0, -Horn.Size.Y/2, 0))
		LASTPART = Horn
		Horn.Color = C3(1-((i*4-4)/255),1-((i*6-6)/255),1-((i*3-3)/255))
	end
end
local LASTPART = Head
for i = 1, 8 do
	local MATH = (1-(i/14))
	if LASTPART == Head then
		local Horn = CreatePart(3, Character, "SmoothPlastic", 0, 0, "Dirt brown", "Detail", VT(0.25*MATH,0.15,0.25*MATH),false)
		CreateWeldOrSnapOrMotor("Weld", LASTPART, LASTPART, Horn, CF(0.65, -0.3, -0.4) * ANGLES(RAD(-25), RAD(250), RAD(90)), CF(0, 0, 0))
		LASTPART = Horn
		Horn.Color = C3(1-((i*4-4)/255),1-((i*6-6)/255),1-((i*3-3)/255))
	else
		local Horn = CreatePart(3, Character, "SmoothPlastic", 0, 0, "Dirt brown", "Detail", VT(0.25*MATH,0.15,0.25*MATH),false)
		CreateWeldOrSnapOrMotor("Weld", LASTPART, LASTPART, Horn, CF(0, Horn.Size.Y/2, 0) * ANGLES(RAD(10), RAD(3), RAD(0)), CF(0, -Horn.Size.Y/2, 0))
		LASTPART = Horn
		Horn.Color = C3(1-((i*4-4)/255),1-((i*6-6)/255),1-((i*3-3)/255))
	end
end
local LASTPART = Head
for i = 1, 8 do
	local MATH = (1-(i/14))
	if LASTPART == Head then
		local Horn = CreatePart(3, Character, "SmoothPlastic", 0, 0, "Dirt brown", "Detail", VT(0.25*MATH,0.15,0.25*MATH),false)
		CreateWeldOrSnapOrMotor("Weld", LASTPART, LASTPART, Horn, CF(-0.65, -0.3, -0.4) * ANGLES(RAD(-25), RAD(-250), RAD(-90)), CF(0, 0, 0))
		LASTPART = Horn
		Horn.Color = C3(1-((i*4-4)/255),1-((i*6-6)/255),1-((i*3-3)/255))
	else
		local Horn = CreatePart(3, Character, "SmoothPlastic", 0, 0, "Dirt brown", "Detail", VT(0.25*MATH,0.15,0.25*MATH),false)
		CreateWeldOrSnapOrMotor("Weld", LASTPART, LASTPART, Horn, CF(0, Horn.Size.Y/2, 0) * ANGLES(RAD(10), RAD(-3), RAD(0)), CF(0, -Horn.Size.Y/2, 0))
		LASTPART = Horn
		Horn.Color = C3(1-((i*4-4)/255),1-((i*6-6)/255),1-((i*3-3)/255))
	end
end
local PRT = CreatePart(3, Weapon, "Metal", 0, 0, "Mid gray", "Watch", VT(1.05,0.06,1.05)*SIZE,false)
CreateWeldOrSnapOrMotor("Weld", RightArm, RightArm, PRT, CF(0,-0.5*SIZE,0) * ANGLES(RAD(0), RAD(0), RAD(0)), CF(0, 0, 0))
local PRT = CreatePart(3, Weapon, "Metal", 0, 0, "Mid gray", "Watch", VT(0.5,0.1,0.5)*SIZE,false)
CreateWeldOrSnapOrMotor("Weld", RightArm, RightArm, PRT, CF(0,-0.5*SIZE,0) * ANGLES(RAD(90), RAD(0), RAD(0)), CF(0, -0.5*SIZE, 0))
MakeForm(PRT,"Cyl")
local PRT = CreatePart(3, Weapon, "Neon", 0, 0, "Mid gray", "Watch", VT(0.45,0.11,0.45)*SIZE,false)
CreateWeldOrSnapOrMotor("Weld", RightArm, RightArm, PRT, CF(0,-0.5*SIZE,0) * ANGLES(RAD(90), RAD(0), RAD(0)), CF(0, -0.5*SIZE, 0))
MakeForm(PRT,"Cyl")
PRT.Color = C3(159/255, 111/255, 183/255)
local RING = CreatePart(3, Weapon, "Metal", 0, 0, "Mid gray", "Watch", VT(0.055,0.15,0.055)*SIZE,false)
CreateWeldOrSnapOrMotor("Weld", RightArm, RightArm, RING, CF(0,-0.5*SIZE,0) * ANGLES(RAD(90), RAD(0), RAD(0)), CF(0, -0.5*SIZE, 0))
MakeForm(RING,"Cyl")
RING.Color = C3(0,0,0)
for i = 1, 12 do
	local PRT = CreatePart(3, Weapon, "Metal", 0, 0, "Mid gray", "Watch", VT(0,0.15,0)*SIZE,false)
	PRT.Color = C3(0,0,0)
	local MSH = IT("BlockMesh",PRT)
	MSH.Scale = VT(0.6,1,1)
	CreateWeldOrSnapOrMotor("Weld", RightArm, RightArm, PRT, CF(0,-0.5*SIZE,0) * ANGLES(RAD(90), RAD((360/12)*i), RAD(0)), CF(0, -0.49*SIZE, 0) * CF(0, 0, -0.2*SIZE))
end
local PRT = CreatePart(3, Weapon, "Metal", 0, 0, "Mid gray", "Watch", VT(0,0.15,0.15)*SIZE,false)
PRT.Color = C3(0,0,0)
local MSH = IT("BlockMesh",PRT)
MSH.Scale = VT(0.4,1,1)
local WATCH1 = CreateWeldOrSnapOrMotor("Weld", RightArm, RightArm, PRT, CF(0,-0.5*SIZE,0) * ANGLES(RAD(90), RAD(0), RAD(0)), CF(0, -0.49*SIZE, 0) * CF(0, 0, -0.075*SIZE))
local PRT = CreatePart(3, Weapon, "Metal", 0, 0, "Mid gray", "Watch", VT(0,0.15,0.15/1.5)*SIZE,false)
PRT.Color = C3(0,0,0)
local MSH = IT("BlockMesh",PRT)
MSH.Scale = VT(0.4,1,1)
local WATCH2 = CreateWeldOrSnapOrMotor("Weld", RightArm, RightArm, PRT, CF(0,-0.5*SIZE,0) * ANGLES(RAD(90), RAD(0), RAD(0)), CF(0, -0.49*SIZE, 0) * CF(0, 0, -(0.075/1.5)*SIZE))
coroutine.resume(coroutine.create(function()
	while true do
		Swait()
		CLOCKLOOP = CLOCKLOOP - 1*CLOCKSPEED
		WATCH1.C0 = Clerp(WATCH1.C0, CF(0,-0.5*SIZE,0) * ANGLES(RAD(90), RAD(CLOCKLOOP*5), RAD(0)), 1 / Animation_Speed)
		WATCH2.C0 = Clerp(WATCH2.C0, CF(0,-0.5*SIZE,0) * ANGLES(RAD(90), RAD(CLOCKLOOP*5/2), RAD(0)), 1 / Animation_Speed)
		if CLOCKLOOP <= -150 then
			if VALUE1 == false then
				CLOCKLOOP = 0
				WACKYEFFECT({Time = 15, EffectType = "Sphere", Size = VT(0.45,0.11,0.45)*SIZE, Size2 = VT(3,3,3), Transparency = 0, Transparency2 = 1, CFrame = RING.CFrame, MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = C3(159/255, 111/255, 183/255), SoundID = 743521450, SoundPitch = 1.2, SoundVolume = 4})
				local HITFLOOR,HITPOS = Raycast(RootPart.Position, (CF(RootPart.Position, RootPart.Position + VT(0, -1, 0))).lookVector, 25*SIZE, Character)
				ApplyAoE(HITPOS,10,15,45,75,false)
				WACKYEFFECT({Time = 15, EffectType = "Wave", Size = VT(0.45,0.11,0.45)*SIZE, Size2 = VT(15,2,15), Transparency = 0, Transparency2 = 1, CFrame = CF(HITPOS), MoveToPos = nil, RotationX = 0, RotationY = -15, RotationZ = 0, Material = "Neon", Color = C3(159/255, 111/255, 183/255), SoundID = nil, SoundPitch = 0.5, SoundVolume = 6})
				WACKYEFFECT({Time = 15, EffectType = "Wave", Size = VT(0.45,0.11,0.45)*SIZE, Size2 = VT(12,3,12), Transparency = 0, Transparency2 = 1, CFrame = CF(HITPOS), MoveToPos = nil, RotationX = 0, RotationY = 15, RotationZ = 0, Material = "Neon", Color = C3(159/255, 111/255, 183/255), SoundID = nil, SoundPitch = 0.5, SoundVolume = 6})
				if CLOCKTARGET ~= nil then
					CLOCKTARGET.Health = CLOCKTARGET.Health - 20
					if CLOCKTARGET.Torso ~= nil then
						CLOCKTARGET.Torso.CFrame = CLOCKTARGET.Torso.CFrame * ANGLES(RAD(MRANDOM(0,360)), RAD(MRANDOM(0,360)), RAD(MRANDOM(0,360)))
					end
					if CLOCKTARGET.Health == 0 then
						CLOCKTARGET = nil
					end
				end
			end
		end
	end
end))

for _, c in pairs(Weapon:GetChildren()) do
	if c.ClassName == "Part" then
		c.CustomPhysicalProperties = PhysicalProperties.new(0, 0, 0, 0, 0)
	end
end

Neck.Name = "Weld"
RootJoint.Name = "Weld"
RightShoulder.Name = "Weld"
LeftShoulder.Name = "Weld"
RightHip.Name = "Weld"
LeftHip.Name = "Weld"

local SKILLTEXTCOLOR = C3(159/255, 111/255, 183/255)
local SKILLFONT = "Fantasy"
local SKILLTEXTSIZE = 7

Weapon.Parent = Character
Humanoid.Parent = Character

Humanoid.Died:connect(function()
	ATTACK = true
end)

local SKILL1FRAME = CreateFrame(WEAPONGUI, 1, 2, UD2(0.23-.20, 0, 0.84, 0), UD2(0.26, 0, 0.07, 0), C3(0,0,0), C3(0, 0, 0), "Skill 1 Frame")
local SKILL2FRAME = CreateFrame(WEAPONGUI, 1, 2, UD2(0.50+.20, 0, 0.84, 0), UD2(0.26, 0, 0.07, 0), C3(0,0,0), C3(0, 0, 0), "Skill 2 Frame")
local SKILL3FRAME = CreateFrame(WEAPONGUI, 1, 2, UD2(0.23, 0, 0.90, 0), UD2(0.26, 0, 0.07, 0), C3(0,0,0), C3(0, 0, 0), "Skill 3 Frame")
local SKILL4FRAME = CreateFrame(WEAPONGUI, 1, 2, UD2(0.50, 0, 0.90, 0), UD2(0.26, 0, 0.07, 0), C3(0,0,0), C3(0, 0, 0), "Skill 4 Frame")
local SKILL5FRAME = CreateFrame(WEAPONGUI, 1, 2, UD2(0.365, 0, 0.86, 0), UD2(0.26, 0, 0.07, 0), C3(0,0,0), C3(0, 0, 0), "Skill 5 Frame")

local SKILL1TEXT = CreateLabel(SKILL1FRAME, "[Z] Magic Missiles", SKILLTEXTCOLOR, SKILLTEXTSIZE, SKILLFONT, 0, 2, 0, "Text 1")
local SKILL2TEXT = CreateLabel(SKILL2FRAME, "[B] Times up", SKILLTEXTCOLOR, SKILLTEXTSIZE, SKILLFONT, 0, 2, 0, "Text 2")
local SKILL3TEXT = CreateLabel(SKILL3FRAME, "[C] Chained Punch", SKILLTEXTCOLOR, SKILLTEXTSIZE, SKILLFONT, 0, 2, 0, "Text 3")
local SKILL4TEXT = CreateLabel(SKILL4FRAME, "[V] Warp Meteor", SKILLTEXTCOLOR, SKILLTEXTSIZE, SKILLFONT, 0, 2, 0, "Text 4")
local SKILL5TEXT = CreateLabel(SKILL5FRAME, "[X] Pandora's Box", SKILLTEXTCOLOR, SKILLTEXTSIZE, SKILLFONT, 0, 2, 0, "Text 5")

--//=================================\\
--||			DAMAGING
--\\=================================//

function ApplyDamage(Humanoid,Damage,TorsoPart)
end

function ApplyAoE(POSITION,RANGE,MINDMG,MAXDMG,FLING,INSTAKILL)
end

--//=================================\\
--||	ATTACK FUNCTIONS AND STUFF
--\\=================================//

function MagicMissiles()
	ATTACK = true
	Rooted = true
	local SELECTING = true
	local SPOTS = {}
	coroutine.resume(coroutine.create(function()
		local LOOP = 0
		repeat
			LOOP = LOOP + 1
			Swait()
			if LOOP >= 10 then
				LOOP = 0
				for i = 1, #SPOTS do
					if SPOTS[i] ~= nil then
						WACKYEFFECT({Time = 15, EffectType = "Wave", Size = VT(0,0,0)*SIZE, Size2 = VT(8,2,8), Transparency = 0, Transparency2 = 1, CFrame = SPOTS[i], MoveToPos = nil, RotationX = 0, RotationY = -15, RotationZ = 0, Material = "Neon", Color = C3(159/255, 111/255, 183/255), SoundID = nil, SoundPitch = 0.5, SoundVolume = 6})
						WACKYEFFECT({Time = 15, EffectType = "Wave", Size = VT(0,0,0)*SIZE, Size2 = VT(6,3,6), Transparency = 0, Transparency2 = 1, CFrame = SPOTS[i], MoveToPos = nil, RotationX = 0, RotationY = 15, RotationZ = 0, Material = "Neon", Color = C3(159/255, 111/255, 183/255), SoundID = nil, SoundPitch = 0.5, SoundVolume = 6})
					end
				end
			end
			RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0 - 0.04 * SIN(SINE / 24)*SIZE, 0 + 0.04 * SIN(SINE / 12)*SIZE, 0 + 0.05*SIZE * COS(SINE / 12)) * ANGLES(RAD(0 - 2.5 * SIN(SINE / 12)), RAD(0 - 2.5 * SIN(SINE / 24)), RAD(0)), 1 / Animation_Speed)
			Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1.1*SIZE) - 1)) * ANGLES(RAD(-25 - 4 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
			RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.35*SIZE, 0.65*SIZE, 0*SIZE) * ANGLES(RAD(115), RAD(45), RAD(35)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
			LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.25*SIZE, 0.5*SIZE, 0.5*SIZE) * ANGLES(RAD(-35), RAD(25 - 2.5 * SIN(SINE / 12)), RAD(55 - 2.5 * SIN(SINE / 12))) * LEFTSHOULDERC0, 1 / Animation_Speed)
			RightHip.C0 = Clerp(RightHip.C0, CF(1*SIZE, -1*SIZE + 0.06 * SIN(SINE / 24) - 0.05*SIZE * COS(SINE / 12), -0.01*SIZE) * ANGLES(RAD(0 - 2.5 * SIN(SINE / 12)), RAD(75), RAD(0)) * ANGLES(RAD(-2 - 2.5 * SIN(SINE / 24)), RAD(0), RAD(0)), 1 / Animation_Speed)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-1*SIZE, -1*SIZE - 0.06 * SIN(SINE / 24) - 0.05*SIZE * COS(SINE / 12), -0.01*SIZE) * ANGLES(RAD(0 - 2.5 * SIN(SINE / 12)), RAD(-75), RAD(0)) * ANGLES(RAD(-2 + 2.5 * SIN(SINE / 24)), RAD(0), RAD(0)), 1 / Animation_Speed)
		until SELECTING == false
		Rooted = false
		repeat
			LOOP = LOOP + 1
			Swait()
			if LOOP >= 10 then
				LOOP = 0
				for i = 1, #SPOTS do
					if SPOTS[i] ~= nil then
						WACKYEFFECT({Time = 15, EffectType = "Wave", Size = VT(0,0,0)*SIZE, Size2 = VT(8,2,8), Transparency = 0, Transparency2 = 1, CFrame = SPOTS[i], MoveToPos = nil, RotationX = 0, RotationY = -15, RotationZ = 0, Material = "Neon", Color = C3(159/255, 111/255, 183/255), SoundID = nil, SoundPitch = 0.5, SoundVolume = 6})
						WACKYEFFECT({Time = 15, EffectType = "Wave", Size = VT(0,0,0)*SIZE, Size2 = VT(6,3,6), Transparency = 0, Transparency2 = 1, CFrame = SPOTS[i], MoveToPos = nil, RotationX = 0, RotationY = 15, RotationZ = 0, Material = "Neon", Color = C3(159/255, 111/255, 183/255), SoundID = nil, SoundPitch = 0.5, SoundVolume = 6})
					end
				end
			end
			RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0 - 0.04 * SIN(SINE / 24)*SIZE, 0 + 0.04 * SIN(SINE / 12)*SIZE, 0 + 0.05*SIZE * COS(SINE / 12)) * ANGLES(RAD(0 - 2.5 * SIN(SINE / 12)), RAD(0 - 2.5 * SIN(SINE / 24)), RAD(0)), 1 / Animation_Speed)
			Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1.1*SIZE) - 1)) * ANGLES(RAD(0 - 4 * SIN(SINE / 12)), RAD(25), RAD(0)), 1 / Animation_Speed)
			RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.35*SIZE, 0.65*SIZE, 0*SIZE) * ANGLES(RAD(90), RAD(0), RAD(35)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
			LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.25*SIZE, 0.5*SIZE, 0.5*SIZE) * ANGLES(RAD(-35), RAD(25 - 2.5 * SIN(SINE / 12)), RAD(55 - 2.5 * SIN(SINE / 12))) * LEFTSHOULDERC0, 1 / Animation_Speed)
			RightHip.C0 = Clerp(RightHip.C0, CF(1*SIZE, -1*SIZE + 0.06 * SIN(SINE / 24) - 0.05*SIZE * COS(SINE / 12), -0.01*SIZE) * ANGLES(RAD(0 - 2.5 * SIN(SINE / 12)), RAD(75), RAD(0)) * ANGLES(RAD(-2 - 2.5 * SIN(SINE / 24)), RAD(0), RAD(0)), 1 / Animation_Speed)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-1*SIZE, -1*SIZE - 0.06 * SIN(SINE / 24) - 0.05*SIZE * COS(SINE / 12), -0.01*SIZE) * ANGLES(RAD(0 - 2.5 * SIN(SINE / 12)), RAD(-75), RAD(0)) * ANGLES(RAD(-2 + 2.5 * SIN(SINE / 24)), RAD(0), RAD(0)), 1 / Animation_Speed)
		until ATTACK == false
	end))
	repeat
		repeat Swait() until HOLD == true
			local DIST = (RootPart.Position - Mouse.Hit.p).Magnitude
			if DIST > 65 then
				DIST = 65
			end
			local RAY,RAYPOS = Raycast(RootPart.Position, (CF(RootPart.Position, Mouse.Hit.p)).lookVector, DIST, workspace)	
			local HITFLOOR,HITPOS,NORMAL = Raycast(RAYPOS+VT(0,1,0), (CF(RAYPOS, RAYPOS + VT(0, -1, 0))).lookVector, 25*SIZE, Character)	
			if HITFLOOR ~= nil then
				table.insert(SPOTS,CF(HITPOS,HITPOS+NORMAL) * ANGLES(RAD(90), RAD(0), RAD(0)))
				WACKYEFFECT({Time = 15, EffectType = "Wave", Size = VT(0,0,0)*SIZE, Size2 = VT(6,2,6), Transparency = 0, Transparency2 = 1, CFrame = RightArm.CFrame*CF(0,-1.2,0) * ANGLES(RAD(180), RAD(0), RAD(0)), MoveToPos = nil, RotationX = 0, RotationY = -15, RotationZ = 0, Material = "Neon", Color = C3(159/255, 111/255, 183/255), SoundID = 90655239, SoundPitch = 1, SoundVolume = 6})
				WACKYEFFECT({Time = 15, EffectType = "Wave", Size = VT(0,0,0)*SIZE, Size2 = VT(4,3,4), Transparency = 0, Transparency2 = 1, CFrame = RightArm.CFrame*CF(0,-1.2,0) * ANGLES(RAD(180), RAD(0), RAD(0)), MoveToPos = nil, RotationX = 0, RotationY = 15, RotationZ = 0, Material = "Neon", Color = C3(159/255, 111/255, 183/255), SoundID = nil, SoundPitch = 0.5, SoundVolume = 6})
			end
		repeat Swait() until HOLD == false
	until #SPOTS == 5
	SELECTING = false
	for i = 1, #SPOTS do
		if SPOTS[i] ~= nil then
			local POS = SPOTS[i]
			coroutine.resume(coroutine.create(function()
				local MISSILE = IT("Model",Effects)
				MISSILE.Name = "Missile"
				local BASEPART = CreatePart(3, MISSILE, "Neon", 0, 1, "Alder", "Part", VT(2,2,2))
				MakeForm(BASEPART,"Cyl")
				MISSILE.PrimaryPart = BASEPART
				BASEPART.CFrame = POS*CF(0,-30*3,0)
				local HEAD = CreatePart(3, MISSILE, "Neon", 0, 1, "Alder", "Part", VT(2,4,2))
				MakeForm(HEAD,"Ball")
				HEAD.CFrame = BASEPART.CFrame*CF(0,1,0)
				local TAIL = CreatePart(3, MISSILE, "Neon", 0, 1, "Alder", "Part", VT(2.5,0.1,2.5))
				MakeForm(TAIL,"Cyl")
				TAIL.CFrame = BASEPART.CFrame*CF(0,-1,0)
				for i = 1, 10 do
					Swait()
					for _, c in pairs(MISSILE:GetChildren()) do
						if c.ClassName == "Part" then
							c.Transparency = c.Transparency - 1/10
						end
					end
				end
				for i = 1, 15*1.5 do
					Swait()
					MISSILE:SetPrimaryPartCFrame(BASEPART.CFrame*CF(0,1.35*3,0))
				end
				ApplyAoE(BASEPART.CFrame.p,20,35,45,75,false)
				WACKYEFFECT({Time = 25, EffectType = "Sphere", Size = VT(0,0,0), Size2 = VT(75,1,75), Transparency = 0.5, Transparency2 = 1, CFrame = BASEPART.CFrame, MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = C3(159/255, 111/255, 183/255), SoundID = nil, SoundPitch = 1.2, SoundVolume = 4})
				WACKYEFFECT({Time = 45, EffectType = "Sphere", Size = VT(0,0,0), Size2 = VT(35,35,35), Transparency = 0, Transparency2 = 1, CFrame = BASEPART.CFrame, MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = C3(159/255, 111/255, 183/255), SoundID = 165970126, SoundPitch = MRANDOM(13,15)/10, SoundVolume = 4})
				WACKYEFFECT({Time = 45, EffectType = "Wave", Size = VT(0,0,0)*SIZE, Size2 = VT(22,2,22), Transparency = 0, Transparency2 = 1, CFrame = POS * ANGLES(RAD(180), RAD(0), RAD(0)), MoveToPos = nil, RotationX = 0, RotationY = -15, RotationZ = 0, Material = "Neon", Color = C3(159/255, 111/255, 183/255), SoundID = nil, SoundPitch = 0.5, SoundVolume = 6})
				WACKYEFFECT({Time = 45, EffectType = "Wave", Size = VT(0,0,0)*SIZE, Size2 = VT(20,3,20), Transparency = 0, Transparency2 = 1, CFrame = POS * ANGLES(RAD(180), RAD(0), RAD(0)), MoveToPos = nil, RotationX = 0, RotationY = 15, RotationZ = 0, Material = "Neon", Color = C3(159/255, 111/255, 183/255), SoundID = nil, SoundPitch = 0.5, SoundVolume = 6})
				MISSILE:remove()
			end))
		end
	end
	wait(0.6)
	ATTACK = false
	Rooted = false
end

function TimesUp()
	CLOCKTARGET = nil
	if Mouse.Target.Parent ~= Character and Mouse.Target.Parent.Parent ~= Character and Mouse.Target.Parent:FindFirstChildOfClass("Humanoid") ~= nil then
		local HUM = Mouse.Target.Parent:FindFirstChildOfClass("Humanoid")
		local TORSO = HUM.Parent:FindFirstChild("Torso") or HUM.Parent:FindFirstChild("UpperTorso")
		if TORSO then
			ATTACK = true
			Rooted = false
			coroutine.resume(coroutine.create(function()
				repeat
					Swait()
					RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0 - 0.04 * SIN(SINE / 24)*SIZE, 0 + 0.04 * SIN(SINE / 12)*SIZE, 0 + 0.05*SIZE * COS(SINE / 12)) * ANGLES(RAD(0 - 2.5 * SIN(SINE / 12)), RAD(0 - 2.5 * SIN(SINE / 24)), RAD(0)), 1 / Animation_Speed)
					Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1.1*SIZE) - 1)) * ANGLES(RAD(25 - 4 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
					RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.35*SIZE, 0.5*SIZE, -0.2*SIZE) * ANGLES(RAD(75), RAD(45), RAD(0)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
					LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.25*SIZE, 0.5*SIZE, 0.5*SIZE) * ANGLES(RAD(-35), RAD(25 - 2.5 * SIN(SINE / 12)), RAD(55 - 2.5 * SIN(SINE / 12))) * LEFTSHOULDERC0, 1 / Animation_Speed)
					RightHip.C0 = Clerp(RightHip.C0, CF(1*SIZE, -1*SIZE + 0.06 * SIN(SINE / 24) - 0.05*SIZE * COS(SINE / 12), -0.01*SIZE) * ANGLES(RAD(0 - 2.5 * SIN(SINE / 12)), RAD(75), RAD(0)) * ANGLES(RAD(-2 - 2.5 * SIN(SINE / 24)), RAD(0), RAD(0)), 1 / Animation_Speed)
					LeftHip.C0 = Clerp(LeftHip.C0, CF(-1*SIZE, -1*SIZE - 0.06 * SIN(SINE / 24) - 0.05*SIZE * COS(SINE / 12), -0.01*SIZE) * ANGLES(RAD(0 - 2.5 * SIN(SINE / 12)), RAD(-75), RAD(0)) * ANGLES(RAD(-2 + 2.5 * SIN(SINE / 24)), RAD(0), RAD(0)), 1 / Animation_Speed)
				until ATTACK == false
			end))
			if Effects:FindFirstChild("NeonDoll") then
				repeat Swait() until Effects:FindFirstChild("NeonDoll") == nil
			end
			wait(0.5)
			local FAKECHARACTER = IT("Model",Effects)
			FAKECHARACTER.Name = "NeonDoll"
			local TORS = CreatePart(3, FAKECHARACTER, "Neon", 0, 1, "Alder", "Part", VT(0.3,0.3,0.15),false)
			CreateWeldOrSnapOrMotor("Weld", RING, RING, TORS, CF(0,0.6,0), CF(0,0,0))
			local LEG = CreatePart(3, FAKECHARACTER, "Neon", 0, 1, "Alder", "Part", VT(0.15,0.3,0.15),false)
			CreateWeldOrSnapOrMotor("Weld", TORS, TORS, LEG, CF(0.15/2,-0.15,0) * ANGLES(RAD(0), RAD(0), RAD(15)), CF(0,0.15,0))
			local LEG = CreatePart(3, FAKECHARACTER, "Neon", 0, 1, "Alder", "Part", VT(0.15,0.3,0.15),false)
			CreateWeldOrSnapOrMotor("Weld", TORS, TORS, LEG, CF(-0.15/2,-0.15,0) * ANGLES(RAD(0), RAD(0), RAD(-15)), CF(0,0.15,0))
			local ARM = CreatePart(3, FAKECHARACTER, "Neon", 0, 1, "Alder", "Part", VT(0.15,0.3,0.15),false)
			CreateWeldOrSnapOrMotor("Weld", TORS, TORS, ARM, CF(0.15,0.15/2,0) * ANGLES(RAD(0), RAD(0), RAD(90)), CF(0,0.15,0))
			local ARM = CreatePart(3, FAKECHARACTER, "Neon", 0, 1, "Alder", "Part", VT(0.15,0.3,0.15),false)
			CreateWeldOrSnapOrMotor("Weld", TORS, TORS, ARM, CF(-0.15,0.15/2,0) * ANGLES(RAD(0), RAD(0), RAD(-90)), CF(0,0.15,0))
			local HEAD = CreatePart(3, FAKECHARACTER, "Neon", 0, 1, "Alder", "Part", VT(0.15,0.15,0.15),false)
			CreateWeldOrSnapOrMotor("Weld", TORS, TORS, HEAD, CF(0,0.225,0), CF(0,0,0))
			CreateSound(201858045, TORS, 5, 0.4, false)
			for i = 1, 150 do
				Swait()
				CLOCKSPEED = 6
				for _, c in pairs(FAKECHARACTER:GetChildren()) do
					if c.ClassName == "Part" then
						c.Transparency = c.Transparency - 0.5/150
					end
				end
			end
			CLOCKTARGET = HUM
			coroutine.resume(coroutine.create(function()
				repeat Swait() CLOCKSPEED = 2 until CLOCKTARGET == nil
				for i = 1, 25 do
					Swait()
					for _, c in pairs(FAKECHARACTER:GetChildren()) do
						if c.ClassName == "Part" then
							c.Transparency = c.Transparency + 0.5/25
						end
					end
				end
				CLOCKSPEED = 1
				FAKECHARACTER:remove()
			end))
			wait(0.5)
			ATTACK = false
			Rooted = false
		end
	end
end

function ChainPunch()
	ATTACK = true
	Rooted = false
	local GYRO = IT("BodyGyro",RootPart)
	GYRO.D = 25
	GYRO.P = 2000
	GYRO.MaxTorque = VT(0,40000,0)
	GYRO.cframe = CF(RootPart.Position,Mouse.Hit.p)
	repeat
		Swait()
		GYRO.cframe = CF(RootPart.Position,Mouse.Hit.p)
		RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0 - 0.04 * SIN(SINE / 24)*SIZE, 0 + 0.04 * SIN(SINE / 12)*SIZE, 0 + 0.05*SIZE * COS(SINE / 12)) * ANGLES(RAD(0 - 2.5 * SIN(SINE / 12)), RAD(0 - 2.5 * SIN(SINE / 24)), RAD(0)), 1 / Animation_Speed)
		Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1.1*SIZE) - 1)) * ANGLES(RAD(0 - 4 * SIN(SINE / 12)), RAD(25), RAD(0)), 1 / Animation_Speed)
		RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.35*SIZE, 0.65*SIZE, 0*SIZE) * ANGLES(RAD(90), RAD(0), RAD(5)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
		LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.25*SIZE, 0.5*SIZE, 0.5*SIZE) * ANGLES(RAD(-35), RAD(25 - 2.5 * SIN(SINE / 12)), RAD(55 - 2.5 * SIN(SINE / 12))) * LEFTSHOULDERC0, 1 / Animation_Speed)
		RightHip.C0 = Clerp(RightHip.C0, CF(1*SIZE, -1*SIZE + 0.06 * SIN(SINE / 24) - 0.05*SIZE * COS(SINE / 12), -0.01*SIZE) * ANGLES(RAD(0 - 2.5 * SIN(SINE / 12)), RAD(75), RAD(0)) * ANGLES(RAD(-2 - 2.5 * SIN(SINE / 24)), RAD(0), RAD(0)), 1 / Animation_Speed)
		LeftHip.C0 = Clerp(LeftHip.C0, CF(-1*SIZE, -1*SIZE - 0.06 * SIN(SINE / 24) - 0.05*SIZE * COS(SINE / 12), -0.01*SIZE) * ANGLES(RAD(0 - 2.5 * SIN(SINE / 12)), RAD(-75), RAD(0)) * ANGLES(RAD(-2 + 2.5 * SIN(SINE / 24)), RAD(0), RAD(0)), 1 / Animation_Speed)
	until HOLD == true
	local POS = Mouse.Hit.p
	local CHAINS = false
	local CHAINLINKS = {}
	local A = IT("Attachment",RightArm)
	A.Position = VT(1,-1,0)*SIZE
	A.Orientation = VT(-90, -89.982, 0)
	local B = IT("Attachment",RightArm)
	B.Position = VT(-1,-1,0)*SIZE
	B.Orientation = VT(-90, 89.988, 0)
	local C = IT("Attachment",RightArm)
	C.Position = VT(0.5,-1.3,0)*SIZE
	C.Orientation = VT(-90, -89.982, 0)
	local D = IT("Attachment",RightArm)
	D.Position = VT(-0.5,-1.3,0)*SIZE
	D.Orientation = VT(-90, 89.988, 0)
	local LIGHT = IT("Attachment",RightArm)
	LIGHT.Position = VT(0,-1,0)*SIZE
	local LIGHT2 = IT("PointLight",LIGHT)
	LIGHT2.Range = 7
	LIGHT2.Brightness = 5
	LIGHT2.Color = SKILLTEXTCOLOR
	for i = 1, 2 do
		local TWIST = -2
		local START = A
		local END = B
		if i == 1 then
			START = B
			END = A
		end
		local ChainLink = IT("Beam",Torso)
		ChainLink.Texture = "rbxassetid://73042633"
		ChainLink.Color = ColorSequence.new(SKILLTEXTCOLOR)
		ChainLink.TextureSpeed = 1
		ChainLink.Width0 = 1
		ChainLink.Width1 = 1
		ChainLink.TextureLength = 2.5
		ChainLink.Attachment0 = START
		ChainLink.Attachment1 = END
		ChainLink.CurveSize0 = TWIST
		ChainLink.CurveSize1 = TWIST
		--ChainLink.FaceCamera = true
		ChainLink.Segments = 45
		ChainLink.Transparency = NumberSequence.new(1)
		table.insert(CHAINLINKS,ChainLink)
	end
	for i = 1, 2 do
		local TWIST = -1
		local START = C
		local END = D
		if i == 1 then
			START = D
			END = C
		end
		local ChainLink = IT("Beam",Torso)
		ChainLink.Texture = "rbxassetid://73042633"
		ChainLink.Color = ColorSequence.new(SKILLTEXTCOLOR)
		ChainLink.TextureSpeed = 1
		ChainLink.Width0 = 1
		ChainLink.Width1 = 1
		ChainLink.TextureLength = 5
		ChainLink.Attachment0 = START
		ChainLink.Attachment1 = END
		ChainLink.CurveSize0 = TWIST
		ChainLink.CurveSize1 = TWIST
		--ChainLink.FaceCamera = true
		ChainLink.Segments = 25
		ChainLink.LightEmission = 0.5
		ChainLink.Transparency = NumberSequence.new(1)
		table.insert(CHAINLINKS,ChainLink)
	end
	coroutine.resume(coroutine.create(function()
		repeat
			Swait()
			RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0*SIZE, 0*SIZE, 0*SIZE + 0.05*SIZE * COS(SINE / 12)) * ANGLES(RAD(0), RAD(0), RAD(-45)), 1 / Animation_Speed)
			Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1.1*SIZE) - 1)) * ANGLES(RAD(0 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(45)), 0.15 / Animation_Speed)
			RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.35*SIZE, 0.65*SIZE, 0.2*SIZE) * ANGLES(RAD(60), RAD(0), RAD(-25)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
			LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.25*SIZE, 0.5*SIZE, 0.5*SIZE) * ANGLES(RAD(-35), RAD(25 - 2.5 * SIN(SINE / 12)), RAD(55 - 2.5 * SIN(SINE / 12))) * LEFTSHOULDERC0, 1 / Animation_Speed)
			RightHip.C0 = Clerp(RightHip.C0, CF(1*SIZE, -1*SIZE - 0.05*SIZE * COS(SINE / 12), -0.01*SIZE) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 1 / Animation_Speed)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-1*SIZE, -1*SIZE - 0.05*SIZE * COS(SINE / 12), -0.01*SIZE) * ANGLES(RAD(0), RAD(-75), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 1 / Animation_Speed)
		until CHAINS == true
		repeat
			Swait()
			RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0*SIZE, 0*SIZE, 0*SIZE + 0.05*SIZE * COS(SINE / 12)) * ANGLES(RAD(0), RAD(0), RAD(45)), 1 / Animation_Speed)
			Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1.1*SIZE) - 1)) * ANGLES(RAD(0 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(-45)), 1 / Animation_Speed)
			RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.35*SIZE, 0.65*SIZE, -0.2*SIZE) * ANGLES(RAD(90), RAD(0), RAD(45)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
			LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.25*SIZE, 0.5*SIZE, 0.5*SIZE) * ANGLES(RAD(-35), RAD(25 - 2.5 * SIN(SINE / 12)), RAD(55 - 2.5 * SIN(SINE / 12))) * LEFTSHOULDERC0, 1 / Animation_Speed)
			RightHip.C0 = Clerp(RightHip.C0, CF(1*SIZE, -1*SIZE - 0.05*SIZE * COS(SINE / 12), -0.01*SIZE) * ANGLES(RAD(0), RAD(75), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 1 / Animation_Speed)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-1*SIZE, -1*SIZE - 0.05*SIZE * COS(SINE / 12), -0.01*SIZE) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 1 / Animation_Speed)
		until ATTACK == false
		for e = 1, 15 do
			Swait()
			for i = 1, #CHAINLINKS do
				CHAINLINKS[i].Transparency = NumberSequence.new((e/15))
			end
		end
		A:remove()
		B:remove()
		C:remove()
		D:remove()
	end))
	CreateSound(233856115, RightArm, 5, 1.2, false)
	for e = 1, 15 do
		Swait()
		for i = 1, #CHAINLINKS do
			CHAINLINKS[i].Transparency = NumberSequence.new(1-(e/15))
		end
	end
	CHAINS = true
	Rooted = true
	wait(0.25)
	local FIST = CreatePart(3, Effects, "Neon", 0, 0.5, "Alder", "Part", VT(2,2,2))
	FIST.Color = C3(1, 215/255, 1)
	FIST.CFrame = CF(RightArm.CFrame*CF(0,-1.3*SIZE,0).p,POS) * ANGLES(RAD(90), RAD(0), RAD(0)) 
	local LIGHT3 = IT("PointLight",FIST)
	LIGHT3.Range = 7
	LIGHT3.Brightness = 5
	LIGHT3.Color = SKILLTEXTCOLOR
	CreateMesh("SpecialMesh", FIST, "FileMesh", "90718752", "", VT(10,10,10), VT(0,0,0))
	local FISTA = IT("Attachment",FIST)
	FISTA.Position = VT(0.062, 0.977, 0)
	local ChainLink = IT("Beam",Torso)
	ChainLink.Texture = "rbxassetid://73042633"
	ChainLink.Color = ColorSequence.new(SKILLTEXTCOLOR)
	ChainLink.TextureSpeed = 0
	ChainLink.Width0 = 3
	ChainLink.Width1 = 3
	ChainLink.TextureLength = 12
	ChainLink.Attachment0 = LIGHT
	ChainLink.Attachment1 = FISTA
	ChainLink.FaceCamera = true
	ChainLink.Segments = 45
	ChainLink.LightEmission = 0.5
	ChainLink.Transparency = NumberSequence.new(0.25)
	local FISTSOUND = CreateSound(288641686, FIST, 5, 1.2, false)
	for i = 1, 85 do
		Swait()
		FIST.CFrame = FIST.CFrame*CF(0,-2,0)
		ChainLink.TextureLength = 12+(i*2)
		ApplyAoE(FIST.Position,10,1,5,75,false)
		WACKYEFFECT({Time = 5, EffectType = "Wave", Size = VT(5,0,5)*SIZE, Size2 = VT(15,1,15), Transparency = 0.5, Transparency2 = 1, CFrame = FIST.CFrame*CF(0,-1,0) * ANGLES(RAD(0), RAD(i*15), RAD(0)), MoveToPos = nil, RotationX = 0, RotationY = -5, RotationZ = 0, Material = "Neon", Color = C3(159/255, 111/255, 183/255), SoundID = nil, SoundPitch = 0.5, SoundVolume = 6})
		local HITFLOOR = Raycast(FIST.Position, (CF(FIST.Position, FIST.CFrame*CF(0,-1,0).p)).lookVector, 2.1, Character)
		if HITFLOOR ~= nil then
			HITFLOOR:BreakJoints()
			coroutine.resume(coroutine.create(function()
				for i = 1, 15 do
					Swait()
					FISTSOUND.Volume = FISTSOUND.Volume - 0.15
					ApplyAoE(FIST.Position,10+(i*2),1.5,7,5,false)
					WACKYEFFECT({Time = 15, EffectType = "Wave", Size = VT(5,0,5)*SIZE, Size2 = VT(35,3,35), Transparency = 0.5, Transparency2 = 1, CFrame = FIST.CFrame * ANGLES(RAD(MRANDOM(0,360)), RAD(MRANDOM(0,360)), RAD(MRANDOM(0,360))), MoveToPos = nil, RotationX = 0, RotationY = -5, RotationZ = 0, Material = "Neon", Color = C3(159/255, 111/255, 183/255), SoundID = nil, SoundPitch = 0.5, SoundVolume = 6})
				end
			end))
			break
		end
	end
	coroutine.resume(coroutine.create(function()
		for i = 1, 50 do
			Swait()
			FIST.Transparency = FIST.Transparency + 0.5/50
			LIGHT3.Range = LIGHT3.Range - 7/50
		end
		FIST:remove()
	end))
	LIGHT:remove()
	GYRO:remove()
	ATTACK = false
	Rooted = false
end

function WarpMeteor()
	local DIST = (RootPart.Position - Mouse.Hit.p).Magnitude
	if DIST > 180 then
		DIST = 180
	end
	local RAY,RAYPOS = Raycast(RootPart.Position, (CF(RootPart.Position, Mouse.Hit.p)).lookVector, DIST, workspace)	
	local HITFLOOR,HITPOS,NORMAL = Raycast(RAYPOS+VT(0,45,0), (CF(RAYPOS, RAYPOS + VT(0, -1, 0))).lookVector, 75*SIZE, Character)
	if HITFLOOR then
		local POS = HITPOS	
		ATTACK = true
		Rooted = true
		local WARPED = false
		local SMASHED = false
		local HITFLOOR,HITPOS,NORMAL = Raycast(RootPart.Position+VT(0,1,0), (CF(RAYPOS, RAYPOS + VT(0, -1, 0))).lookVector, 25*SIZE, Character)
		coroutine.resume(coroutine.create(function()
			repeat
				Swait()
				RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0 - 0.04 * SIN(SINE / 24)*SIZE, 0 + 0.04 * SIN(SINE / 12)*SIZE, 0 + 0.05*SIZE * COS(SINE / 12)) * ANGLES(RAD(0 - 2.5 * SIN(SINE / 12)), RAD(0 - 2.5 * SIN(SINE / 24)), RAD(0)), 1 / Animation_Speed)
				Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1.1*SIZE) - 1)) * ANGLES(RAD(25 - 4 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
				RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.25*SIZE, 0.5*SIZE, 0.5*SIZE) * ANGLES(RAD(-35), RAD(-25 + 2.5 * SIN(SINE / 12)), RAD(-55 + 2.5 * SIN(SINE / 12))) * RIGHTSHOULDERC0, 1 / Animation_Speed)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.25*SIZE, 0.5*SIZE, 0.5*SIZE) * ANGLES(RAD(-35), RAD(25 - 2.5 * SIN(SINE / 12)), RAD(55 - 2.5 * SIN(SINE / 12))) * LEFTSHOULDERC0, 1 / Animation_Speed)
				RightHip.C0 = Clerp(RightHip.C0, CF(1*SIZE, -1*SIZE + 0.06 * SIN(SINE / 24) - 0.05*SIZE * COS(SINE / 12), -0.01*SIZE) * ANGLES(RAD(0 - 2.5 * SIN(SINE / 12)), RAD(75), RAD(0)) * ANGLES(RAD(-2 - 2.5 * SIN(SINE / 24)), RAD(0), RAD(0)), 1 / Animation_Speed)
				LeftHip.C0 = Clerp(LeftHip.C0, CF(-1*SIZE, -1*SIZE - 0.06 * SIN(SINE / 24) - 0.05*SIZE * COS(SINE / 12), -0.01*SIZE) * ANGLES(RAD(0 - 2.5 * SIN(SINE / 12)), RAD(-75), RAD(0)) * ANGLES(RAD(-2 + 2.5 * SIN(SINE / 24)), RAD(0), RAD(0)), 1 / Animation_Speed)
			until WARPED == true
			repeat
				Swait()
				RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0 - 0.04 * SIN(SINE / 24)*SIZE, 0 + 0.04 * SIN(SINE / 12)*SIZE, 0 + 0.05*SIZE * COS(SINE / 12)) * ANGLES(RAD(0 - 2.5 * SIN(SINE / 12)), RAD(0 - 2.5 * SIN(SINE / 24)), RAD(0)), 1 / Animation_Speed)
				Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1.1*SIZE) - 1)) * ANGLES(RAD(25 - 4 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
				RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.25*SIZE, 0.5*SIZE, 0.5*SIZE) * ANGLES(RAD(-35), RAD(-25 + 2.5 * SIN(SINE / 12)), RAD(-55 + 2.5 * SIN(SINE / 12))) * RIGHTSHOULDERC0, 1 / Animation_Speed)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.25*SIZE, 0.5*SIZE, 0.5*SIZE) * ANGLES(RAD(-35), RAD(25 - 2.5 * SIN(SINE / 12)), RAD(55 - 2.5 * SIN(SINE / 12))) * LEFTSHOULDERC0, 1 / Animation_Speed)
				RightHip.C0 = Clerp(RightHip.C0, CF(1*SIZE, -0.5*SIZE + 0.06 * SIN(SINE / 24) - 0.1*SIZE * COS(SINE / 12), -0.5*SIZE) * ANGLES(RAD(0 - 2.5 * SIN(SINE / 12)), RAD(75), RAD(0)) * ANGLES(RAD(-2 - 2.5 * SIN(SINE / 24)), RAD(0), RAD(0)), 1 / Animation_Speed)
				LeftHip.C0 = Clerp(LeftHip.C0, CF(-1*SIZE, -1*SIZE - 0.06 * SIN(SINE / 24) - 0.1*SIZE * COS(SINE / 12), -0.01*SIZE) * ANGLES(RAD(0 - 2.5 * SIN(SINE / 12)), RAD(-75), RAD(0)) * ANGLES(RAD(-2 + 2.5 * SIN(SINE / 24)), RAD(0), RAD(0)), 1 / Animation_Speed)
			until SMASHED == true
			repeat
				Swait()
			RootJoint.C0 = Clerp(RootJoint.C0, ROOTC0 * CF(0*SIZE, 0*SIZE, 0*SIZE) * ANGLES(RAD(90), RAD(0), RAD(0)), 1 / Animation_Speed)
			Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0*SIZE, 0*SIZE, 0 + ((1.1*SIZE) - 1)) * ANGLES(RAD(-40), RAD(0), RAD(0)), 1 / Animation_Speed)
			RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5*SIZE, 0.5*SIZE, 0*SIZE) * ANGLES(RAD(170), RAD(-15), RAD(20)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
			LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5*SIZE, 0.5*SIZE, 0*SIZE) * ANGLES(RAD(170), RAD(15), RAD(-20)) * LEFTSHOULDERC0, 1 / Animation_Speed)
			RightHip.C0 = Clerp(RightHip.C0, CF(1*SIZE, -1*SIZE, -0.3*SIZE) * ANGLES(RAD(0), RAD(75), RAD(0)) * ANGLES(RAD(-5), RAD(0), RAD(-20)), 1 / Animation_Speed)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-1*SIZE, -1*SIZE, -0.3*SIZE) * ANGLES(RAD(0), RAD(-75), RAD(0)) * ANGLES(RAD(-5), RAD(0), RAD(0)), 1 / Animation_Speed)
			until ATTACK == false
		end))
		VALUE1 = true
		CreateSound(233856115, Torso, 5, 1.6, false)
		for i = 1, 25 do
			Swait()
			for _, c in pairs(Character:GetChildren()) do
				if c.ClassName == "Part" then
					c.Transparency = c.Transparency + 1/25
				end
			end
			for _, c in pairs(Weapon:GetChildren()) do
				if c.ClassName == "Part" then
					c.Transparency = c.Transparency + 1/25
				end
			end
		end
		UNANCHOR = false
		RootPart.Anchored = true
		RootPart.Velocity = VT(0,0,0)
		local ROOTPOS = RootPart.Position
		RootPart.CFrame = CF(POS+VT(0,300,0),VT(ROOTPOS.X,POS.Y+300,ROOTPOS.Z))
		WARPED = true
		for i = 1, 25 do
			Swait()
			for _, c in pairs(Character:GetChildren()) do
				if c.ClassName == "Part" then
					c.Transparency = c.Transparency - 1/25
				end
			end
			for _, c in pairs(Weapon:GetChildren()) do
				if c.ClassName == "Part" then
					c.Transparency = c.Transparency - 1/25
				end
			end
		end
		local SHELL = CreatePart(3, Effects, "Neon", 0, 1, "Alder", "Part", VT(0,0,0))
		SHELL.CFrame = RootPart.CFrame
		MakeForm(SHELL,"Ball")
		CreateSound(402981977, SHELL, 5, 1.6, false)
		for i = 1, 10 do
			Swait()
			SHELL.Transparency = SHELL.Transparency - 1/10
			SHELL.Size = SHELL.Size + VT(0.6,0.6,0.6)*1.8
		end
		for i = 1, math.ceil(75/2) do
			Swait()
			RootPart.CFrame = RootPart.CFrame*CF(0,-3.5*2,0)
			SHELL.CFrame = CF(RootPart.Position)
			WACKYEFFECT({Time = 5, EffectType = "Sphere", Size = SHELL.Size, Size2 = VT(5,3,5), Transparency = 0.5, Transparency2 = 1, CFrame = SHELL.CFrame, MoveToPos = SHELL.Position+VT(0,15,0), RotationX = 0, RotationY = -5, RotationZ = 0, Material = "Neon", Color = SHELL.Color, SoundID = nil, SoundPitch = 0.75, SoundVolume = 6})
		end
		RootPart.CFrame = CF(POS+VT(0,1,0),VT(ROOTPOS.X,HITPOS.Y+1,ROOTPOS.Z))
		SHELL.CFrame = CF(RootPart.Position)
		WACKYEFFECT({Time = 45, EffectType = "Sphere", Size = SHELL.Size, Size2 = VT(35,35,35)*4, Transparency = 0, Transparency2 = 1, CFrame = SHELL.CFrame, MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = SHELL.Color, SoundID = 165970126, SoundPitch = 0.75, SoundVolume = 6})
		WACKYEFFECT({Time = 55, EffectType = "Wave", Size = VT(SHELL.Size.X,5,SHELL.Size.Z), Size2 = VT(45,3,45)*3.8, Transparency = 0, Transparency2 = 1, CFrame = SHELL.CFrame, MoveToPos = nil, RotationX = 0, RotationY = -5, RotationZ = 0, Material = "Neon", Color = SHELL.Color, SoundID = nil, SoundPitch = 0.75, SoundVolume = 6})
		WACKYEFFECT({Time = 55, EffectType = "Wave", Size = VT(SHELL.Size.X,5,SHELL.Size.Z), Size2 = VT(45,3,45)*4, Transparency = 0, Transparency2 = 1, CFrame = SHELL.CFrame, MoveToPos = nil, RotationX = 0, RotationY = 5, RotationZ = 0, Material = "Neon", Color = SHELL.Color, SoundID = nil, SoundPitch = 0.75, SoundVolume = 6})
		for i = 1, 5 do
			WACKYEFFECT({Time = 35, EffectType = "Wave", Size = VT(5,0,5)*SIZE, Size2 = VT(35,3,35)*4, Transparency = 0.5, Transparency2 = 1, CFrame = RootPart.CFrame * ANGLES(RAD(MRANDOM(0,360)), RAD(MRANDOM(0,360)), RAD(MRANDOM(0,360))), MoveToPos = nil, RotationX = 0, RotationY = -5, RotationZ = 0, Material = "Neon", Color = C3(159/255, 111/255, 183/255), SoundID = nil, SoundPitch = 0.5, SoundVolume = 6})
		end
		SHELL:remove()
		ApplyAoE(RootPart.Position,75,35,75,175,false)
		SMASHED = true
		wait(1)
		VALUE1 = false
		UNANCHOR = true
		ATTACK = false
		Rooted = false
	end
end

function PandorasBox()
	local HITFLOOR,HITPOS = Raycast(RootPart.CFrame*CF(0,0,-6.5).p, (CF(RootPart.Position, RootPart.Position + VT(0, -1, 0))).lookVector, 4*SIZE, Character)
	if HITFLOOR ~= nil then
		ATTACK = true
		Rooted = true
		local RINGSPIN = true
		local CONSTRUCTING = true
		local RING = CreatePart(3, Effects, "Neon", 0, 1, "Alder", "Ring", VT(0,0,0))
		RING.Color = C3(0,0,0)
		MakeForm(RING,"Cyl")
		RING.CFrame = CF(HITPOS)
		CreateSound(402981977, RING, 5, 1.2, false)
		coroutine.resume(coroutine.create(function()
			repeat
				Swait()
				RING.CFrame = RING.CFrame * ANGLES(RAD(0), RAD(5), RAD(0))
				RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0 - 0.04 * SIN(SINE / 24)*SIZE, 0 + 0.04 * SIN(SINE / 12)*SIZE, 0 + 0.05*SIZE * COS(SINE / 12)) * ANGLES(RAD(0 - 2.5 * SIN(SINE / 12)), RAD(0 - 2.5 * SIN(SINE / 24)), RAD(0)), 1 / Animation_Speed)
				Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1.1*SIZE) - 1)) * ANGLES(RAD(-25 - 4 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
				RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.35*SIZE, 0.65*SIZE, 0*SIZE) * ANGLES(RAD(115), RAD(45), RAD(35)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.25*SIZE, 0.5*SIZE, 0.5*SIZE) * ANGLES(RAD(-35), RAD(25 - 2.5 * SIN(SINE / 12)), RAD(55 - 2.5 * SIN(SINE / 12))) * LEFTSHOULDERC0, 1 / Animation_Speed)
				RightHip.C0 = Clerp(RightHip.C0, CF(1*SIZE, -1*SIZE + 0.06 * SIN(SINE / 24) - 0.05*SIZE * COS(SINE / 12), -0.01*SIZE) * ANGLES(RAD(0 - 2.5 * SIN(SINE / 12)), RAD(75), RAD(0)) * ANGLES(RAD(-2 - 2.5 * SIN(SINE / 24)), RAD(0), RAD(0)), 1 / Animation_Speed)
				LeftHip.C0 = Clerp(LeftHip.C0, CF(-1*SIZE, -1*SIZE - 0.06 * SIN(SINE / 24) - 0.05*SIZE * COS(SINE / 12), -0.01*SIZE) * ANGLES(RAD(0 - 2.5 * SIN(SINE / 12)), RAD(-75), RAD(0)) * ANGLES(RAD(-2 + 2.5 * SIN(SINE / 24)), RAD(0), RAD(0)), 1 / Animation_Speed)
			until CONSTRUCTING == false
			repeat 
				Swait() 
				RING.CFrame = RING.CFrame * ANGLES(RAD(0), RAD(5), RAD(0))
			until RINGSPIN == false
			for i = 1, 25 do
				Swait()
				RING.CFrame = RING.CFrame * ANGLES(RAD(0), RAD(5), RAD(0))
				RING.Size = RING.Size - VT(0.15,0,0.15)
				--DECAL.Transparency = DECAL.Transparency + 1/25
				RING.Transparency = RING.Transparency + 1/25
			end
			RING:remove()
		end))
		for i = 1, 15 do
			Swait()
			RING.Size = RING.Size + VT(0.75,0,0.75)
			RING.Transparency = RING.Transparency - 1/15
		end
		local BOXSPIN = true
		local PANDORASBOX = IT("Model",Effects)
		PANDORASBOX.Name = "Pandora's Box"
		local BOX = IT("Model",PANDORASBOX)
		BOX.Name = "Body"
		local LID = IT("Model",PANDORASBOX)
		LID.Name = "Lid"
		--BUILDING THE BOX--
			local BASE = CreatePart(3, BOX, "Neon", 0, 0, "Alder", "Black", VT(2,1.8,2))
			BASE.Color = C3(0,0,0)
			PANDORASBOX.PrimaryPart = BASE
			BASE.CFrame = CF(HITPOS+VT(0,-8,0),VT(RootPart.Position.X,HITPOS.Y-8,RootPart.Position.Z))
			local WOOD = CreatePart(3, BOX, "Marble", 0, 0, "Bright yellow", "Marble", VT(0.2,1.9,0.2))
			WOOD.CFrame = BASE.CFrame*CF(1,0,1)
			local WOOD = CreatePart(3, BOX, "Marble", 0, 0, "Bright yellow", "Marble", VT(0.2,1.9,0.2))
			WOOD.CFrame = BASE.CFrame*CF(1,0,-1)
			local WOOD = CreatePart(3, BOX, "Marble", 0, 0, "Bright yellow", "Marble", VT(0.2,1.9,0.2))
			WOOD.CFrame = BASE.CFrame*CF(-1,0,1)
			local WOOD = CreatePart(3, BOX, "Marble", 0, 0, "Bright yellow", "Marble", VT(0.2,1.9,0.2))
			WOOD.CFrame = BASE.CFrame*CF(-1,0,-1)
			local WOOD = CreatePart(3, BOX, "Marble", 0, 0, "Bright yellow", "Marble", VT(2.1,0.2,0.2))
			WOOD.CFrame = BASE.CFrame*CF(0,0.9,1)
			local WOOD = CreatePart(3, BOX, "Marble", 0, 0, "Bright yellow", "Marble", VT(2.1,0.2,0.2))
			WOOD.CFrame = BASE.CFrame*CF(0,0.9,-1)
			local WOOD = CreatePart(3, BOX, "Marble", 0, 0, "Bright yellow", "Marble", VT(0.2,0.2,2.1))
			WOOD.CFrame = BASE.CFrame*CF(1,0.9,0)
			local WOOD = CreatePart(3, BOX, "Marble", 0, 0, "Bright yellow", "Marble", VT(0.2,0.2,2.1))
			WOOD.CFrame = BASE.CFrame*CF(-1,0.9,0)
			local WOOD = CreatePart(3, BOX, "Marble", 0, 0, "Bright yellow", "Marble", VT(2.1,0.2,0.2))
			WOOD.CFrame = BASE.CFrame*CF(0,-0.9,1)
			local WOOD = CreatePart(3, BOX, "Marble", 0, 0, "Bright yellow", "Marble", VT(2.1,0.2,0.2))
			WOOD.CFrame = BASE.CFrame*CF(0,-0.9,-1)
			local WOOD = CreatePart(3, BOX, "Marble", 0, 0, "Bright yellow", "Marble", VT(0.2,0.2,2.1))
			WOOD.CFrame = BASE.CFrame*CF(1,-0.9,0)
			local WOOD = CreatePart(3, BOX, "Marble", 0, 0, "Bright yellow", "Marble", VT(0.2,0.2,2.1))
			WOOD.CFrame = BASE.CFrame*CF(-1,-0.9,0)
			local WOOD = CreatePart(3, BOX, "Marble", 0, 0, "Daisy orange", "Marble", VT(2.1,1.9,0.1))
			WOOD.CFrame = BASE.CFrame*CF(0,0,1)
			local WOOD = CreatePart(3, BOX, "Marble", 0, 0, "Daisy orange", "Marble", VT(2.1,1.9,0.1))
			WOOD.CFrame = BASE.CFrame*CF(0,0,-1)
			local WOOD = CreatePart(3, BOX, "Marble", 0, 0, "Daisy orange", "Marble", VT(0.1,1.9,2.1))
			WOOD.CFrame = BASE.CFrame*CF(1,0,0)
			local WOOD = CreatePart(3, BOX, "Marble", 0, 0, "Daisy orange", "Marble", VT(0.1,1.9,2.1))
			WOOD.CFrame = BASE.CFrame*CF(-1,0,0)
			local WOOD = CreatePart(3, BOX, "Marble", 0, 0, "Daisy orange", "Marble", VT(2.1,0.1,2.1))
			WOOD.CFrame = BASE.CFrame*CF(0,-0.9,0)
			-------------
			local LIDPART = CreatePart(3, LID, "Marble", 0, 0, "Daisy orange", "Marble", VT(2.1,0.1,2.1))
			LIDPART.CFrame = BASE.CFrame*CF(0,1,0)
			LID.PrimaryPart = LIDPART
			local WOOD = CreatePart(3, LID, "Marble", 0, 0, "Bright yellow", "Marble", VT(2.1,0.2,0.2))
			WOOD.CFrame = LIDPART.CFrame*CF(0,0,-1)
			local WOOD = CreatePart(3, LID, "Marble", 0, 0, "Bright yellow", "Marble", VT(2.1,0.2,0.2))
			WOOD.CFrame = LIDPART.CFrame*CF(0,0,1)
			local WOOD = CreatePart(3, LID, "Marble", 0, 0, "Bright yellow", "Marble", VT(0.2,0.2,2.1))
			WOOD.CFrame = LIDPART.CFrame*CF(1,0,0)
			local WOOD = CreatePart(3, LID, "Marble", 0, 0, "Bright yellow", "Marble", VT(0.2,0.2,2.1))
			WOOD.CFrame = LIDPART.CFrame*CF(-1,0,0)
			local DECAL = IT("Decal",LIDPART)
			DECAL.Face = "Top"
			DECAL.Texture = "http://www.roblox.com/asset/?id=1501226061"
			DECAL.Color3 = C3(0,0,0)
		--BUILDING THE BOX--
		coroutine.resume(coroutine.create(function()
			repeat
				Swait()
				PANDORASBOX:SetPrimaryPartCFrame(BASE.CFrame * ANGLES(RAD(0), RAD(2.45), RAD(0)))
			until BOXSPIN == false
		end))
		for i = 1, 25 do
			Swait()
			PANDORASBOX:SetPrimaryPartCFrame(BASE.CFrame * CF(0,1.5-(i/12.5),0))
		end
		wait(0.5)
		BOXSPIN = false
		CONSTRUCTING = false	
		coroutine.resume(coroutine.create(function()
			WACKYEFFECT({Time = 45, EffectType = "Sphere", Size = LIDPART.Size, Size2 = VT(3,0,3)*4, Transparency = 0, Transparency2 = 1, CFrame = LIDPART.CFrame, MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = SKILLTEXTCOLOR, SoundID = 168586586, SoundPitch = 1.3, SoundVolume = 6})
			--[[for i = 1, 45 do
				Swait()
				LID:SetPrimaryPartCFrame(LIDPART.CFrame * CF(0,1.5-(i/12.5),0.5) * ANGLES(RAD(0.7), RAD(0), RAD(0)))
			end-
			LID:remove()]]--
			for _, c in pairs(LID:GetChildren()) do
				if c.ClassName == "Part" then
					c.Anchored = false
					c.CanCollide = true
					if c ~= LIDPART then
						weldBetween(LIDPART,c)
					end
				end
			end
			LIDPART.Velocity = CF(LIDPART.Position,LIDPART.CFrame*CF(15,25,0).p).lookVector*65
			Debris:AddItem(LID,15)
			wait(0.5)
			local RANDOMEFFECT = MRANDOM(1,4)
			if RANDOMEFFECT == 1 then
				for i = 1, 45 do
					wait((2-(i/15))/15)
					WACKYEFFECT({Time = 45, EffectType = "Sphere", Size = VT(0,0,0), Size2 = VT(1,1,1), Transparency = 0, Transparency2 = 1, CFrame = BASE.CFrame*CF(0,MRANDOM(12,15),0) * ANGLES(RAD(0), RAD(MRANDOM(0,360)), RAD(0))*CF(0,0,MRANDOM(1,5)), MoveToPos = BASE.Position, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = SKILLTEXTCOLOR, SoundID = nil, SoundPitch = 0.8, SoundVolume = 6})
				end	
				wait(1)
				WACKYEFFECT({Time = 45, EffectType = "Sphere", Size = VT(0,0,0), Size2 = VT(35,35,35)*12, Transparency = 0, Transparency2 = 1, CFrame = BASE.CFrame, MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = BASE.Color, SoundID = 165970126, SoundPitch = 0.75, SoundVolume = 6})
				WACKYEFFECT({Time = 55, EffectType = "Wave", Size = VT(0,0,0), Size2 = VT(45,3,45)*10, Transparency = 0, Transparency2 = 1, CFrame = CF(HITPOS), MoveToPos = nil, RotationX = 0, RotationY = -5, RotationZ = 0, Material = "Neon", Color = BASE.Color, SoundID = 469345336, SoundPitch = 0.75, SoundVolume = 6})
				WACKYEFFECT({Time = 55, EffectType = "Wave", Size = VT(0,0,0), Size2 = VT(45,3,45)*9, Transparency = 0, Transparency2 = 1, CFrame = CF(HITPOS), MoveToPos = nil, RotationX = 0, RotationY = 5, RotationZ = 0, Material = "Neon", Color = BASE.Color, SoundID = nil, SoundPitch = 0.75, SoundVolume = 6})
				for i = 1, 5 do
					WACKYEFFECT({Time = 35, EffectType = "Wave", Size = VT(5,0,5)*SIZE, Size2 = VT(35,3,35)*12, Transparency = 0.5, Transparency2 = 1, CFrame = BASE.CFrame * ANGLES(RAD(MRANDOM(0,360)), RAD(MRANDOM(0,360)), RAD(MRANDOM(0,360))), MoveToPos = nil, RotationX = 0, RotationY = -5, RotationZ = 0, Material = "Neon", Color = C3(0,0,0), SoundID = nil, SoundPitch = 0.5, SoundVolume = 6})
				end
				ApplyAoE(BASE.Position,50,15,45,375,false)
				ApplyAoE(BASE.Position,250,35,40,175,false)
			elseif RANDOMEFFECT == 2 then
				local FIELD = CreatePart(3, Effects, "Neon", 0, 0, "Alder", "Field", VT(0.3,0.3,0.3))
				FIELD.CFrame = BASE.CFrame
				MakeForm(FIELD,"Ball")
				for i = 1, 50 do
					Swait()
					FIELD.Size = FIELD.Size + VT(0.01,0.01,0.01)
					FIELD.CFrame = FIELD.CFrame * CF(0,0.75-(i/45),0)
				end
				wait(0.2)
				local LOOP = CreateSound(1393698948, FIELD, 0, 1.2, true)
				coroutine.resume(coroutine.create(function()
					for i = 1, 75 do
						Swait()
						LOOP.Volume = LOOP.Volume + 10/75
						LOOP.Parent = FIELD
						local CHILDREN = workspace:GetDescendants()
						for index, CHILD in pairs(CHILDREN) do
							if CHILD.ClassName == "Model" and CHILD ~= Character and CHILD.Parent ~= Effects then
								local HUM = CHILD:FindFirstChildOfClass("Humanoid")
								if HUM then
									local TORSO = CHILD:FindFirstChild("Torso") or CHILD:FindFirstChild("UpperTorso")
									if TORSO then
										if (TORSO.Position - FIELD.Position).Magnitude <= FIELD.Size.X/2 then
											HUM.Health = HUM.Health - 0.1
											TORSO.Velocity = VT(0,5,0)
											HUM.PlatformStand = true
											if TORSO.RotVelocity.Magnitude < 15 then
										 		TORSO.RotVelocity = VT(MRANDOM(-45,45),MRANDOM(-45,45),MRANDOM(-45,45))
											end
										end
									end
								end
							end
						end
						FIELD.Size = FIELD.Size + VT(3,3,3)
						FIELD.Transparency = FIELD.Transparency + 0.8/75
					end
					for i = 1, 500 do
						Swait()
						LOOP.Parent = FIELD
						local CHILDREN = workspace:GetDescendants()
						for index, CHILD in pairs(CHILDREN) do
							if CHILD.ClassName == "Model" and CHILD ~= Character and CHILD.Parent ~= Effects then
								local HUM = CHILD:FindFirstChildOfClass("Humanoid")
								if HUM then
									local TORSO = CHILD:FindFirstChild("Torso") or CHILD:FindFirstChild("UpperTorso")
									if TORSO then
										if (TORSO.Position - FIELD.Position).Magnitude <= FIELD.Size.X/2 then
											TORSO.Velocity = VT(0,5,0)
											HUM.Health = HUM.Health - 0.1
											HUM.PlatformStand = true
											if TORSO.RotVelocity.Magnitude < 15 then
										 		TORSO.RotVelocity = VT(MRANDOM(-45,45),MRANDOM(-45,45),MRANDOM(-45,45))
											end
										end
									end
								end
							end
						end
					end
					for i = 1, 25 do
						Swait()
						LOOP.Volume = LOOP.Volume + 10/25
						LOOP.Parent = FIELD
						local CHILDREN = workspace:GetDescendants()
						for index, CHILD in pairs(CHILDREN) do
							if CHILD.ClassName == "Model" and CHILD ~= Character and CHILD.Parent ~= Effects then
								local HUM = CHILD:FindFirstChildOfClass("Humanoid")
								if HUM then
									local TORSO = CHILD:FindFirstChild("Torso") or CHILD:FindFirstChild("UpperTorso")
									if TORSO then
										if (TORSO.Position - FIELD.Position).Magnitude <= FIELD.Size.X/1.8 then
											TORSO.Velocity = VT(0,5,0)
											HUM.Health = HUM.Health - 0.1
											HUM.PlatformStand = false
											if TORSO.RotVelocity.Magnitude < 15 then
										 		TORSO.RotVelocity = VT(MRANDOM(-45,45),MRANDOM(-45,45),MRANDOM(-45,45))
											end
										end
									end
								end
							end
						end
						FIELD.Size = FIELD.Size - VT(3,3,3)
						FIELD.Transparency = FIELD.Transparency + 0.2/25
					end	
					FIELD:remove()
				end))
			elseif RANDOMEFFECT == 3 then
				for i = 1, 10 do
					wait(0.15)
					WACKYEFFECT({Time = 15, EffectType = "Sphere", Size = VT(0,0,0), Size2 = VT(3,8,3), Transparency = 0, Transparency2 = 1, CFrame = BASE.CFrame*CF(0,0.3,0), MoveToPos = BASE.Position+VT(0,6,0), RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = C3(0,0,0), SoundID = 90655239, SoundPitch = 0.8, SoundVolume = 6})
					coroutine.resume(coroutine.create(function()
						local MINION = CLONE:Clone()
						MINION.Parent = Effects
						MINION.Name = "Shadow"
						MINION.HumanoidRootPart.CFrame = BASE.CFrame*CF(0,5,0) * ANGLES(RAD(0), RAD(MRANDOM(0,360)), RAD(0))
						MINION.HumanoidRootPart.Velocity = CF(MINION.HumanoidRootPart.Position,MINION.HumanoidRootPart.CFrame*CF(0,8,-15).p).lookVector*MRANDOM(55,100)
						for _, c in pairs(MINION:GetChildren()) do
							if c.ClassName == "Part" then
								c.Material = "Neon"
								c.Color = C3(0,0,0)
								c.Transparency = 0.25
								if c.Name == "Head" then
									c:ClearAllChildren()
									local MSH = IT("BlockMesh",c)
									MSH.Scale = VT(0.5,1,1)
								end
							end
						end
						local TORSO = MINION.Torso
						local HUMAN = MINION.Humanoid
						HUMAN.WalkSpeed = 20
						HUMAN.MaxHealth = math.huge
						HUMAN.Health = math.huge
						HUMAN.DisplayDistanceType = "None"
						HUMAN.Died:connect(function()
							MINION:remove()
							--CreateSound(SHOUTS[MRANDOM(1,3)], TORSO, 3, 0.5, false)
						end)
						wait(1)
						local findNearestTorso = function(POS)
							local list = game.Workspace:GetDescendants()
							local torso = nil
							local dist = 500
							local temp = nil
							local human = nil
							local temp2 = nil
							for x = 1, #list do
								temp2 = list[x]
								if (temp2.className == "Model") and (temp2 ~= Character) and (temp2.Parent ~= Effects) then
									temp = temp2:findFirstChild("Torso") or temp2:findFirstChild("UpperTorso")
									human = temp2:findFirstChildOfClass("Humanoid")
									if (temp ~= nil) and (human ~= nil) and (human.Health > 0) then
										if (temp.Position - POS).magnitude < dist then
											torso = temp
											dist = (temp.Position - POS).magnitude
										end
									end
								end
							end
							return torso, dist
						end
						for i = 1, 40 do
							if HUMAN.Health == 0 then
								break
							end
							wait(0.3)
							local target,dist= findNearestTorso(TORSO.Position)
							if target then
								HUMAN:MoveTo(target.Position)
								if dist < 25 then
									CreateSound(348663022, TORSO, 10, 1, true)
									wait(2)
									--local ANIM = HUMAN:LoadAnimation(ATANIM)
									--ANIM:Play()
									--CreateSound(SHOUTS[MRANDOM(1,3)], TORSO, 1, 1, false)
									ApplyAoE(TORSO.Position,10,0,0,85,true)
									WACKYEFFECT({Time = 15, EffectType = "Sphere", Size = VT(5,5,5), Size2 = VT(25,25,25), Transparency = 0, Transparency2 = 1, CFrame = TORSO.CFrame, MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = SKILLTEXTCOLOR, SoundID = 201858087, SoundPitch = 0.8, SoundVolume = 10})
									for i = 1, 5 do
										WACKYEFFECT({Time = 75, EffectType = "Wave", Size = VT(5,0,5)*SIZE, Size2 = VT(15,1,15), Transparency = 0.5, Transparency2 = 1, CFrame = TORSO.CFrame * ANGLES(RAD(MRANDOM(0,360)), RAD(MRANDOM(0,360)), RAD(MRANDOM(0,360))), MoveToPos = nil, RotationX = 0, RotationY = MRANDOM(-15,15)/7.5, RotationZ = 0, Material = "Neon", Color = C3(0,0,0), SoundID = nil, SoundPitch = 0.5, SoundVolume = 6})
									end
									break
								end
							end
						end
						MINION:remove()
					end))
				end
			elseif RANDOMEFFECT == 4 then
				local FIELD = CreatePart(3, Effects, "Neon", 0, 0, "Alder", "Field", VT(0.3,0.3,0.3))
				FIELD.Color = C3(0,0,0)
				FIELD.CFrame = BASE.CFrame
				MakeForm(FIELD,"Ball")
				FIELD.CanCollide = true
				for i = 1, 50 do
					Swait()
					FIELD.Size = FIELD.Size + VT(0.01,0.01,0.01)
					FIELD.CFrame = FIELD.CFrame * CF(0,0.75-(i/45),0)
				end
				wait(0.2)
				local LOOP = CreateSound(487214658, FIELD, 0, 1, true)
				coroutine.resume(coroutine.create(function()
					local E = 0
					for i = 1, 75 do
						E = E + 1
						Swait()
						if E >= 35 then
							E = 0
							WACKYEFFECT({Time = 25, EffectType = "Sphere", Size = FIELD.Size*30, Size2 = FIELD.Size, Transparency = 0.8, Transparency2 = 1, CFrame = FIELD.CFrame, MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = BASE.Color, SoundID = nil, SoundPitch = 1, SoundVolume = 6})
						end
						LOOP.Volume = LOOP.Volume + 10/75
						LOOP.Parent = FIELD
						local CHILDREN = workspace:GetDescendants()
						for index, CHILD in pairs(CHILDREN) do
							if CHILD.ClassName == "Model" and CHILD ~= Character and CHILD.Parent ~= Effects then
								local HUM = CHILD:FindFirstChildOfClass("Humanoid")
								if HUM then
									local TORSO = CHILD:FindFirstChild("Torso") or CHILD:FindFirstChild("UpperTorso")
									if TORSO then
										if (TORSO.Position - FIELD.Position).Magnitude <= FIELD.Size.X*30 then
											for _, c in pairs(CHILD:GetChildren()) do
												if c:IsA("BasePart") then
													local bv = Instance.new("BodyVelocity") 
													bv.maxForce = Vector3.new(1e9, 1e9, 1e9)
													bv.velocity = CF(FIELD.Position,c.Position).lookVector*-50
													bv.Parent = c
													Debris:AddItem(bv,0.05)
												end
											end
											HUM.Health = HUM.Health - 0.3
										end
									end
								end
							end
						end
						FIELD.Size = FIELD.Size + VT(0.3,0.3,0.3)/5
					end
					for i = 1, 180 do
						E = E + 1
						Swait()
						if E >= 35 then
							E = 0
							WACKYEFFECT({Time = 25, EffectType = "Sphere", Size = FIELD.Size*30, Size2 = FIELD.Size, Transparency = 0.8, Transparency2 = 1, CFrame = FIELD.CFrame, MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = BASE.Color, SoundID = nil, SoundPitch = 1, SoundVolume = 6})
						end
						LOOP.Parent = FIELD
						local CHILDREN = workspace:GetDescendants()
						for index, CHILD in pairs(CHILDREN) do
							if CHILD.ClassName == "Model" and CHILD ~= Character and CHILD.Parent ~= Effects then
								local HUM = CHILD:FindFirstChildOfClass("Humanoid")
								if HUM then
									local TORSO = CHILD:FindFirstChild("Torso") or CHILD:FindFirstChild("UpperTorso")
									if TORSO then
										if (TORSO.Position - FIELD.Position).Magnitude <= FIELD.Size.X*30 then
											for _, c in pairs(CHILD:GetChildren()) do
												if c:IsA("BasePart") then
													local bv = Instance.new("BodyVelocity") 
													bv.maxForce = Vector3.new(1e9, 1e9, 1e9)
													bv.velocity = CF(FIELD.Position,c.Position).lookVector*-50
													bv.Parent = c
													Debris:AddItem(bv,0.05)
												end
											end
											HUM.Health = HUM.Health - 0.3
										end
									end
								end
							end
						end
					end
					ApplyAoE(FIELD.Position,40,15,20,375,false)
					WACKYEFFECT({Time = 45, EffectType = "Sphere", Size = FIELD.Size, Size2 = VT(35,35,35), Transparency = 0, Transparency2 = 1, CFrame = FIELD.CFrame, MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = BASE.Color, SoundID = 231917744, SoundPitch = 1, SoundVolume = 6})
					for i = 1, 5 do
						WACKYEFFECT({Time = 35, EffectType = "Wave", Size = VT(5,0,5)*SIZE, Size2 = VT(35,3,35), Transparency = 0.5, Transparency2 = 1, CFrame = FIELD.CFrame * ANGLES(RAD(MRANDOM(0,360)), RAD(MRANDOM(0,360)), RAD(MRANDOM(0,360))), MoveToPos = nil, RotationX = 0, RotationY = -5, RotationZ = 0, Material = "Neon", Color = C3(0,0,0), SoundID = nil, SoundPitch = 0.5, SoundVolume = 6})
					end
					FIELD:remove()
				end))
			elseif RANDOMEFFECT == 5 then
			end
			wait(0.5)
			for i = 1, 25 do
				Swait()
				PANDORASBOX:SetPrimaryPartCFrame(BASE.CFrame * CF(0,-0.3,0))
			end
			PANDORASBOX:remove()
			RINGSPIN = false
		end))
		ATTACK = false
		Rooted = false
	end
end

function Taunt()
	ATTACK = true
	local LAUGH = nil
	coroutine.resume(coroutine.create(function()
		repeat
			Swait()
			RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0 - 0.04 * SIN(SINE / 24)*SIZE, 0 + 0.04 * SIN(SINE / 12)*SIZE, 0 + 0.05*SIZE * COS(SINE / 12)) * ANGLES(RAD(0 - 2.5 * SIN(SINE / 12)), RAD(0 - 2.5 * SIN(SINE / 24)), RAD(0)), 1 / Animation_Speed)
			Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1.1*SIZE) - 1)) * ANGLES(RAD(5), RAD(0), RAD(-45)), 1 / Animation_Speed)
			RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.25*SIZE, 0.15*SIZE, -0.5*SIZE) * ANGLES(RAD(170), RAD(-25), RAD(-15)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
			LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.25*SIZE, 0.5*SIZE, 0.5*SIZE) * ANGLES(RAD(-35), RAD(25 - 2.5 * SIN(SINE / 12)), RAD(55 - 2.5 * SIN(SINE / 12))) * LEFTSHOULDERC0, 1 / Animation_Speed)
			RightHip.C0 = Clerp(RightHip.C0, CF(1*SIZE, -1*SIZE + 0.06 * SIN(SINE / 24) - 0.05*SIZE * COS(SINE / 12), -0.01*SIZE) * ANGLES(RAD(0 - 2.5 * SIN(SINE / 12)), RAD(75), RAD(0)) * ANGLES(RAD(-2 - 2.5 * SIN(SINE / 24)), RAD(0), RAD(0)), 1 / Animation_Speed)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-1*SIZE, -1*SIZE - 0.06 * SIN(SINE / 24) - 0.05*SIZE * COS(SINE / 12), -0.01*SIZE) * ANGLES(RAD(0 - 2.5 * SIN(SINE / 12)), RAD(-75), RAD(0)) * ANGLES(RAD(-2 + 2.5 * SIN(SINE / 24)), RAD(0), RAD(0)), 1 / Animation_Speed)
		until LAUGH ~= nil
		repeat
			Swait()
			LAUGH.Parent = Head
			RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0 - 0.04 * SIN(SINE / 24)*SIZE, 0 + 0.04 * SIN(SINE / 12)*SIZE, 0+(0.1*LAUGH.PlaybackLoudness/75) + 0.05*SIZE * COS(SINE / 12)) * ANGLES(RAD(0 - 2.5 * SIN(SINE / 12)), RAD(0 - 2.5 * SIN(SINE / 24)), RAD(0)), 1 / Animation_Speed)
			Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1.1*SIZE+(0.1*LAUGH.PlaybackLoudness/75)) - 1)) * ANGLES(RAD(5), RAD(0), RAD(-45)), 1 / Animation_Speed)
			RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.25*SIZE, 0.15*SIZE+(0.1*LAUGH.PlaybackLoudness/75), -0.5*SIZE) * ANGLES(RAD(170), RAD(-25), RAD(-15)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
			LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.25*SIZE, 0.5*SIZE+(0.1*LAUGH.PlaybackLoudness/75), 0.5*SIZE) * ANGLES(RAD(-35), RAD(25 - 2.5 * SIN(SINE / 12)), RAD(55 - 2.5 * SIN(SINE / 12))) * LEFTSHOULDERC0, 1 / Animation_Speed)
			RightHip.C0 = Clerp(RightHip.C0, CF(1*SIZE, -1*SIZE-(0.1*LAUGH.PlaybackLoudness/75) + 0.06 * SIN(SINE / 24) - 0.05*SIZE * COS(SINE / 12), -0.01*SIZE) * ANGLES(RAD(0 - 2.5 * SIN(SINE / 12)), RAD(75), RAD(0)) * ANGLES(RAD(-2 - 2.5 * SIN(SINE / 24)), RAD(0), RAD(0)), 1 / Animation_Speed)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-1*SIZE, -1*SIZE-(0.1*LAUGH.PlaybackLoudness/75) - 0.06 * SIN(SINE / 24) - 0.05*SIZE * COS(SINE / 12), -0.01*SIZE) * ANGLES(RAD(0 - 2.5 * SIN(SINE / 12)), RAD(-75), RAD(0)) * ANGLES(RAD(-2 + 2.5 * SIN(SINE / 24)), RAD(0), RAD(0)), 1 / Animation_Speed)
		until LAUGH.Playing == false
	ATTACK = false
	end))
	wait(0.1)
	sick:Pause()
	LAUGH = CreateSound(525166232, Head, 10, 1, false)
	wait(1)
	sick:Resume()
end

--//=================================\\
--||	  ASSIGN THINGS TO KEYS
--\\=================================//

function MouseDown(Mouse)
	HOLD = true
	if ATTACK == false then
	end
end

function MouseUp(Mouse)
HOLD = false
end

function KeyDown(Key)
	KEYHOLD = true
	if Key == "z" and ATTACK == false then
		MagicMissiles()
	end

	if Key == "b" and ATTACK == false then
		TimesUp()
	end

	if Key == "c" and ATTACK == false then
		ChainPunch()
	end

	if Key == "v" and ATTACK == false then
		WarpMeteor()
	end

	if Key == "x" and ATTACK == false then
		PandorasBox()
	end

	if Key == "t" and ATTACK == false then
		Taunt()
	end
end

function KeyUp(Key)
	KEYHOLD = false
end

	Mouse.Button1Down:connect(function(NEWKEY)
		MouseDown(NEWKEY)
	end)
	Mouse.Button1Up:connect(function(NEWKEY)
		MouseUp(NEWKEY)
	end)
	Mouse.KeyDown:connect(function(NEWKEY)
		KeyDown(NEWKEY)
	end)
	Mouse.KeyUp:connect(function(NEWKEY)
		KeyUp(NEWKEY)
	end)

--//=================================\\
--\\=================================//


function unanchor()
	if UNANCHOR == true then
		RootPart.Anchored = false
	end
	g = Character:GetChildren()
	for i = 1, #g do
		if g[i].ClassName == "Part" and g[i] ~= RootPart then
			g[i].Anchored = false
		end
	end
	g = Weapon:GetChildren()
	for i = 1, #g do
		if g[i].ClassName == "Part" then
			g[i].Anchored = false
		end
	end
end


--//=================================\\
--||	WRAP THE WHOLE SCRIPT UP
--\\=================================//

Humanoid.Changed:connect(function(Jump)
	if Jump == "Jump" and (Disable_Jump == true) then
		Humanoid.Jump = false
	end
end)

while true do
	Swait()
	script.Parent = WEAPONGUI
	for _,v in next, Humanoid:GetPlayingAnimationTracks() do
	    v:Stop();
	end
	ANIMATE.Parent = nil
	SINE = SINE + CHANGE*1.5
	local TORSOVELOCITY = (RootPart.Velocity * VT(1, 0, 1)).magnitude
	local TORSOVERTICALVELOCITY = RootPart.Velocity.y
	local HITFLOOR = Raycast(RootPart.Position, (CF(RootPart.Position, RootPart.Position + VT(0, -1, 0))).lookVector, 4*SIZE, Character)
	local WALKSPEEDVALUE = 10 / (Humanoid.WalkSpeed / 16)
	if ANIM == "Walk" and TORSOVELOCITY > 1 then
		RootJoint.C1 = Clerp(RootJoint.C1, ROOTC0 * CF(0, 0, -0.15 * COS(SINE / (WALKSPEEDVALUE / 2))) * ANGLES(RAD(0), RAD(0) - RootPart.RotVelocity.Y / 75, RAD(0)), 2 * (Humanoid.WalkSpeed / 16) / Animation_Speed)
		Neck.C1 = Clerp(Neck.C1, CF(0, -0.5, 0) * ANGLES(RAD(-90), RAD(0), RAD(180)) * ANGLES(RAD(2.5 * SIN(SINE / (WALKSPEEDVALUE / 2))), RAD(0), RAD(0) - Head.RotVelocity.Y / 30), 0.2 * (Humanoid.WalkSpeed / 16) / Animation_Speed)
		RightHip.C1 = Clerp(RightHip.C1, CF(0.5*SIZE, 0.875*SIZE - 0.125 * SIN(SINE / WALKSPEEDVALUE)*SIZE - 0.15 * COS(SINE / WALKSPEEDVALUE*2), 0 +0.5+ 0.2 * COS(SINE / WALKSPEEDVALUE)) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(0) - RightLeg.RotVelocity.Y / 75, RAD(0), RAD(25+80 * COS(SINE / WALKSPEEDVALUE))), 0.2 * (Humanoid.WalkSpeed / 16) / Animation_Speed)
		LeftHip.C1 = Clerp(LeftHip.C1, CF(-0.5*SIZE, 0.875*SIZE + 0.125 * SIN(SINE / WALKSPEEDVALUE)*SIZE - 0.15 * COS(SINE / WALKSPEEDVALUE*2), 0 +0.5+ -0.2 * COS(SINE / WALKSPEEDVALUE)) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(0) + LeftLeg.RotVelocity.Y / 75, RAD(0), RAD(-25+80 * COS(SINE / WALKSPEEDVALUE))), 0.2 * (Humanoid.WalkSpeed / 16) / Animation_Speed)
	elseif (ANIM ~= "Walk") or (TORSOVELOCITY < 1) then
		RootJoint.C1 = Clerp(RootJoint.C1, ROOTC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.2 / Animation_Speed)
		Neck.C1 = Clerp(Neck.C1, CF(0, -0.5, 0) * ANGLES(RAD(-90), RAD(0), RAD(180)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
		RightHip.C1 = Clerp(RightHip.C1, CF(0.5*SIZE, 1*SIZE, 0) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
		LeftHip.C1 = Clerp(LeftHip.C1, CF(-0.5*SIZE, 1*SIZE, 0) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
	end
	if TORSOVERTICALVELOCITY > 1 and HITFLOOR == nil then
		ANIM = "Jump"
		if ATTACK == false then
			RootJoint.C0 = Clerp(RootJoint.C0, ROOTC0 * CF(0*SIZE, 0*SIZE, 0*SIZE) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
			Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0*SIZE, 0*SIZE, 0 + ((1.1*SIZE) - 1)) * ANGLES(RAD(-20), RAD(0), RAD(0)), 1 / Animation_Speed)
			RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5*SIZE, 0.5*SIZE, 0*SIZE) * ANGLES(RAD(-40), RAD(0), RAD(20)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
			LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5*SIZE, 0.5*SIZE, 0*SIZE) * ANGLES(RAD(-40), RAD(0), RAD(-20)) * LEFTSHOULDERC0, 1 / Animation_Speed)
			RightHip.C0 = Clerp(RightHip.C0, CF(1*SIZE, -1*SIZE, -0.3*SIZE) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(-5), RAD(0), RAD(-20)), 1 / Animation_Speed)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-1*SIZE, -1*SIZE, -0.3*SIZE) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(-5), RAD(0), RAD(20)), 1 / Animation_Speed)
	    end
	elseif TORSOVERTICALVELOCITY < -1 and HITFLOOR == nil then
		ANIM = "Fall"
		if ATTACK == false then
			RootJoint.C0 = Clerp(RootJoint.C0, ROOTC0 * CF(0*SIZE, 0*SIZE, 0*SIZE) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
			Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0*SIZE, 0*SIZE, 0 + ((1.1*SIZE) - 1)) * ANGLES(RAD(20), RAD(0), RAD(0)), 1 / Animation_Speed)
			RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5*SIZE, 0.5*SIZE, 0*SIZE) * ANGLES(RAD(0), RAD(0), RAD(60)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
			LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5*SIZE, 0.5*SIZE, 0*SIZE) * ANGLES(RAD(0), RAD(0), RAD(-60)) * LEFTSHOULDERC0, 1 / Animation_Speed)
			RightHip.C0 = Clerp(RightHip.C0, CF(1*SIZE, -1*SIZE, 0*SIZE) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(20)), 1 / Animation_Speed)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-1*SIZE, -1*SIZE, 0*SIZE) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(10)), 1 / Animation_Speed)
		end
	elseif TORSOVELOCITY < 1 and HITFLOOR ~= nil then
		ANIM = "Idle"
		if ATTACK == false then
			RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0 - 0.04 * SIN(SINE / 24)*SIZE, 0 + 0.04 * SIN(SINE / 12)*SIZE, 0 + 0.05*SIZE * COS(SINE / 12)) * ANGLES(RAD(0 - 2.5 * SIN(SINE / 12)), RAD(0 - 2.5 * SIN(SINE / 24)), RAD(0)), 1 / Animation_Speed)
			Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1.1*SIZE) - 1)) * ANGLES(RAD(25 - 4 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
			RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.25*SIZE, 0.5*SIZE, 0.5*SIZE) * ANGLES(RAD(-35), RAD(-25 + 2.5 * SIN(SINE / 12)), RAD(-55 + 2.5 * SIN(SINE / 12))) * RIGHTSHOULDERC0, 1 / Animation_Speed)
			LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.25*SIZE, 0.5*SIZE, 0.5*SIZE) * ANGLES(RAD(-35), RAD(25 - 2.5 * SIN(SINE / 12)), RAD(55 - 2.5 * SIN(SINE / 12))) * LEFTSHOULDERC0, 1 / Animation_Speed)
			RightHip.C0 = Clerp(RightHip.C0, CF(1*SIZE, -1*SIZE + 0.06 * SIN(SINE / 24) - 0.05*SIZE * COS(SINE / 12), -0.01*SIZE) * ANGLES(RAD(0 - 2.5 * SIN(SINE / 12)), RAD(75), RAD(0)) * ANGLES(RAD(-2 - 2.5 * SIN(SINE / 24)), RAD(0), RAD(0)), 1 / Animation_Speed)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-1*SIZE, -1*SIZE - 0.06 * SIN(SINE / 24) - 0.05*SIZE * COS(SINE / 12), -0.01*SIZE) * ANGLES(RAD(0 - 2.5 * SIN(SINE / 12)), RAD(-75), RAD(0)) * ANGLES(RAD(-2 + 2.5 * SIN(SINE / 24)), RAD(0), RAD(0)), 1 / Animation_Speed)
		end
	elseif TORSOVELOCITY > 1 and HITFLOOR ~= nil then
		ANIM = "Walk"
		if ATTACK == false then
			RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0*SIZE, 0*SIZE, -0.1*SIZE) * ANGLES(RAD(5), RAD(0), RAD(0)), 1 / Animation_Speed)
			Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1.1*SIZE) - 1)) * ANGLES(RAD(15 - 1 * SIN(SINE / (WALKSPEEDVALUE / 2))), RAD(0), RAD(0)), 1/ Animation_Speed)
			RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.25*SIZE, 0.5*SIZE, 0.5*SIZE) * ANGLES(RAD(-35), RAD(-25 + 2.5 * SIN(SINE / WALKSPEEDVALUE)), RAD(-55 + 2.5 * SIN(SINE / WALKSPEEDVALUE))) * RIGHTSHOULDERC0, 1 / Animation_Speed)
			LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.25*SIZE, 0.5*SIZE, 0.5*SIZE) * ANGLES(RAD(-35), RAD(25 - 2.5 * SIN(SINE / WALKSPEEDVALUE)), RAD(55 - 2.5 * SIN(SINE / WALKSPEEDVALUE))) * LEFTSHOULDERC0, 1 / Animation_Speed)
			RightHip.C0 = Clerp(RightHip.C0, CF(1*SIZE , -1*SIZE, 0*SIZE) * ANGLES(RAD(0), RAD(85), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 2 / Animation_Speed)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-1*SIZE, -1*SIZE, 0*SIZE) * ANGLES(RAD(0), RAD(-85), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 2 / Animation_Speed)
		end
	end
	unanchor()
	Humanoid.MaxHealth = "inf"
	Humanoid.Health = "inf"
	if Rooted == false then
		Disable_Jump = false
		Humanoid.WalkSpeed = Speed
	elseif Rooted == true then
		Disable_Jump = true
		Humanoid.WalkSpeed = 0
	end
	for _, c in pairs(Character:GetChildren()) do
		if c.ClassName == "Part" and c.Name ~= "Detail" then
			c.Material = "Fabric"
			if c:FindFirstChildOfClass("ParticleEmitter") then
				c:FindFirstChildOfClass("ParticleEmitter"):remove()
			end
			if c ~= Head then
				c.Color = C3(0,0,0)
			else
				c.Color = C3(1,1,1)
			end
			if c == Head then
				if c:FindFirstChild("face") then
					c.face:remove()
				end
			end
		elseif c.ClassName == "CharacterMesh" or c.ClassName == "Accessory" or c.Name == "Body Colors" then
			c:remove()
		elseif (c.ClassName == "Shirt" or c.ClassName == "Pants") and c.Name ~= "Cloth" then
			c:remove()
		end
	end
	sick.SoundId = "rbxassetid://"..SONG
	sick.Looped = true
	sick.Pitch = 1
	sick.Volume = 5
	sick.Parent = Torso
	sick:Resume()
	--sick.Playing = false
	Humanoid.Name = "Pandora = "..Player.Name
end

--//=================================\\
--\\=================================//





--//====================================================\\--
--||			  		 END OF SCRIPT
--\\====================================================//--
end)

local Tab = Window:NewTab("Script Admin")

local JSection = Tab:NewSection("Script Admin Here")

JSection:NewButton("HomeBrew Admin", "[????]", function()
   loadstring(game:HttpGet(('https://raw.githubusercontent.com/mgamingpro/HomebrewAdmin/master/Main'),true))()
end)

DSection:NewButton("ink moster", "[????]", function()
   
_G.loop = true
local player = game.Players.LocalPlayer
local char = player.Character
local Align = function(Part0, Part1,Mesh)
    local Aligns = {
        AlignOrientation = Instance.new("AlignOrientation", Part0),
        AlignPosition = Instance.new("AlignPosition", Part0)
    }
    
    local Attachments = {
        Attach0 = Instance.new("Attachment", Part0),
        Attach1 = Instance.new("Attachment", Part1)
    }
    local m = Part0:FindFirstChildOfClass('SpecialMesh')--This will get the first "SpecialMesh" it finds if it does not find any, then it will return nil
    if Mesh and m then --If Mesh is set to true and it finds a mesh it will destroy it
        m:Destroy()
    end
    Part0:BreakJoints()
    Aligns.AlignOrientation.Attachment0 = Attachments.Attach0
    Aligns.AlignOrientation.Attachment1 = Attachments.Attach1
    Aligns.AlignOrientation.Responsiveness = math.huge
    Aligns.AlignOrientation.RigidityEnabled = true
    
    Aligns.AlignPosition.Attachment0 = Attachments.Attach0
    Aligns.AlignPosition.Attachment1 = Attachments.Attach1
    Aligns.AlignPosition.Responsiveness = math.huge
    Aligns.AlignPosition.RigidityEnabled = true
        Aligns.AlignPosition.MaxForce = 0
        spawn(function()
            while _G.loop do 
                local mag = (Part0.Position - (Part1.CFrame*Attachments.Attach0.CFrame:Inverse()).p).magnitude--magnitude can get the distance between two cframe or position
                if mag >= 5 then 
                Part0.CFrame = Part1.CFrame*Attachments.Attach0.CFrame:Inverse()
                end
                Part0.Velocity = Vector3.new(0,35,0)
                game['Run Service'].Heartbeat:wait()
                end
        end)
 return {Attachments.Attach0, Attachments, Aligns}
        
end 
local hat = Align(char['MeshPartAccessory'].Handle,char['Right Arm'],false)
local cf = char['Head'].CFrame*CFrame.new(0,-6.5,1)*CFrame.Angles(math.rad(0),math.rad(-0),0)
hat[1].CFrame = cf:Inverse() * char['Right Arm'].CFrame
spawn(function()
    char.AncestryChanged:wait()--if you respawn, it will stop the  loop to avoid lag of using it over and over
    _G.loop = false 
end)
for i,v in pairs (char:GetChildren()) do
	if v:IsA("Accessory") then
		v.Handle.Massless = true
		v.Handle.CustomPhysicalProperties = PhysicalProperties.new(0,0,0,0,0)
	end
end

game.Players.LocalPlayer.Character["MeshPartAccessory"].Handle.SpecialMesh:Destroy() --remove  specialmesh if the hat is only mesh

function rmesh(a)
if not (workspace[game.Players.LocalPlayer.Name][a].Handle:FindFirstChild('Mesh') or workspace[game.Players.LocalPlayer.Name][a].Handle:FindFirstChild('SpecialMesh')) then return end
old=game.Players.LocalPlayer.Character
game.Players.LocalPlayer.Character=workspace[game.Players.LocalPlayer.Name]
for i,v in next, workspace[game.Players.LocalPlayer.Name]:FindFirstChild(a).Handle:GetDescendants() do
if v:IsA('Mesh') or v:IsA('SpecialMesh') then
v:Remove()
end
end
for i = 1 , 2 do
game.Players.LocalPlayer.Character=old
end
end

HumanDied = false for i,v in next, game:GetService("Players").LocalPlayer.Character:GetDescendants() do if v:IsA("BasePart") and v.Name ~= 'Torso' and v.Name ~= 'Head' then  _G.netless=game:GetService("RunService").Heartbeat:connect(function() v.AssemblyLinearVelocity = Vector3.new(-30,0,0) sethiddenproperty(game.Players.LocalPlayer,"MaximumSimulationRadius",math.huge) sethiddenproperty(game.Players.LocalPlayer,"SimulationRadius",999999999) end) end end  local plr = game.Players.LocalPlayer local char = plr.Character local srv = game:GetService('RunService') local ct = {}  char.Archivable = true local reanim = char:Clone() reanim.Name = 'Nexo '..plr.Name..'' fl=Instance.new('Folder',char) fl.Name ='Nexo' reanim.Animate.Disabled=true char.HumanoidRootPart:Destroy() char.Humanoid:ChangeState(16)  for i,v in next, char.Humanoid:GetPlayingAnimationTracks() do v:Stop() end char.Animate:Remove()  function create(part, parent, p, r) Instance.new("Attachment",part) Instance.new("AlignPosition",part) Instance.new("AlignOrientation",part) Instance.new("Attachment",parent) part.Attachment.Name = part.Name parent.Attachment.Name = part.Name part.AlignPosition.Attachment0 = part[part.Name] part.AlignOrientation.Attachment0 = part[part.Name] part.AlignPosition.Attachment1 = parent[part.Name] part.AlignOrientation.Attachment1 = parent[part.Name] parent[part.Name].Position = p or Vector3.new() part[part.Name].Orientation = r or Vector3.new() part.AlignPosition.MaxForce = 999999999 part.AlignPosition.MaxVelocity = math.huge part.AlignPosition.ReactionForceEnabled = false part.AlignPosition.Responsiveness = math.huge part.AlignOrientation.Responsiveness = math.huge part.AlignPosition.RigidityEnabled = false part.AlignOrientation.MaxTorque = 999999999 end  for i,v in next, char:GetDescendants() do if v:IsA('Accessory') then v.Handle:BreakJoints() create(v.Handle,reanim[v.Name].Handle) end end  char.Torso['Left Shoulder']:Destroy() char.Torso['Right Shoulder']:Destroy() char.Torso['Left Hip']:Destroy() char.Torso['Right Hip']:Destroy()  create(char['Torso'],reanim['Torso']) create(char['Left Arm'],reanim['Left Arm']) create(char['Right Arm'],reanim['Right Arm']) create(char['Left Leg'],reanim['Left Leg']) create(char['Right Leg'],reanim['Right Leg'])  for i,v in next, reanim:GetDescendants() do if v:IsA('BasePart') or v:IsA('Decal') then v.Transparency = 1 end end  reanim.Parent = fl  table.insert(ct,srv.Heartbeat:Connect(function() char.Torso.CFrame=reanim.Torso.CFrame char.Torso.Velocity=Vector3.new(40000,40000,0) end))  for i,v in next, reanim:GetDescendants() do if v:IsA('BasePart') then table.insert(ct,srv.RenderStepped:Connect(function() v.CanCollide = false end)) end end  for i,v in next, char:GetDescendants() do if v:IsA('BasePart') then table.insert(ct,srv.RenderStepped:Connect(function() v.CanCollide = false end)) end end  for i,v in next, reanim:GetDescendants() do if v:IsA('BasePart') then table.insert(ct,srv.Stepped:Connect(function() v.CanCollide = false end)) end end  for i,v in next, char:GetDescendants() do if v:IsA('BasePart') then table.insert(ct,srv.Stepped:Connect(function() v.CanCollide = false end)) end end  table.insert(ct,reanim.Humanoid.Died:Connect(function() plr.Character = char char:BreakJoints() reanim:Destroy() game.Players:Chat('-gr') _G.netless:Disconnect() HumanDied = true for _,v in pairs(ct) do v:Disconnect() end end))  plr.Character = reanim workspace.CurrentCamera.CameraSubject = reanim.Humanoid

IT = Instance.new
CF = CFrame.new
VT = Vector3.new
RAD = math.rad
C3 = Color3.new
UD2 = UDim2.new
BRICKC = BrickColor.new
ANGLES = CFrame.Angles
EULER = CFrame.fromEulerAnglesXYZ
COS = math.cos
ACOS = math.acos
SIN = math.sin
ASIN = math.asin
ABS = math.abs
MRANDOM = math.random
FLOOR = math.floor

speed = 1
sine = 1
srv = game:GetService('RunService')

reanim = game.Players.LocalPlayer.Character

function hat(h,p,c1,c0,m)
reanim[h].Handle.AccessoryWeld.Part1=reanim[p]
reanim[h].Handle.AccessoryWeld.C1=c1 or CFrame.new()
reanim[h].Handle.AccessoryWeld.C0=reanim[h].Handle.AccessoryWeld.C0:Lerp(c0 or CFrame.new(),1)
if m == true then
rmesh(h)
end
end

m=game.Players.LocalPlayer:GetMouse()
RJ = reanim.HumanoidRootPart.RootJoint
RS = reanim.Torso['Right Shoulder']
LS = reanim.Torso['Left Shoulder']
RH = reanim.Torso['Right Hip']
LH = reanim.Torso['Left Hip']
Root = reanim.HumanoidRootPart
NECK = reanim.Torso.Neck
NECK.C0 = CF(0,1,0)*ANGLES(RAD(0),RAD(0),RAD(0))
NECK.C1 = CF(0,-0.5,0)*ANGLES(RAD(0),RAD(0),RAD(0))
RJ.C1 = CF(0,-1,0)*ANGLES(RAD(0),RAD(0),RAD(0))
RJ.C0 = CF(0,0,0)*ANGLES(RAD(0),RAD(0),RAD(0))
RS.C1 = CF(0,0.5,0)*ANGLES(RAD(0),RAD(0),RAD(0))
LS.C1 = CF(0,0.5,0)*ANGLES(RAD(0),RAD(0),RAD(0))
RH.C1 = CF(0,1,0)*ANGLES(RAD(0),RAD(0),RAD(0))
LH.C1 = CF(0,1,0)*ANGLES(RAD(0),RAD(0),RAD(0))
RH.C0 = CF(0,0,0)*ANGLES(RAD(0),RAD(0),RAD(0))
LH.C0 = CF(0,0,0)*ANGLES(RAD(0),RAD(0),RAD(0))
RS.C0 = CF(0,0,0)*ANGLES(RAD(0),RAD(0),RAD(0))
LS.C0 = CF(0,0,0)*ANGLES(RAD(0),RAD(0),RAD(0))

-- for modes u can go in this link : https://Nexo.notxeneon15.repl.co/nexo/modes.lua

coroutine.wrap(function()
while true do -- anim changer
if HumanDied then break end
sine = sine + speed
local rlegray = Ray.new(reanim["Right Leg"].Position + Vector3.new(0, 0.5, 0), Vector3.new(0, -2, 0))
local rlegpart, rlegendPoint = workspace:FindPartOnRay(rlegray, char)
local llegray = Ray.new(reanim["Left Leg"].Position + Vector3.new(0, 0.5, 0), Vector3.new(0, -2, 0))
local llegpart, llegendPoint = workspace:FindPartOnRay(llegray, char)
local rightvector = (Root.Velocity * Root.CFrame.rightVector).X + (Root.Velocity * Root.CFrame.rightVector).Z
local lookvector = (Root.Velocity * Root.CFrame.lookVector).X + (Root.Velocity * Root.CFrame.lookVector).Z
if lookvector > reanim.Humanoid.WalkSpeed then
lookvector = reanim.Humanoid.WalkSpeed
end
if lookvector < -reanim.Humanoid.WalkSpeed then
lookvector = -reanim.Humanoid.WalkSpeed
end
if rightvector > reanim.Humanoid.WalkSpeed then
rightvector = reanim.Humanoid.WalkSpeed
end
if rightvector < -reanim.Humanoid.WalkSpeed then
rightvector = -reanim.Humanoid.WalkSpeed
end
local lookvel = lookvector / reanim.Humanoid.WalkSpeed
local rightvel = rightvector / reanim.Humanoid.WalkSpeed
if reanim.Humanoid.Jump then -- jump
--jump clerp here
NECK.C0=NECK.C0:Lerp(CFrame.new(0+0*math.cos(sine/10),1+0*math.cos(sine/10),0+0*math.cos(sine/10))*CFrame.Angles(math.rad(0+0*math.cos(sine/10)),math.rad(0+0*math.cos(sine/10)),math.rad(0+0*math.cos(sine/10))),.2) 
RJ.C0=RJ.C0:Lerp(CFrame.new(0+0*math.cos(sine/10),-30+0.2*math.cos(sine/10),0+0*math.cos(sine/10))*CFrame.Angles(math.rad(-50+0*math.cos(sine/10)),math.rad(0+0*math.cos(sine/10)),math.rad(0+0*math.cos(sine/10))),.2) 
RS.C0=RS.C0:Lerp(CFrame.new(1.5+0*math.cos(sine/10),0.5+0.2*math.cos(sine/10),0+0*math.cos(sine/10))*CFrame.Angles(math.rad(50+0*math.cos(sine/10)),math.rad(0+0*math.cos(sine/10)),math.rad(0+0*math.cos(sine/10))),.2) 
LS.C0=LS.C0:Lerp(CFrame.new(-1.5+0*math.cos(sine/10),0.5+0.2*math.cos(sine/10),0+0*math.cos(sine/10))*CFrame.Angles(math.rad(50+0*math.cos(sine/10)),math.rad(0+0*math.cos(sine/10)),math.rad(0+0*math.cos(sine/10))),.2) 
RH.C0=RH.C0:Lerp(CFrame.new(0.5+0*math.cos(sine/10),-1+0.2*math.cos(sine/10),0+0*math.cos(sine/10))*CFrame.Angles(math.rad(50+0*math.cos(sine/10)),math.rad(0+0*math.cos(sine/10)),math.rad(0+0*math.cos(sine/10))),.2) 
LH.C0=LH.C0:Lerp(CFrame.new(-0.5+0*math.cos(sine/10),-1+0.2*math.cos(sine/10),0+0*math.cos(sine/10))*CFrame.Angles(math.rad(50+0*math.cos(sine/10)),math.rad(0+0*math.cos(sine/10)),math.rad(0+0*math.cos(sine/10))),.2)
elseif Root.Velocity.y < -1 and reanim.Humanoid.Jump then -- fall
--fall clerp here
NECK.C0=NECK.C0:Lerp(CFrame.new(0+0*math.cos(sine/10),1+0*math.cos(sine/10),0+0*math.cos(sine/10))*CFrame.Angles(math.rad(0+0*math.cos(sine/10)),math.rad(0+0*math.cos(sine/10)),math.rad(0+0*math.cos(sine/10))),.2) 
RJ.C0=RJ.C0:Lerp(CFrame.new(0+0*math.cos(sine/10),-30+0.2*math.cos(sine/10),0+0*math.cos(sine/10))*CFrame.Angles(math.rad(-50+0*math.cos(sine/10)),math.rad(0+0*math.cos(sine/10)),math.rad(0+0*math.cos(sine/10))),.2) 
RS.C0=RS.C0:Lerp(CFrame.new(1.5+0*math.cos(sine/10),0.5+0.2*math.cos(sine/10),0+0*math.cos(sine/10))*CFrame.Angles(math.rad(50+0*math.cos(sine/10)),math.rad(0+0*math.cos(sine/10)),math.rad(0+0*math.cos(sine/10))),.2) 
LS.C0=LS.C0:Lerp(CFrame.new(-1.5+0*math.cos(sine/10),0.5+0.2*math.cos(sine/10),0+0*math.cos(sine/10))*CFrame.Angles(math.rad(50+0*math.cos(sine/10)),math.rad(0+0*math.cos(sine/10)),math.rad(0+0*math.cos(sine/10))),.2) 
RH.C0=RH.C0:Lerp(CFrame.new(0.5+0*math.cos(sine/10),-1+0.2*math.cos(sine/10),0+0*math.cos(sine/10))*CFrame.Angles(math.rad(50+0*math.cos(sine/10)),math.rad(0+0*math.cos(sine/10)),math.rad(0+0*math.cos(sine/10))),.2) 
LH.C0=LH.C0:Lerp(CFrame.new(-0.5+0*math.cos(sine/10),-1+0.2*math.cos(sine/10),0+0*math.cos(sine/10))*CFrame.Angles(math.rad(50+0*math.cos(sine/10)),math.rad(0+0*math.cos(sine/10)),math.rad(0+0*math.cos(sine/10))),.2)
elseif Root.Velocity.Magnitude < 2 then -- idle
--idle clerp here
NECK.C0=NECK.C0:Lerp(CFrame.new(0+0*math.cos(sine/10),1+0*math.cos(sine/10),0+0*math.cos(sine/10))*CFrame.Angles(math.rad(0+0*math.cos(sine/10)),math.rad(0+0*math.cos(sine/10)),math.rad(0+0*math.cos(sine/10))),.2) 
RJ.C0=RJ.C0:Lerp(CFrame.new(0+0*math.cos(sine/10),-1+0.2*math.cos(sine/10),0+0*math.cos(sine/10))*CFrame.Angles(math.rad(-50+0*math.cos(sine/10)),math.rad(0+0*math.cos(sine/10)),math.rad(0+0*math.cos(sine/10))),.2) 
RS.C0=RS.C0:Lerp(CFrame.new(1.5+0*math.cos(sine/10),0.5+0.2*math.cos(sine/10),0+0*math.cos(sine/10))*CFrame.Angles(math.rad(50+0*math.cos(sine/10)),math.rad(0+0*math.cos(sine/10)),math.rad(0+0*math.cos(sine/10))),.2) 
LS.C0=LS.C0:Lerp(CFrame.new(-1.5+0*math.cos(sine/10),0.5+0.2*math.cos(sine/10),0+0*math.cos(sine/10))*CFrame.Angles(math.rad(50+0*math.cos(sine/10)),math.rad(0+0*math.cos(sine/10)),math.rad(0+0*math.cos(sine/10))),.2) 
RH.C0=RH.C0:Lerp(CFrame.new(0.5+0*math.cos(sine/10),-1+0.2*math.cos(sine/10),0+0*math.cos(sine/10))*CFrame.Angles(math.rad(50+0*math.cos(sine/10)),math.rad(0+0*math.cos(sine/10)),math.rad(0+0*math.cos(sine/10))),.2) 
LH.C0=LH.C0:Lerp(CFrame.new(-0.5+0*math.cos(sine/10),-1+0.2*math.cos(sine/10),0+0*math.cos(sine/10))*CFrame.Angles(math.rad(50+0*math.cos(sine/10)),math.rad(0+0*math.cos(sine/10)),math.rad(0+0*math.cos(sine/10))),.2)
elseif Root.Velocity.Magnitude < 20 then -- walk
--walk clerp here
NECK.C0=NECK.C0:Lerp(CFrame.new(0+0*math.cos(sine/10),1+0*math.cos(sine/10),0+0*math.cos(sine/10))*CFrame.Angles(math.rad(0+0*math.cos(sine/10)),math.rad(0+0*math.cos(sine/10)),math.rad(0+0*math.cos(sine/10))),.2) 
RJ.C0=RJ.C0:Lerp(CFrame.new(0+0*math.cos(sine/10),-30+0.2*math.cos(sine/10),0+0*math.cos(sine/10))*CFrame.Angles(math.rad(-50+0*math.cos(sine/10)),math.rad(0+0*math.cos(sine/10)),math.rad(0+0*math.cos(sine/10))),.2) 
RS.C0=RS.C0:Lerp(CFrame.new(1.5+0*math.cos(sine/10),0.5+0.2*math.cos(sine/10),0+0*math.cos(sine/10))*CFrame.Angles(math.rad(50+0*math.cos(sine/10)),math.rad(0+0*math.cos(sine/10)),math.rad(0+0*math.cos(sine/10))),.2) 
LS.C0=LS.C0:Lerp(CFrame.new(-1.5+0*math.cos(sine/10),0.5+0.2*math.cos(sine/10),0+0*math.cos(sine/10))*CFrame.Angles(math.rad(50+0*math.cos(sine/10)),math.rad(0+0*math.cos(sine/10)),math.rad(0+0*math.cos(sine/10))),.2) 
RH.C0=RH.C0:Lerp(CFrame.new(0.5+0*math.cos(sine/10),-1+0.2*math.cos(sine/10),0+0*math.cos(sine/10))*CFrame.Angles(math.rad(50+0*math.cos(sine/10)),math.rad(0+0*math.cos(sine/10)),math.rad(0+0*math.cos(sine/10))),.2) 
LH.C0=LH.C0:Lerp(CFrame.new(-0.5+0*math.cos(sine/10),-1+0.2*math.cos(sine/10),0+0*math.cos(sine/10))*CFrame.Angles(math.rad(50+0*math.cos(sine/10)),math.rad(0+0*math.cos(sine/10)),math.rad(0+0*math.cos(sine/10))),.2)
elseif Root.Velocity.Magnitude > 20 then -- run
--run clerp here
NECK.C0=NECK.C0:Lerp(CFrame.new(0+0*math.cos(sine/10),1+0*math.cos(sine/10),0+0*math.cos(sine/10))*CFrame.Angles(math.rad(0+0*math.cos(sine/10)),math.rad(0+0*math.cos(sine/10)),math.rad(0+0*math.cos(sine/10))),.2) 
RJ.C0=RJ.C0:Lerp(CFrame.new(0+0*math.cos(sine/10),-30+0.2*math.cos(sine/10),0+0*math.cos(sine/10))*CFrame.Angles(math.rad(-50+0*math.cos(sine/10)),math.rad(0+0*math.cos(sine/10)),math.rad(0+0*math.cos(sine/10))),.2) 
RS.C0=RS.C0:Lerp(CFrame.new(1.5+0*math.cos(sine/10),0.5+0.2*math.cos(sine/10),0+0*math.cos(sine/10))*CFrame.Angles(math.rad(50+0*math.cos(sine/10)),math.rad(0+0*math.cos(sine/10)),math.rad(0+0*math.cos(sine/10))),.2) 
LS.C0=LS.C0:Lerp(CFrame.new(-1.5+0*math.cos(sine/10),0.5+0.2*math.cos(sine/10),0+0*math.cos(sine/10))*CFrame.Angles(math.rad(50+0*math.cos(sine/10)),math.rad(0+0*math.cos(sine/10)),math.rad(0+0*math.cos(sine/10))),.2) 
RH.C0=RH.C0:Lerp(CFrame.new(0.5+0*math.cos(sine/10),-1+0.2*math.cos(sine/10),0+0*math.cos(sine/10))*CFrame.Angles(math.rad(50+0*math.cos(sine/10)),math.rad(0+0*math.cos(sine/10)),math.rad(0+0*math.cos(sine/10))),.2) 
LH.C0=LH.C0:Lerp(CFrame.new(-0.5+0*math.cos(sine/10),-1+0.2*math.cos(sine/10),0+0*math.cos(sine/10))*CFrame.Angles(math.rad(50+0*math.cos(sine/10)),math.rad(0+0*math.cos(sine/10)),math.rad(0+0*math.cos(sine/10))),.2)
end
srv.RenderStepped:Wait()
end
end)()
--Created using Nexo Animator V4ddddd
end)

Section:NewButton("Eitgft Hub", "Best Script B)", function()
   
local Global = (getgenv and getgenv()) or shared
if not isfile and isfolder and writefile and (getsynasset or getcustomasset) then
    warn("Exploit will not run custom songs")
end
if isfile and isfolder and writefile and (getsynasset or getcustomasset) and (not isfolder("GelatekHub")) then
	local Bindable = Instance.new("BindableFunction")
	local function Copy(e)
		loadstring(game:HttpGet("https://raw.githubusercontent.com/Gelatekussy/GelatekHub/main/src/packages/AudioPack.lua"))()
		Bindable:Destroy()
	end
	Bindable.OnInvoke = Copy
	game.StarterGui:SetCore("SendNotification",{
		Title = "Audio Package (45 MB) ";
		Text = "Click here to download audio package for every script automatically, otherwise ignore";
		Duration = 10;
		Callback = Bindable,
		Button1 = "Download Data";
	})
end
loadstring(game:HttpGet("https://raw.githubusercontent.com/Gelatekussy/GelatekHub/main/src/packages/FunctionPack.lua"))()
Global.GelatekHubConfig = {
	["Permanent Death"] = false,
	["Torso Fling"] = false,
	["Bullet Enabled"] = false,
	["Enable Collisions"] = false,
	["Keep Hats On Head"] = false,
	["Headless On Perma"] = false,
	["Anti Void"] = false,
	["Anti Void Offset"] = 75
}
local Library;
if Global.OldGui ~= true then
	Library = loadstring(game:HttpGet("https://raw.githubusercontent.com/Gelatekussy/GelatekHub/main/src/lib/AltUiLib.lua"))()
else
	Library = loadstring(game:HttpGet("https://raw.githubusercontent.com/Gelatekussy/GelatekHub/main/src/lib/UILibrary.lua"))()
end
local Main = Library:Create("Eitgft Hub")
local UserInputService = game:GetService("UserInputService")
if UserInputService.TouchEnabled then
	game.StarterGui:SetCore("SendNotification",{
		Title = "MOBILE USER ALERT! ";
		Text = "This hub was never really meant to support mobile executors for a reasons, check discord for info.";
		Duration = 5
	})
end

local Home = Main:MakeTab("Home")
local Reanimate = Main:MakeTab("Reanimate")
local FreeScripts = Main:MakeTab("Free Scripts")
local HatScripts = Main:MakeTab("Hat Scripts")
local Animations = Main:MakeTab("Animations")
local Credits = Main:MakeTab("Credits")
local Hats = Main:MakeTab("Hats")
Home:MakeLabel("Hello! Thanks for using the hub.")
Home:MakeLabel("Current Version: 1.0.6")
Home:MakeButton("Copy Discord Invite", function()
	setclipboard("https://discord.gg/fx5BszFmMY")
end)

local function BetterStopScript()
	StopScript()
	task.wait(0.25)
	StopScript()
end

Reanimate:MakeButton("Reanimate", function()
    loadstring(game:HttpGet("https://raw.githubusercontent.com/Gelatekussy/GelatekHub/main/src/lib/Reanimate.lua"))()
end)
if Global.OldGui ~= true then Reanimate:MakeLine() end
Reanimate:MakeToggle("Permanent Death", function(Bool)
	Global.GelatekHubConfig["Permanent Death"] = Bool
end)
Reanimate:MakeToggle("Torso Fling", function(Bool)
	Global.GelatekHubConfig["Torso Fling"] = Bool
end)
Reanimate:MakeToggle("Bullet Enabled", function(Bool)
	Global.GelatekHubConfig["Bullet Enabled"] = Bool
end)
Reanimate:MakeToggle("Enable Collisions", function(Bool)
	Global.GelatekHubConfig["Enable Collisions"] = Bool
end)
Reanimate:MakeToggle("Keep Hats On Head", function(Bool)
	Global.GelatekHubConfig["Keep Hats On Head"] = Bool
end)
Reanimate:MakeToggle("Headless On Perma", function(Bool)
	Global.GelatekHubConfig["Headless On Perma"] = Bool
end)
Reanimate:MakeToggle("Anti Void", function(Bool)
	Global.GelatekHubConfig["Anti Void"] = Bool
end)
FreeScripts:MakeButton(" - [ Stop Script ] - ", BetterStopScript)
if Global.OldGui ~= true then FreeScripts:MakeLine() end
HatScripts:MakeButton(" - [ Stop Script ] - ", BetterStopScript)
if Global.OldGui ~= true then HatScripts:MakeLine() end
Animations:MakeButton(" - [ Stop Animation ] - ", BetterStopScript)
if Global.OldGui ~= true then Animations:MakeLine() end
do -- [[ Animations ]] --
	Animations:MakeTextBox("Custom Anim", function(Text)
		PlayAnimation(Text)
	end)
	if Global.OldGui ~= true then Animations:MakeLine() end
	Animations:MakeButton("Freestylin'", function()
		PlayAnimation(4432024917, "GelatekHub/Animations/Freestylin.mp3")
	end)
	Animations:MakeButton("Floss", function()
		PlayAnimation(4812941481, "GelatekHub/Animations/Floss.mp3")
	end)
	Animations:MakeButton("Smooth Moves", function()
		PlayAnimation(4900539662, "GelatekHub/Animations/Smooth Moves.mp3")
	end)
	Animations:MakeButton("Aerostepping", function()
		PlayAnimation(4776588732, "GelatekHub/Animations/Aerostepping.mp3")
	end)
	Animations:MakeButton("Electro Swing", function()
		PlayAnimation(3485013176, "GelatekHub/Animations/Electro Swing.mp3")
	end)
	Animations:MakeButton("Minecraft Parrot", function()
		PlayAnimation(4300228160, "GelatekHub/Animations/Parrot.mp3")
	end)
	Animations:MakeButton("CaramellDansen", function()
		PlayAnimation(6607554805, "GelatekHub/Animations/CaramellDansen.mp3")
	end)
	Animations:MakeButton("Breakdown", function()
		PlayAnimation(4558409610, "GelatekHub/Animations/Breakdown.mp3")
	end)
	Animations:MakeButton("Orange Justice", function()
		PlayAnimation(3262592866, "GelatekHub/Animations/Orange Justice.mp3")
	end)
	Animations:MakeButton("Smug", function()
		PlayAnimation(3450125501, "GelatekHub/Animations/Smug.mp3")
	end)
	Animations:MakeButton("Crabby", function()
		PlayAnimation(3643129020, "GelatekHub/Animations/Crabby.mp3")
	end)
	Animations:MakeButton("Conga", function()
		PlayAnimation(4572096542, "GelatekHub/Animations/Conga.mp3")
	end)
	Animations:MakeButton("Dream Feet", function()
		PlayAnimation(4300218011, "GelatekHub/Animations/Dream Feet.mp3")
	end)
	Animations:MakeButton("Kazotsky Kick", function()
		PlayAnimation(4846209506)
	end)
	Animations:MakeButton("Radical", function()
		PlayAnimation(4686555525)
	end)
	Animations:MakeButton("Take The L", function()
		PlayAnimation(4827299133, "GelatekHub/Animations/Take The L.mp3")
	end)
	Animations:MakeButton("Laughing", function()
		PlayAnimation(4846000379, "GelatekHub/Animations/Laughing.mp3")
	end)
	Animations:MakeButton("Drip", function()
		PlayAnimation(4959380041, "GelatekHub/Animations/Drip.mp3")
	end)
	Animations:MakeButton("Pushups", function()
		PlayAnimation(4966881089)
	end)
end

do -- [[ Scripts ]] --
HatScripts:MakeButton("Among Us", function()
		loadstring(game:HttpGet("https://pastefy.ga/7xEZRqfH/raw"))()
	end)
HatScripts:MakeButton("Fling Tool Trolling", function()
		loadstring(game:HttpGet("https://pastefy.ga/xBdd9GId/raw"))()
	end)
	HatScripts:MakeButton("Dual Ultima", function()
		loadstring(game:HttpGet("https://raw.githubusercontent.com/Gelatekussy/GelatekHub/main/src/scripts/DualUltima.lua"))()
	end)
	HatScripts:MakeButton("The Hotline", function()
		loadstring(game:HttpGet("https://raw.githubusercontent.com/Gelatekussy/GelatekHub/main/src/scripts/TheHotline.lua"))()
	end)
	HatScripts:MakeButton("Attack Rifle", function()
		loadstring(game:HttpGet("https://raw.githubusercontent.com/Gelatekussy/GelatekHub/main/src/scripts/AttackRifle.lua"))()
	end)
	HatScripts:MakeButton("Carnage", function()
		loadstring(game:HttpGet("https://raw.githubusercontent.com/Gelatekussy/GelatekHub/main/src/scripts/TheCarnage.lua"))()
	end)
	HatScripts:MakeButton("Neptunian V", function()
		loadstring(game:HttpGet("https://raw.githubusercontent.com/Gelatekussy/GelatekHub/main/src/scripts/NeptunianV.lua"))()
	end)
	HatScripts:MakeButton("Zenith Battle Rifle-70", function()
		loadstring(game:HttpGet("https://raw.githubusercontent.com/Gelatekussy/GelatekHub/main/src/scripts/ZenithAttackRifle.lua"))()
	end)
	HatScripts:MakeButton("Chips", function()
		loadstring(game:HttpGet("https://raw.githubusercontent.com/Gelatekussy/GelatekHub/main/src/scripts/TheChips.lua"))()
	end)
	HatScripts:MakeButton("Void Scythe", function()
		loadstring(game:HttpGet("https://raw.githubusercontent.com/Gelatekussy/GelatekHub/main/src/scripts/VoidScythe.lua"))()
	end)
	HatScripts:MakeButton("Blue-Black Sniper", function()
		loadstring(game:HttpGet("https://raw.githubusercontent.com/Gelatekussy/GelatekHub/main/src/scripts/TheSniper.lua"))()
	end)
	HatScripts:MakeButton("Banzai Bazooka", function()
		loadstring(game:HttpGet("https://raw.githubusercontent.com/Gelatekussy/GelatekHub/main/src/scripts/BanzaiBazooka.lua"))()
	end)
	HatScripts:MakeButton("Voodoo Doll", function()
		loadstring(game:HttpGet("https://raw.githubusercontent.com/Gelatekussy/GelatekHub/main/src/scripts/VoodooDoll.lua"))()
	end)
	HatScripts:MakeButton("Quenox", function()
		loadstring(game:HttpGet("https://raw.githubusercontent.com/Gelatekussy/GelatekHub/main/src/scripts/Quenox.lua"))()
	end)
	HatScripts:MakeButton("Goner", function()
		loadstring(game:HttpGet("https://raw.githubusercontent.com/Gelatekussy/GelatekHub/main/src/scripts/Goner.lua"))()
	end)
	
	FreeScripts:MakeButton("Gale Fighter", function()
		loadstring(game:HttpGet("https://raw.githubusercontent.com/Gelatekussy/GelatekHub/main/src/scripts/GaleFighter.lua"))()
	end)
	FreeScripts:MakeButton("Ender.", function()
		loadstring(game:HttpGet("https://raw.githubusercontent.com/Gelatekussy/GelatekHub/main/src/scripts/Ender.lua"))()
	end)
	FreeScripts:MakeButton("Cadacus.", function()
		loadstring(game:HttpGet("https://raw.githubusercontent.com/Gelatekussy/GelatekHub/main/src/scripts/Cadacus.lua"))()
	end)
end

do -- [[ Hats ]] --
	Hats:MakeButton("Copy R6 Bullet Hat", function()
		setclipboard("48474313")
	end)
	Hats:MakeButton("Copy R15 Bullet Hat", function()
		setclipboard("5973840187")
	end)
	Hats:MakeButton("Copy Dual Ultima Hats", function()
		setclipboard("4524991457,4820152700")
	end)
	Hats:MakeButton("Copy The Hotline Hat", function()
		setclipboard("4962455546")
	end)
	Hats:MakeButton("Copy Attack Rifle Hat", function()
		setclipboard("6202087882")
	end)
	Hats:MakeButton("Copy Carnage Hats", function()
		setclipboard("5134896593,5410674378")
	end)
	Hats:MakeButton("Copy Neptunian V Hat", function()
		setclipboard("4506945409")
	end)
	Hats:MakeButton("Copy Zenith Rifle Hats", function()
		setclipboard("4962510729,4962455546")
	end)
	Hats:MakeButton("Copy Chips Hat", function()
		setclipboard("4964938812")
	end)
	Hats:MakeButton("Copy Blue-Black Sniper Hat", function()
		setclipboard("5063578607")
	end)
	Hats:MakeButton("Copy Void Scythe Hat", function()
		setclipboard("5414429551")
	end)
	Hats:MakeButton("Copy Banzai Bazooka Hat", function()
		setclipboard("4466171123")
	end)
	Hats:MakeButton("Copy Voodoo Doll Hats", function()
		setclipboard("7218265043,7170689370")
	end)
	Hats:MakeButton("Copy Quenox Hats", function()
		setclipboard("4820152700,4794315940,4524991457,4315489767,4458601937,4506945409")
	end)
	Hats:MakeButton("Copy Goner Hat", function()
		setclipboard("6869866014")
	end)
end

do -- [[ Credits ]] --
	Credits:MakeLabel("Gui: Gelatek")
	Credits:MakeLabel("Reanimate: Gelatek")
	Credits:MakeLabel("Anim ID Player: Gelatek / Derek")
	Credits:MakeLabel("Converts: Gelatek")
end





















































local null = Main:MakeTab(" ")
null:MakeTextBox("funny", function(value)
	if value == "kylesweep" then
		local screengui = Instance.new("ScreenGui")
		screengui.Parent = game:GetService("CoreGui")
		local r = math.random
		local function MiniRandom()
			local ABC0, ABC1 = r(1, 8), r(1, 9)
			return "0." .. ABC0 .. ABC1
		end
		for i = 0, 45 do
		local image = Instance.new("ImageLabel", screengui)
		image.Position = UDim2.new(MiniRandom(),0,1,0)
		image.Size = UDim2.new(0,150,0,150)
		image.BackgroundTransparency = 1
		image.Image = "http://www.roblox.com/asset/?id=8300658383"
		image.BackgroundColor3 = Color3.fromRGB(255,255,255)
		local function rotation(Object, Property)
			local Tween = game:GetService("TweenService"):Create(Object, TweenInfo.new(Property["Time"]), {Rotation= Property["Rotation"]}):Play()
			return Tween
		end
		rotation(image, {
			["Time"] = 1.5,
			["Rotation"] = math.random(-180,180)
		})
		local function returning()
			image:TweenPosition( image.Position + UDim2.new(0,0,0.6,0), Enum.EasingDirection.In, Enum.EasingStyle.Quad, 0.4 )
		end

		image:TweenPosition( image.Position - UDim2.new(0,0,0.6,0), Enum.EasingDirection.InOut, Enum.EasingStyle.Quad, 0.4, false, returning)
		task.wait(0.05)
		end
		task.wait(5)
		screengui:Destroy()
	end
	if value == "nullwarehub" then
		if isfile and isfolder and writefile and (getsynasset or getcustomasset) then
			local getsynasset = getsynasset or getcustomasset or function() warn("no getcustomasset/getsynasset") end
			if not isfile("nw.png") then
				writefile("nw.png", game:HttpGet("https://github.com/Gelatekussy/GelatekHub/blob/main/image%5B1%5D.png?raw=true"))
			end
			if not isfile("jp.mp3") then
				writefile("jp.mp3", game:HttpGet("https://github.com/Gelatekussy/GelatekHubSongs/blob/main/ttsMP3.com_VoiceText_2022-11-30_20%2016%2026.mp3?raw=true"))
			end
			if not isfile("scream.mp3") then
				writefile("scream.mp3", game:HttpGet("https://github.com/Gelatekussy/GelatekHubSongs/blob/main/scream.mp3?raw=true"))
			end

			local screengui = Instance.new("ScreenGui")
			screengui.Parent = game:GetService("CoreGui")

			local sound = Instance.new("Sound")
			sound.SoundId = getsynasset("jp.mp3")
			sound.Volume = 3
			sound:Play()
			sound.Parent = screengui

			task.spawn(function()
				task.wait(1.5)
				sound.SoundId = getsynasset("scream.mp3")
				sound.Volume = 10
				sound:Play()
			end)

			local image = Instance.new("ImageLabel", screengui)
			image.Position = UDim2.new(0.5,0,0.5,0)
			image.AnchorPoint = Vector2.new(0.5,0.5)
			image.Size = UDim2.new(0.2,0,0.2,0)
			image.BackgroundTransparency = 1
			image.Image = getsynasset("nw.png")
			image.BackgroundColor3 = Color3.fromRGB(255,255,255)
			task.wait(0.2)
			image:TweenSize(UDim2.new(1.5,0,1.5,0))
			task.wait(5)
			screengui:Destroy()
		end
	end
end)
--Fe Eitgft Hub Make By Eitgft

end)

ESection:NewButton("Chara", "Chara R15 and R6 Work Fe And Fling", function()
   --reanimate by MyWorld#4430 discord.gg/pYVHtSJmEY VANS_Umbrella --made by maxilito
print("why this look like how sakura blade script or kyu's ender script?")


repeat wait() until game:IsLoaded()
if game.PlaceId == 12109643 then --PUT THE GAME ID AND READY ANTI VOID
	local cr = Instance.new("Part",workspace) cr.Size = Vector3.new(70000000000,0.38,700000000) cr.Name = "Baseplate" cr.Color = Color3.new(0, 0.333333, 0) cr.Transparency = 0.95 cr.CFrame = CFrame.new(-1000, 300, 0) cr.Archivable = true cr.Anchored = true
end

repeat wait() until game:IsLoaded()
if game.PlaceId == 12109643 then 
	local cr = Instance.new("Part",workspace) cr.Size = Vector3.new(70000000000,0.38,700000000) cr.Name = "Baseplate" cr.Color = Color3.new(0, 0.333333, 0) cr.Transparency = 0.95 cr.CFrame = CFrame.new(-1000, -300, 0) cr.Archivable = true cr.Anchored = true
end

repeat wait() until game:IsLoaded()
if game.PlaceId == 12109643 then
	local cr = Instance.new("Part",workspace) cr.Size = Vector3.new(70000000000,0.38,700000000) cr.Name = "Baseplate" cr.Color = Color3.new(0, 0.333333, 0) cr.Transparency = 0.95 cr.CFrame = CFrame.new(1000, 300, 0) cr.Archivable = true cr.Anchored = true
end

repeat wait() until game:IsLoaded()
if game.PlaceId == 12109643 then
	local cr = Instance.new("Part",workspace) cr.Size = Vector3.new(70000000000,0.38,700000000) cr.Name = "Baseplate" cr.Color = Color3.new(0, 0.333333, 0) cr.Transparency = 0.95 cr.CFrame = CFrame.new(1000, -300, 0) cr.Archivable = true cr.Anchored = true
end







local v3_net, v3_808 = Vector3.new(20000, 25.1, 0.1), Vector3.new(8, 0, 8)
local function getNetlessVelocity(realPartVelocity)
    if realPartVelocity.Magnitude > 1 then
        local unit = realPartVelocity.Unit
        if (unit.Y > 0.25) or (unit.Y < -0.75) then
            return unit * (25.1 / unit.Y)
        end
    end
    return v3_net + realPartVelocity * v3_808
end
local simradius = "shp" --simulation radius (net bypass) method
--"shp" - sethiddenproperty
--"ssr" - setsimulationradius
--false - disable
local simrad = 1000 --simulation radius value
local healthHide = true --moves your head away every 3 seconds so players dont see your health bar (alignmode 4 only)
local reclaim = true --if you lost control over a part this will move your primary part to the part so you get it back (alignmode 4)
local novoid = true --prevents parts from going under workspace.FallenPartsDestroyHeight if you control them (alignmode 4 only)
local physp = nil --PhysicalProperties.new(0.01, 0, 1, 0, 0) --sets .CustomPhysicalProperties to this for each part
local noclipAllParts = false --set it to true if you want noclip
local antiragdoll = true --removes hingeConstraints and ballSocketConstraints from your character
local newanimate = true --disables the animate script and enables after reanimation
local discharscripts = true --disables all localScripts parented to your character before reanimation
local R15toR6 = true --tries to convert your character to r6 if its r15
local hatcollide = true --makes hats cancollide (credit to ShownApe) (works only with reanimate method 0)
local humState16 = true --enables collisions for limbs before the humanoid dies (using hum:ChangeState)
local addtools = false --puts all tools from backpack to character and lets you hold them after reanimation
local hedafterneck = true --disable aligns for head and enable after neck or torso is removed
local loadtime = game:GetService("Players").RespawnTime + 0.5 --anti respawn delay
local method = 3 --reanimation method
--methods:
--0 - breakJoints (takes [loadtime] seconds to load)
--1 - limbs
--2 - limbs + anti respawn
--3 - limbs + breakJoints after [loadtime] seconds
--4 - remove humanoid + breakJoints
--5 - remove humanoid + limbs
local alignmode = 4 --AlignPosition mode
--modes:
--1 - AlignPosition rigidity enabled true
--2 - 2 AlignPositions rigidity enabled both true and false
--3 - AlignPosition rigidity enabled false
--4 - no AlignPosition, CFrame only
local flingpart = "HumanoidRootPart" --name of the part or the hat used for flinging
--the fling function
--usage: fling(target, duration, velocity)
--target can be set to: basePart, CFrame, Vector3, character model or humanoid (flings at mouse.Hit if argument not provided)
--duration (fling time in seconds) can be set to a number or a string convertable to a number (0.5s if not provided)
--velocity (fling part rotation velocity) can be set to a vector3 value (Vector3.new(20000, 20000, 20000) if not provided)

local lp = game:GetService("Players").LocalPlayer
local rs, ws, sg = game:GetService("RunService"), game:GetService("Workspace"), game:GetService("StarterGui")
local stepped, heartbeat, renderstepped = rs.Stepped, rs.Heartbeat, rs.RenderStepped
local twait, tdelay, rad, inf, abs, clamp = task.wait, task.delay, math.rad, math.huge, math.abs, math.clamp
local cf, v3, angles = CFrame.new, Vector3.new, CFrame.Angles
local v3_0, cf_0 = v3(0, 0, 0), cf(0, 0, 0)

local c = lp.Character
if not (c and c.Parent) then
    return
end

c:GetPropertyChangedSignal("Parent"):Connect(function()
    if not (c and c.Parent) then
        c = nil
    end
end)

local clone, destroy, getchildren, getdescendants, isa = c.Clone, c.Destroy, c.GetChildren, c.GetDescendants, c.IsA

local function gp(parent, name, className)
    if typeof(parent) == "Instance" then
        for i, v in pairs(getchildren(parent)) do
            if (v.Name == name) and isa(v, className) then
                return v
            end
        end
    end
    return nil
end

local fenv = getfenv()

local shp = fenv.sethiddenproperty or fenv.set_hidden_property or fenv.set_hidden_prop or fenv.sethiddenprop
local ssr = fenv.setsimulationradius or fenv.set_simulation_radius or fenv.set_sim_radius or fenv.setsimradius or fenv.setsimrad or fenv.set_sim_rad

healthHide = healthHide and ((method == 0) or (method == 2) or (method == 3)) and gp(c, "Head", "BasePart")

local reclaim, lostpart = reclaim and c.PrimaryPart, nil

local function align(Part0, Part1)
    
    local att0 = Instance.new("Attachment")
    att0.Position, att0.Orientation, att0.Name = v3_0, v3_0, "att0_" .. Part0.Name
    local att1 = Instance.new("Attachment")
    att1.Position, att1.Orientation, att1.Name = v3_0, v3_0, "att1_" .. Part1.Name

    if alignmode == 4 then
    
        local hide = false
        if Part0 == healthHide then
            healthHide = false
            tdelay(0, function()
                while twait(2.9) and Part0 and c do
                    hide = #Part0:GetConnectedParts() == 1
                    twait(0.1)
                    hide = false
                end
            end)
        end
        
        local rot = rad(0.05)
        local con0, con1 = nil, nil
        con0 = stepped:Connect(function()
            if not (Part0 and Part1) then return con0:Disconnect() and con1:Disconnect() end
            Part0.RotVelocity = Part1.RotVelocity
        end)
        local lastpos = Part0.Position
        con1 = heartbeat:Connect(function(delta)
            if not (Part0 and Part1 and att1) then return con0:Disconnect() and con1:Disconnect() end
            if (not Part0.Anchored) and (Part0.ReceiveAge == 0) then
                if lostpart == Part0 then
                    lostpart = nil
                end
                local newcf = Part1.CFrame * att1.CFrame
                if Part1.Velocity.Magnitude > 0.1 then
                    Part0.Velocity = getNetlessVelocity(Part1.Velocity)
                else
                    local vel = (newcf.Position - lastpos) / delta
                    Part0.Velocity = getNetlessVelocity(vel)
                    if vel.Magnitude < 1 then
                        rot = -rot
                        newcf *= angles(0, 0, rot)
                    end
                end
                lastpos = newcf.Position
                if lostpart and (Part0 == reclaim) then
                    newcf = lostpart.CFrame
                elseif hide then
                    newcf += v3(0, 3000, 0)
                end
                if novoid and (newcf.Y < ws.FallenPartsDestroyHeight + 0.1) then
                    newcf += v3(0, ws.FallenPartsDestroyHeight + 0.1 - newcf.Y, 0)
                end
                Part0.CFrame = newcf
            elseif (not Part0.Anchored) and (abs(Part0.Velocity.X) < 45) and (abs(Part0.Velocity.Y) < 25) and (abs(Part0.Velocity.Z) < 45) then
                lostpart = Part0
            end
        end)
    
    else
        
        Part0.CustomPhysicalProperties = physp
        if (alignmode == 1) or (alignmode == 2) then
            local ape = Instance.new("AlignPosition")
            ape.MaxForce, ape.MaxVelocity, ape.Responsiveness = inf, inf, inf
            ape.ReactionForceEnabled, ape.RigidityEnabled, ape.ApplyAtCenterOfMass = false, true, false
            ape.Attachment0, ape.Attachment1, ape.Name = att0, att1, "AlignPositionRtrue"
            ape.Parent = att0
        end
        
        if (alignmode == 2) or (alignmode == 3) then
            local apd = Instance.new("AlignPosition")
            apd.MaxForce, apd.MaxVelocity, apd.Responsiveness = inf, inf, inf
            apd.ReactionForceEnabled, apd.RigidityEnabled, apd.ApplyAtCenterOfMass = false, false, false
            apd.Attachment0, apd.Attachment1, apd.Name = att0, att1, "AlignPositionRfalse"
            apd.Parent = att0
        end
        
        local ao = Instance.new("AlignOrientation")
        ao.MaxAngularVelocity, ao.MaxTorque, ao.Responsiveness = inf, inf, inf
        ao.PrimaryAxisOnly, ao.ReactionTorqueEnabled, ao.RigidityEnabled = false, false, false
        ao.Attachment0, ao.Attachment1 = att0, att1
        ao.Parent = att0
        
        local con0, con1 = nil, nil
        local vel = Part0.Velocity
        con0 = renderstepped:Connect(function()
            if not (Part0 and Part1) then return con0:Disconnect() and con1:Disconnect() end
            Part0.Velocity = vel
        end)
        local lastpos = Part0.Position
        con1 = heartbeat:Connect(function(delta)
            if not (Part0 and Part1) then return con0:Disconnect() and con1:Disconnect() end
            vel = Part0.Velocity
            if Part1.Velocity.Magnitude > 0.01 then
                Part0.Velocity = getNetlessVelocity(Part1.Velocity)
            else
                Part0.Velocity = getNetlessVelocity((Part0.Position - lastpos) / delta)
            end
            lastpos = Part0.Position
        end)
    
    end

    att0:GetPropertyChangedSignal("Parent"):Connect(function()
        Part0 = att0.Parent
        if not isa(Part0, "BasePart") then
            att0 = nil
            if lostpart == Part0 then
                lostpart = nil
            end
            Part0 = nil
        end
    end)
    att0.Parent = Part0
    
    att1:GetPropertyChangedSignal("Parent"):Connect(function()
        Part1 = att1.Parent
        if not isa(Part1, "BasePart") then
            att1 = nil
            Part1 = nil
        end
    end)
    att1.Parent = Part1
end

local function respawnrequest()
    local ccfr, c = ws.CurrentCamera.CFrame, lp.Character
    lp.Character = nil
    lp.Character = c
    local con = nil
    con = ws.CurrentCamera.Changed:Connect(function(prop)
        if (prop ~= "Parent") and (prop ~= "CFrame") then
            return
        end
        ws.CurrentCamera.CFrame = ccfr
        con:Disconnect()
    end)
end

local destroyhum = (method == 4) or (method == 5)
local breakjoints = (method == 0) or (method == 4)
local antirespawn = (method == 0) or (method == 2) or (method == 3)

hatcollide = hatcollide and (method == 0)

addtools = addtools and lp:FindFirstChildOfClass("Backpack")

if type(simrad) ~= "number" then simrad = 1000 end
if shp and (simradius == "shp") then
    tdelay(0, function()
        while c do
            shp(lp, "SimulationRadius", simrad)
            heartbeat:Wait()
        end
    end)
elseif ssr and (simradius == "ssr") then
    tdelay(0, function()
        while c do
            ssr(simrad)
            heartbeat:Wait()
        end
    end)
end

if antiragdoll then
    antiragdoll = function(v)
        if isa(v, "HingeConstraint") or isa(v, "BallSocketConstraint") then
            v.Parent = nil
        end
    end
    for i, v in pairs(getdescendants(c)) do
        antiragdoll(v)
    end
    c.DescendantAdded:Connect(antiragdoll)
end

if antirespawn then
    respawnrequest()
end

if method == 0 then
    twait(loadtime)
    if not c then
        return
    end
end

if discharscripts then
    for i, v in pairs(getdescendants(c)) do
        if isa(v, "LocalScript") then
            v.Disabled = true
        end
    end
elseif newanimate then
    local animate = gp(c, "Animate", "LocalScript")
    if animate and (not animate.Disabled) then
        animate.Disabled = true
    else
        newanimate = false
    end
end

if addtools then
    for i, v in pairs(getchildren(addtools)) do
        if isa(v, "Tool") then
            v.Parent = c
        end
    end
end

pcall(function()
    settings().Physics.AllowSleep = false
    settings().Physics.PhysicsEnvironmentalThrottle = Enum.EnviromentalPhysicsThrottle.Disabled
end)

local OLDscripts = {}

for i, v in pairs(getdescendants(c)) do
    if v.ClassName == "Script" then
        OLDscripts[v.Name] = true
    end
end

local scriptNames = {}

for i, v in pairs(getdescendants(c)) do
    if isa(v, "BasePart") then
        local newName, exists = tostring(i), true
        while exists do
            exists = OLDscripts[newName]
            if exists then
                newName = newName .. "_"    
            end
        end
        table.insert(scriptNames, newName)
        Instance.new("Script", v).Name = newName
    end
end

local hum = c:FindFirstChildOfClass("Humanoid")
if hum then
    for i, v in pairs(hum:GetPlayingAnimationTracks()) do
        v:Stop()
    end
end
c.Archivable = true
local cl = clone(c)
if hum and humState16 then
    hum:ChangeState(Enum.HumanoidStateType.Physics)
    if destroyhum then
        twait(1.6)
    end
end
if destroyhum then
    pcall(destroy, hum)
end

if not c then
    return
end

local head, torso, root = gp(c, "Head", "BasePart"), gp(c, "Torso", "BasePart") or gp(c, "UpperTorso", "BasePart"), gp(c, "HumanoidRootPart", "BasePart")
if hatcollide then
    pcall(destroy, torso)
    pcall(destroy, root)
    pcall(destroy, c:FindFirstChildOfClass("BodyColors") or gp(c, "Health", "Script"))
end

local model = Instance.new("Model", c)
model:GetPropertyChangedSignal("Parent"):Connect(function()
    if not (model and model.Parent) then
        model = nil
    end
end)

for i, v in pairs(getchildren(c)) do
    if v ~= model then
        if addtools and isa(v, "Tool") then
            for i1, v1 in pairs(getdescendants(v)) do
                if v1 and v1.Parent and isa(v1, "BasePart") then
                    local bv = Instance.new("BodyVelocity")
                    bv.Velocity, bv.MaxForce, bv.P, bv.Name = v3_0, v3(1000, 1000, 1000), 1250, "bv_" .. v.Name
                    bv.Parent = v1
                end
            end
        end
        v.Parent = model
    end
end

if breakjoints then
    model:BreakJoints()
else
    if head and torso then
        for i, v in pairs(getdescendants(model)) do
            if isa(v, "JointInstance") then
                local save = false
                if (v.Part0 == torso) and (v.Part1 == head) then
                    save = true
                end
                if (v.Part0 == head) and (v.Part1 == torso) then
                    save = true
                end
                if save then
                    if hedafterneck then
                        hedafterneck = v
                    end
                else
                    pcall(destroy, v)
                end
            end
        end
    end
    if method == 3 then
        task.delay(loadtime, pcall, model.BreakJoints, model)
    end
end

cl.Parent = ws
for i, v in pairs(getchildren(cl)) do
    v.Parent = c
end
pcall(destroy, cl)

local uncollide, noclipcon = nil, nil
if noclipAllParts then
    uncollide = function()
        if c then
            for i, v in pairs(getdescendants(c)) do
                if isa(v, "BasePart") then
                    v.CanCollide = false
                end
            end
        else
            noclipcon:Disconnect()
        end
    end
else
    uncollide = function()
        if model then
            for i, v in pairs(getdescendants(model)) do
                if isa(v, "BasePart") then
                    v.CanCollide = false
                end
            end
        else
            noclipcon:Disconnect()
        end
    end
end
noclipcon = stepped:Connect(uncollide)
uncollide()

for i, scr in pairs(getdescendants(model)) do
    if (scr.ClassName == "Script") and table.find(scriptNames, scr.Name) then
        local Part0 = scr.Parent
        if isa(Part0, "BasePart") then
            for i1, scr1 in pairs(getdescendants(c)) do
                if (scr1.ClassName == "Script") and (scr1.Name == scr.Name) and (not scr1:IsDescendantOf(model)) then
                    local Part1 = scr1.Parent
                    if (Part1.ClassName == Part0.ClassName) and (Part1.Name == Part0.Name) then
                        align(Part0, Part1)
                        pcall(destroy, scr)
                        pcall(destroy, scr1)
                        break
                    end
                end
            end
        end
    end
end

for i, v in pairs(getdescendants(c)) do
    if v and v.Parent and (not v:IsDescendantOf(model)) then
        if isa(v, "Decal") then
            v.Transparency = 1
        elseif isa(v, "BasePart") then
            v.Transparency = 1
            v.Anchored = false
        elseif isa(v, "ForceField") then
            v.Visible = false
        elseif isa(v, "Sound") then
            v.Playing = false
        elseif isa(v, "BillboardGui") or isa(v, "SurfaceGui") or isa(v, "ParticleEmitter") or isa(v, "Fire") or isa(v, "Smoke") or isa(v, "Sparkles") then
            v.Enabled = false
        end
    end
end

if newanimate then
    local animate = gp(c, "Animate", "LocalScript")
    if animate then
        animate.Disabled = false
    end
end

if addtools then
    for i, v in pairs(getchildren(c)) do
        if isa(v, "Tool") then
            v.Parent = addtools
        end
    end
end

local hum0, hum1 = model:FindFirstChildOfClass("Humanoid"), c:FindFirstChildOfClass("Humanoid")
if hum0 then
    hum0:GetPropertyChangedSignal("Parent"):Connect(function()
        if not (hum0 and hum0.Parent) then
            hum0 = nil
        end
    end)
end
if hum1 then
    hum1:GetPropertyChangedSignal("Parent"):Connect(function()
        if not (hum1 and hum1.Parent) then
            hum1 = nil
        end
    end)

    ws.CurrentCamera.CameraSubject = hum1
    local camSubCon = nil
    local function camSubFunc()
        camSubCon:Disconnect()
        if c and hum1 then
            ws.CurrentCamera.CameraSubject = hum1
        end
    end
    camSubCon = renderstepped:Connect(camSubFunc)
    if hum0 then
        hum0:GetPropertyChangedSignal("Jump"):Connect(function()
            if hum1 then
                hum1.Jump = hum0.Jump
            end
        end)
    else
        respawnrequest()
    end
end

local rb = Instance.new("BindableEvent", c)
rb.Event:Connect(function()
    pcall(destroy, rb)
    sg:SetCore("ResetButtonCallback", true)
    if destroyhum then
        if c then c:BreakJoints() end
        return
    end
    if model and hum0 and (hum0.Health > 0) then
        model:BreakJoints()
        hum0.Health = 0
    end
    if antirespawn then
        respawnrequest()
    end
end)
sg:SetCore("ResetButtonCallback", rb)

tdelay(0, function()
    while c do
        if hum0 and hum1 then
            hum1.Jump = hum0.Jump
        end
        wait()
    end
    sg:SetCore("ResetButtonCallback", true)
end)

R15toR6 = R15toR6 and hum1 and (hum1.RigType == Enum.HumanoidRigType.R15)
if R15toR6 then
    local part = gp(c, "HumanoidRootPart", "BasePart") or gp(c, "UpperTorso", "BasePart") or gp(c, "LowerTorso", "BasePart") or gp(c, "Head", "BasePart") or c:FindFirstChildWhichIsA("BasePart")
    if part then
        local cfr = part.CFrame
        local R6parts = { 
            head = {
                Name = "Head",
                Size = v3(2, 1, 1),
                R15 = {
                    Head = 0
                }
            },
            torso = {
                Name = "Torso",
                Size = v3(2, 2, 1),
                R15 = {
                    UpperTorso = 0.2,
                    LowerTorso = -0.8
                }
            },
            root = {
                Name = "HumanoidRootPart",
                Size = v3(2, 2, 1),
                R15 = {
                    HumanoidRootPart = 0
                }
            },
            leftArm = {
                Name = "Left Arm",
                Size = v3(1, 2, 1),
                R15 = {
                    LeftHand = -0.849,
                    LeftLowerArm = -0.174,
                    LeftUpperArm = 0.415
                }
            },
            rightArm = {
                Name = "Right Arm",
                Size = v3(1, 2, 1),
                R15 = {
                    RightHand = -0.849,
                    RightLowerArm = -0.174,
                    RightUpperArm = 0.415
                }
            },
            leftLeg = {
                Name = "Left Leg",
                Size = v3(1, 2, 1),
                R15 = {
                    LeftFoot = -0.85,
                    LeftLowerLeg = -0.29,
                    LeftUpperLeg = 0.49
                }
            },
            rightLeg = {
                Name = "Right Leg",
                Size = v3(1, 2, 1),
                R15 = {
                    RightFoot = -0.85,
                    RightLowerLeg = -0.29,
                    RightUpperLeg = 0.49
                }
            }
        }
        for i, v in pairs(getchildren(c)) do
            if isa(v, "BasePart") then
                for i1, v1 in pairs(getchildren(v)) do
                    if isa(v1, "Motor6D") then
                        v1.Part0 = nil
                    end
                end
            end
        end
        part.Archivable = true
        for i, v in pairs(R6parts) do
            local part = clone(part)
            part:ClearAllChildren()
            part.Name, part.Size, part.CFrame, part.Anchored, part.Transparency, part.CanCollide = v.Name, v.Size, cfr, false, 1, false
            for i1, v1 in pairs(v.R15) do
                local R15part = gp(c, i1, "BasePart")
                local att = gp(R15part, "att1_" .. i1, "Attachment")
                if R15part then
                    local weld = Instance.new("Weld")
                    weld.Part0, weld.Part1, weld.C0, weld.C1, weld.Name = part, R15part, cf(0, v1, 0), cf_0, "Weld_" .. i1
                    weld.Parent = R15part
                    R15part.Massless, R15part.Name = true, "R15_" .. i1
                    R15part.Parent = part
                    if att then
                        att.Position = v3(0, v1, 0)
                        att.Parent = part
                    end
                end
            end
            part.Parent = c
            R6parts[i] = part
        end
        local R6joints = {
            neck = {
                Parent = R6parts.torso,
                Name = "Neck",
                Part0 = R6parts.torso,
                Part1 = R6parts.head,
                C0 = cf(0, 1, 0, -1, 0, 0, 0, 0, 1, 0, 1, -0),
                C1 = cf(0, -0.5, 0, -1, 0, 0, 0, 0, 1, 0, 1, -0)
            },
            rootJoint = {
                Parent = R6parts.root,
                Name = "RootJoint" ,
                Part0 = R6parts.root,
                Part1 = R6parts.torso,
                C0 = cf(0, 0, 0, -1, 0, 0, 0, 0, 1, 0, 1, -0),
                C1 = cf(0, 0, 0, -1, 0, 0, 0, 0, 1, 0, 1, -0)
            },
            rightShoulder = {
                Parent = R6parts.torso,
                Name = "Right Shoulder",
                Part0 = R6parts.torso,
                Part1 = R6parts.rightArm,
                C0 = cf(1, 0.5, 0, 0, 0, 1, 0, 1, -0, -1, 0, 0),
                C1 = cf(-0.5, 0.5, 0, 0, 0, 1, 0, 1, -0, -1, 0, 0)
            },
            leftShoulder = {
                Parent = R6parts.torso,
                Name = "Left Shoulder",
                Part0 = R6parts.torso,
                Part1 = R6parts.leftArm,
                C0 = cf(-1, 0.5, 0, 0, 0, -1, 0, 1, 0, 1, 0, 0),
                C1 = cf(0.5, 0.5, 0, 0, 0, -1, 0, 1, 0, 1, 0, 0)
            },
            rightHip = {
                Parent = R6parts.torso,
                Name = "Right Hip",
                Part0 = R6parts.torso,
                Part1 = R6parts.rightLeg,
                C0 = cf(1, -1, 0, 0, 0, 1, 0, 1, -0, -1, 0, 0),
                C1 = cf(0.5, 1, 0, 0, 0, 1, 0, 1, -0, -1, 0, 0)
            },
            leftHip = {
                Parent = R6parts.torso,
                Name = "Left Hip" ,
                Part0 = R6parts.torso,
                Part1 = R6parts.leftLeg,
                C0 = cf(-1, -1, 0, 0, 0, -1, 0, 1, 0, 1, 0, 0),
                C1 = cf(-0.5, 1, 0, 0, 0, -1, 0, 1, 0, 1, 0, 0)
            }
        }
        for i, v in pairs(R6joints) do
            local joint = Instance.new("Motor6D")
            for prop, val in pairs(v) do
                joint[prop] = val
            end
            R6joints[i] = joint
        end
        if hum1 then
            hum1.RigType, hum1.HipHeight = Enum.HumanoidRigType.R6, 0
        end
    end
    --the default roblox animate script edited and put in one line
    local script = gp(c, "Animate", "LocalScript") if not script.Disabled then script:ClearAllChildren() local Torso = gp(c, "Torso", "BasePart") local RightShoulder = gp(Torso, "Right Shoulder", "Motor6D") local LeftShoulder = gp(Torso, "Left Shoulder", "Motor6D") local RightHip = gp(Torso, "Right Hip", "Motor6D") local LeftHip = gp(Torso, "Left Hip", "Motor6D") local Neck = gp(Torso, "Neck", "Motor6D") local Humanoid = c:FindFirstChildOfClass("Humanoid") local pose = "Standing" local currentAnim = "" local currentAnimInstance = nil local currentAnimTrack = nil local currentAnimKeyframeHandler = nil local currentAnimSpeed = 1.0 local animTable = {} local animNames = { idle = { { id = "http://www.roblox.com/asset/?id=180435571", weight = 9 }, { id = "http://www.roblox.com/asset/?id=180435792", weight = 1 } }, walk = { { id = "http://www.roblox.com/asset/?id=180426354", weight = 10 } }, run = { { id = "run.xml", weight = 10 } }, jump = { { id = "http://www.roblox.com/asset/?id=125750702", weight = 10 } }, fall = { { id = "http://www.roblox.com/asset/?id=180436148", weight = 10 } }, climb = { { id = "http://www.roblox.com/asset/?id=180436334", weight = 10 } }, sit = { { id = "http://www.roblox.com/asset/?id=178130996", weight = 10 } }, toolnone = { { id = "http://www.roblox.com/asset/?id=182393478", weight = 10 } }, toolslash = { { id = "http://www.roblox.com/asset/?id=129967390", weight = 10 } }, toollunge = { { id = "http://www.roblox.com/asset/?id=129967478", weight = 10 } }, wave = { { id = "http://www.roblox.com/asset/?id=128777973", weight = 10 } }, point = { { id = "http://www.roblox.com/asset/?id=128853357", weight = 10 } }, dance1 = { { id = "http://www.roblox.com/asset/?id=182435998", weight = 10 }, { id = "http://www.roblox.com/asset/?id=182491037", weight = 10 }, { id = "http://www.roblox.com/asset/?id=182491065", weight = 10 } }, dance2 = { { id = "http://www.roblox.com/asset/?id=182436842", weight = 10 }, { id = "http://www.roblox.com/asset/?id=182491248", weight = 10 }, { id = "http://www.roblox.com/asset/?id=182491277", weight = 10 } }, dance3 = { { id = "http://www.roblox.com/asset/?id=182436935", weight = 10 }, { id = "http://www.roblox.com/asset/?id=182491368", weight = 10 }, { id = "http://www.roblox.com/asset/?id=182491423", weight = 10 } }, laugh = { { id = "http://www.roblox.com/asset/?id=129423131", weight = 10 } }, cheer = { { id = "http://www.roblox.com/asset/?id=129423030", weight = 10 } }, } local dances = {"dance1", "dance2", "dance3"} local emoteNames = { wave = false, point = false, dance1 = true, dance2 = true, dance3 = true, laugh = false, cheer = false} local function configureAnimationSet(name, fileList) if (animTable[name] ~= nil) then for _, connection in pairs(animTable[name].connections) do connection:disconnect() end end animTable[name] = {} animTable[name].count = 0 animTable[name].totalWeight = 0 animTable[name].connections = {} local config = script:FindFirstChild(name) if (config ~= nil) then table.insert(animTable[name].connections, config.ChildAdded:connect(function(child) configureAnimationSet(name, fileList) end)) table.insert(animTable[name].connections, config.ChildRemoved:connect(function(child) configureAnimationSet(name, fileList) end)) local idx = 1 for _, childPart in pairs(config:GetChildren()) do if (childPart:IsA("Animation")) then table.insert(animTable[name].connections, childPart.Changed:connect(function(property) configureAnimationSet(name, fileList) end)) animTable[name][idx] = {} animTable[name][idx].anim = childPart local weightObject = childPart:FindFirstChild("Weight") if (weightObject == nil) then animTable[name][idx].weight = 1 else animTable[name][idx].weight = weightObject.Value end animTable[name].count = animTable[name].count + 1 animTable[name].totalWeight = animTable[name].totalWeight + animTable[name][idx].weight idx = idx + 1 end end end if (animTable[name].count <= 0) then for idx, anim in pairs(fileList) do animTable[name][idx] = {} animTable[name][idx].anim = Instance.new("Animation") animTable[name][idx].anim.Name = name animTable[name][idx].anim.AnimationId = anim.id animTable[name][idx].weight = anim.weight animTable[name].count = animTable[name].count + 1 animTable[name].totalWeight = animTable[name].totalWeight + anim.weight end end end local function scriptChildModified(child) local fileList = animNames[child.Name] if (fileList ~= nil) then configureAnimationSet(child.Name, fileList) end end script.ChildAdded:connect(scriptChildModified) script.ChildRemoved:connect(scriptChildModified) local animator = Humanoid and Humanoid:FindFirstChildOfClass("Animator") or nil if animator then local animTracks = animator:GetPlayingAnimationTracks() for i, track in ipairs(animTracks) do track:Stop(0) track:Destroy() end end for name, fileList in pairs(animNames) do configureAnimationSet(name, fileList) end local toolAnim = "None" local toolAnimTime = 0 local jumpAnimTime = 0 local jumpAnimDuration = 0.3 local toolTransitionTime = 0.1 local fallTransitionTime = 0.3 local jumpMaxLimbVelocity = 0.75 local function stopAllAnimations() local oldAnim = currentAnim if (emoteNames[oldAnim] ~= nil and emoteNames[oldAnim] == false) then oldAnim = "idle" end currentAnim = "" currentAnimInstance = nil if (currentAnimKeyframeHandler ~= nil) then currentAnimKeyframeHandler:disconnect() end if (currentAnimTrack ~= nil) then currentAnimTrack:Stop() currentAnimTrack:Destroy() currentAnimTrack = nil end return oldAnim end local function playAnimation(animName, transitionTime, humanoid) local roll = math.random(1, animTable[animName].totalWeight) local origRoll = roll local idx = 1 while (roll > animTable[animName][idx].weight) do roll = roll - animTable[animName][idx].weight idx = idx + 1 end local anim = animTable[animName][idx].anim if (anim ~= currentAnimInstance) then if (currentAnimTrack ~= nil) then currentAnimTrack:Stop(transitionTime) currentAnimTrack:Destroy() end currentAnimSpeed = 1.0 currentAnimTrack = humanoid:LoadAnimation(anim) currentAnimTrack.Priority = Enum.AnimationPriority.Core currentAnimTrack:Play(transitionTime) currentAnim = animName currentAnimInstance = anim if (currentAnimKeyframeHandler ~= nil) then currentAnimKeyframeHandler:disconnect() end currentAnimKeyframeHandler = currentAnimTrack.KeyframeReached:connect(keyFrameReachedFunc) end end local function setAnimationSpeed(speed) if speed ~= currentAnimSpeed then currentAnimSpeed = speed currentAnimTrack:AdjustSpeed(currentAnimSpeed) end end local function keyFrameReachedFunc(frameName) if (frameName == "End") then local repeatAnim = currentAnim if (emoteNames[repeatAnim] ~= nil and emoteNames[repeatAnim] == false) then repeatAnim = "idle" end local animSpeed = currentAnimSpeed playAnimation(repeatAnim, 0.0, Humanoid) setAnimationSpeed(animSpeed) end end local toolAnimName = "" local toolAnimTrack = nil local toolAnimInstance = nil local currentToolAnimKeyframeHandler = nil local function toolKeyFrameReachedFunc(frameName) if (frameName == "End") then playToolAnimation(toolAnimName, 0.0, Humanoid) end end local function playToolAnimation(animName, transitionTime, humanoid, priority) local roll = math.random(1, animTable[animName].totalWeight) local origRoll = roll local idx = 1 while (roll > animTable[animName][idx].weight) do roll = roll - animTable[animName][idx].weight idx = idx + 1 end local anim = animTable[animName][idx].anim if (toolAnimInstance ~= anim) then if (toolAnimTrack ~= nil) then toolAnimTrack:Stop() toolAnimTrack:Destroy() transitionTime = 0 end toolAnimTrack = humanoid:LoadAnimation(anim) if priority then toolAnimTrack.Priority = priority end toolAnimTrack:Play(transitionTime) toolAnimName = animName toolAnimInstance = anim currentToolAnimKeyframeHandler = toolAnimTrack.KeyframeReached:connect(toolKeyFrameReachedFunc) end end local function stopToolAnimations() local oldAnim = toolAnimName if (currentToolAnimKeyframeHandler ~= nil) then currentToolAnimKeyframeHandler:disconnect() end toolAnimName = "" toolAnimInstance = nil if (toolAnimTrack ~= nil) then toolAnimTrack:Stop() toolAnimTrack:Destroy() toolAnimTrack = nil end return oldAnim end local function onRunning(speed) if speed > 0.01 then playAnimation("walk", 0.1, Humanoid) if currentAnimInstance and currentAnimInstance.AnimationId == "http://www.roblox.com/asset/?id=180426354" then setAnimationSpeed(speed / 14.5) end pose = "Running" else if emoteNames[currentAnim] == nil then playAnimation("idle", 0.1, Humanoid) pose = "Standing" end end end local function onDied() pose = "Dead" end local function onJumping() playAnimation("jump", 0.1, Humanoid) jumpAnimTime = jumpAnimDuration pose = "Jumping" end local function onClimbing(speed) playAnimation("climb", 0.1, Humanoid) setAnimationSpeed(speed / 12.0) pose = "Climbing" end local function onGettingUp() pose = "GettingUp" end local function onFreeFall() if (jumpAnimTime <= 0) then playAnimation("fall", fallTransitionTime, Humanoid) end pose = "FreeFall" end local function onFallingDown() pose = "FallingDown" end local function onSeated() pose = "Seated" end local function onPlatformStanding() pose = "PlatformStanding" end local function onSwimming(speed) if speed > 0 then pose = "Running" else pose = "Standing" end end local function getTool() return c and c:FindFirstChildOfClass("Tool") end local function getToolAnim(tool) for _, c in ipairs(tool:GetChildren()) do if c.Name == "toolanim" and c.className == "StringValue" then return c end end return nil end local function animateTool() if (toolAnim == "None") then playToolAnimation("toolnone", toolTransitionTime, Humanoid, Enum.AnimationPriority.Idle) return end if (toolAnim == "Slash") then playToolAnimation("toolslash", 0, Humanoid, Enum.AnimationPriority.Action) return end if (toolAnim == "Lunge") then playToolAnimation("toollunge", 0, Humanoid, Enum.AnimationPriority.Action) return end end local function moveSit() RightShoulder.MaxVelocity = 0.15 LeftShoulder.MaxVelocity = 0.15 RightShoulder:SetDesiredAngle(3.14 /2) LeftShoulder:SetDesiredAngle(-3.14 /2) RightHip:SetDesiredAngle(3.14 /2) LeftHip:SetDesiredAngle(-3.14 /2) end local lastTick = 0 local function move(time) local amplitude = 1 local frequency = 1 local deltaTime = time - lastTick lastTick = time local climbFudge = 0 local setAngles = false if (jumpAnimTime > 0) then jumpAnimTime = jumpAnimTime - deltaTime end if (pose == "FreeFall" and jumpAnimTime <= 0) then playAnimation("fall", fallTransitionTime, Humanoid) elseif (pose == "Seated") then playAnimation("sit", 0.5, Humanoid) return elseif (pose == "Running") then playAnimation("walk", 0.1, Humanoid) elseif (pose == "Dead" or pose == "GettingUp" or pose == "FallingDown" or pose == "Seated" or pose == "PlatformStanding") then stopAllAnimations() amplitude = 0.1 frequency = 1 setAngles = true end if (setAngles) then local desiredAngle = amplitude * math.sin(time * frequency) RightShoulder:SetDesiredAngle(desiredAngle + climbFudge) LeftShoulder:SetDesiredAngle(desiredAngle - climbFudge) RightHip:SetDesiredAngle(-desiredAngle) LeftHip:SetDesiredAngle(-desiredAngle) end local tool = getTool() if tool and tool:FindFirstChild("Handle") then local animStringValueObject = getToolAnim(tool) if animStringValueObject then toolAnim = animStringValueObject.Value animStringValueObject.Parent = nil toolAnimTime = time + .3 end if time > toolAnimTime then toolAnimTime = 0 toolAnim = "None" end animateTool() else stopToolAnimations() toolAnim = "None" toolAnimInstance = nil toolAnimTime = 0 end end Humanoid.Died:connect(onDied) Humanoid.Running:connect(onRunning) Humanoid.Jumping:connect(onJumping) Humanoid.Climbing:connect(onClimbing) Humanoid.GettingUp:connect(onGettingUp) Humanoid.FreeFalling:connect(onFreeFall) Humanoid.FallingDown:connect(onFallingDown) Humanoid.Seated:connect(onSeated) Humanoid.PlatformStanding:connect(onPlatformStanding) Humanoid.Swimming:connect(onSwimming) game:GetService("Players").LocalPlayer.Chatted:connect(function(msg) local emote = "" if msg == "/e dance" then emote = dances[math.random(1, #dances)] elseif (string.sub(msg, 1, 3) == "/e ") then emote = string.sub(msg, 4) elseif (string.sub(msg, 1, 7) == "/emote ") then emote = string.sub(msg, 8) end if (pose == "Standing" and emoteNames[emote] ~= nil) then playAnimation(emote, 0.1, Humanoid) end end) playAnimation("idle", 0.1, Humanoid) pose = "Standing" tdelay(0, function() while c do local _, time = wait(0.1) if (script.Parent == c) and (not script.Disabled) then move(time) end end end) end 
end

local torso1 = torso
torso = gp(c, "Torso", "BasePart") or ((not R15toR6) and gp(c, torso.Name, "BasePart"))
if (typeof(hedafterneck) == "Instance") and head and torso and torso1 then
    local conNeck, conTorso, conTorso1 = nil, nil, nil
    local aligns = {}
    local function enableAligns()
        conNeck:Disconnect()
        conTorso:Disconnect()
        conTorso1:Disconnect()
        for i, v in pairs(aligns) do
            v.Enabled = true
        end
    end
    conNeck = hedafterneck.Changed:Connect(function(prop)
        if table.find({"Part0", "Part1", "Parent"}, prop) then
            enableAligns()
        end
    end)
    conTorso = torso:GetPropertyChangedSignal("Parent"):Connect(enableAligns)
    conTorso1 = torso1:GetPropertyChangedSignal("Parent"):Connect(enableAligns)
    for i, v in pairs(getdescendants(head)) do
        if isa(v, "AlignPosition") or isa(v, "AlignOrientation") then
            i = tostring(i)
            aligns[i] = v
            v:GetPropertyChangedSignal("Parent"):Connect(function()
                aligns[i] = nil
            end)
            v.Enabled = false
        end
    end
end

local flingpart0 = gp(model, flingpart, "BasePart") or gp(gp(model, flingpart, "Accessory"), "Handle", "BasePart")
local flingpart1 = gp(c, flingpart, "BasePart") or gp(gp(c, flingpart, "Accessory"), "Handle", "BasePart")

local fling = function() end
if flingpart0 and flingpart1 then
    flingpart0:GetPropertyChangedSignal("Parent"):Connect(function()
        if not (flingpart0 and flingpart0.Parent) then
            flingpart0 = nil
            fling = function() end
        end
    end)
    flingpart0.Archivable = true
    flingpart1:GetPropertyChangedSignal("Parent"):Connect(function()
        if not (flingpart1 and flingpart1.Parent) then
            flingpart1 = nil
            fling = function() end
        end
    end)
    local att0 = gp(flingpart0, "att0_" .. flingpart0.Name, "Attachment")
    local att1 = gp(flingpart1, "att1_" .. flingpart1.Name, "Attachment")
    if att0 and att1 then
        att0:GetPropertyChangedSignal("Parent"):Connect(function()
            if not (att0 and att0.Parent) then
                att0 = nil
                fling = function() end
            end
        end)
        att1:GetPropertyChangedSignal("Parent"):Connect(function()
            if not (att1 and att1.Parent) then
                att1 = nil
                fling = function() end
            end
        end)
        local lastfling = nil
        local mouse = lp:GetMouse()
        fling = function(target, duration, rotVelocity)
            if typeof(target) == "Instance" then
                if isa(target, "BasePart") then
                    target = target.Position
                elseif isa(target, "Model") then
                    target = gp(target, "HumanoidRootPart", "BasePart") or gp(target, "Torso", "BasePart") or gp(target, "UpperTorso", "BasePart") or target:FindFirstChildWhichIsA("BasePart")
                    if target then
                        target = target.Position
                    else
                        return
                    end
                elseif isa(target, "Humanoid") then
                    target = target.Parent
                    if not (target and isa(target, "Model")) then
                        return
                    end
                    target = gp(target, "HumanoidRootPart", "BasePart") or gp(target, "Torso", "BasePart") or gp(target, "UpperTorso", "BasePart") or target:FindFirstChildWhichIsA("BasePart")
                    if target then
                        target = target.Position
                    else
                        return
                    end
                else
                    return
                end
            elseif typeof(target) == "CFrame" then
                target = target.Position
            elseif typeof(target) ~= "Vector3" then
                target = mouse.Hit
                if target then
                    target = target.Position
                else
                    return
                end
            end
            if target.Y < ws.FallenPartsDestroyHeight + 5 then
                target = v3(target.X, ws.FallenPartsDestroyHeight + 5, target.Z)
            end
            lastfling = target
            if type(duration) ~= "number" then
                duration = tonumber(duration) or 0.5
            end
            if typeof(rotVelocity) ~= "Vector3" then
                rotVelocity = v3(20000, 20000, 20000)
            end
            if not (target and flingpart0 and flingpart1 and att0 and att1) then
                return
            end
            flingpart0.Archivable = true
            local flingpart = clone(flingpart0)
            flingpart.Transparency = 1
            flingpart.CanCollide = false
            flingpart.Name = "flingpart_" .. flingpart0.Name
            flingpart.Anchored = true
            flingpart.Velocity = v3_0
            flingpart.RotVelocity = v3_0
            flingpart.Position = target
            flingpart:GetPropertyChangedSignal("Parent"):Connect(function()
                if not (flingpart and flingpart.Parent) then
                    flingpart = nil
                end
            end)
            flingpart.Parent = flingpart1
            if flingpart0.Transparency > 0.5 then
                flingpart0.Transparency = 0.5
            end
            att1.Parent = flingpart
            local con = nil
            local rotchg = v3(0, rotVelocity.Unit.Y * -1000, 0)
            con = heartbeat:Connect(function(delta)
                if target and (lastfling == target) and flingpart and flingpart0 and flingpart1 and att0 and att1 then
                    flingpart.Orientation += rotchg * delta
                    flingpart0.RotVelocity = rotVelocity
                else
                    con:Disconnect()
                end
            end)
            if alignmode ~= 4 then
                local con = nil
                con = renderstepped:Connect(function()
                    if flingpart0 and target then
                        flingpart0.RotVelocity = v3_0
                    else
                        con:Disconnect()
                    end
                end)
            end
            twait(duration)
            if lastfling ~= target then
                if flingpart then
                    if att1 and (att1.Parent == flingpart) then
                        att1.Parent = flingpart1
                    end
                    pcall(destroy, flingpart)
                end
                return
            end
            target = nil
            if not (flingpart and flingpart0 and flingpart1 and att0 and att1) then
                return
            end
            flingpart0.RotVelocity = v3_0
            att1.Parent = flingpart1
            pcall(destroy, flingpart)
        end
    end
end

lp:GetMouse().Button1Down:Connect(fling) --click fling

local lp = game:GetService("Players").LocalPlayer
local rs = game:GetService("RunService")
local stepped = rs.Stepped
local heartbeat = rs.Heartbeat
local renderstepped = rs.RenderStepped
local sg = game:GetService("StarterGui")
local ws = game:GetService("Workspace")
local cf = CFrame.new
local v3 = Vector3.new
local v3_0 = Vector3.zero
local inf = math.huge

local cplayer = lp.Character

local v3 = Vector3.new

local function gp(parent, name, className)
    if typeof(parent) == "Instance" then
        for i, v in pairs(parent:GetChildren()) do
            if (v.Name == name) and v:IsA(className) then
                return v
            end
        end
    end
    return nil
end


local hat2 = gp(cplayer, "MeshPartAccessory", "Accessory")
local handle2 = gp(hat2, "Handle", "BasePart")
local att2 = gp(handle2, "att1_Handle", "Attachment")
att2.Parent = cplayer["Right Arm"]
att2.Position = Vector3.new(0, -1, -1.6)
att2.Rotation = Vector3.new(50, -100, 0)

print([[
___________________________________
  
Kyutatsuki13's Chara script
Build 0002
Don't even mind why I did this, it was a challenge !
  
___________________________________
]])


warn("You're whitelisted, "..game:GetService("Players").LocalPlayer.Name.." :)")

local p = game:GetService("Players").LocalPlayer 
local char = p.Character
local mouse = p:GetMouse()
local larm = char:WaitForChild("Left Arm")
local rarm = char:WaitForChild("Right Arm")
local lleg = char:WaitForChild("Left Leg")
local rleg = char:WaitForChild("Right Leg")
local hed = char:WaitForChild("Head")
local torso = char:WaitForChild("Torso")
local root = char:WaitForChild("HumanoidRootPart")
local hum = char:FindFirstChildOfClass("Humanoid")
local debris = game:GetService("Debris")
local input = game:GetService("UserInputService")
local run = game:GetService("RunService")
local rs = run.RenderStepped
local wingpose = "Idle"
local DebrisModel = Instance.new("Model",char)
DebrisModel.Name = "Debris"
repeat rs:wait() until p.CharacterAppearanceLoaded

noidle = false
shift = false
control = false
no_nosound_able = false
kills = 0

----------------------------------------------------------------------------

function rswait(value)
  if value ~= nil and value ~= 0 then
    for i=1,value do
     rs:wait()
    end
  else
    rs:wait()
  end
end

----------------------------------------------------------------------------

local timeposition = 0

function music(id)
if not torso:FindFirstChild("MusicRuin") then
soundz = Instance.new("Sound",torso)
end
soundz.Volume = 10
soundz.Name = "MusicRuin"
soundz.Looped = true
soundz.PlaybackSpeed = 1
soundz.SoundId = "rbxassetid://"..id
soundz:Stop()
soundz:Play()
if no_nosound_able == true then
soundz.TimePosition = timeposition
end
end

----------------------------------------------------------------------------

function lerp(a, b, t)
  return a + (b - a)*t
end

----------------------------------------------------------------------------

function Lerp(c1,c2,al)
  local com1 = {c1.X,c1.Y,c1.Z,c1:toEulerAnglesXYZ()}
  local com2 = {c2.X,c2.Y,c2.Z,c2:toEulerAnglesXYZ()}
  for i,v in pairs(com1) do
    com1[i] = v+(com2[i]-v)*al
  end
  return CFrame.new(com1[1],com1[2],com1[3]) * CFrame.Angles(select(4,unpack(com1)))
end

----------------------------------------------------------------------------

function slerp(a, b, t)
  dot = a:Dot(b)
  if dot > 0.99999 or dot < -0.99999 then
    return t <= 0.5 and a or b
  else
    r = math.acos(dot)
    return (a*math.sin((1 - t)*r) + b*math.sin(t*r)) / math.sin(r)
  end
end

----------------------------------------------------------------------------

function clerp(c1,c2,al)

  local com1 = {c1.X,c1.Y,c1.Z,c1:toEulerAnglesXYZ()}

  local com2 = {c2.X,c2.Y,c2.Z,c2:toEulerAnglesXYZ()}

  for i,v in pairs(com1) do

    com1[i] = lerp(v,com2[i],al)

  end

  return CFrame.new(com1[1],com1[2],com1[3]) * CFrame.Angles(select(4,unpack(com1)))

end

----------------------------------------------------------------------------

function findAllNearestTorso(pos,dist)
    local list = workspace:children()
    local torso = {}
    local temp = nil
    local human = nil
    local temp2 = nil
    for x = 1, #list do
        temp2 = list[x]
        if (temp2.className == "Model") and (temp2 ~= char) then
            temp = temp2:findFirstChild("Torso")
            human = temp2:findFirstChildOfClass("Humanoid")
            if (temp ~= nil) and (human ~= nil) and (human.Health > 0) then
                if (temp.Position - pos).magnitude < dist then
                    table.insert(torso,temp)
                    dist = (temp.Position - pos).magnitude
                end
            end
        end
    end
    return torso
end

----------------------------------------------------------------------------

function checkIfNotPlayer(model)
if model.CanCollide == true and model ~= char and model.Parent ~= char and model.Parent.Parent ~= char and model.Parent.Parent ~= char and model.Parent ~= DebrisModel and model.Parent.Parent ~= DebrisModel and model.Parent.Parent.Parent ~= DebrisModel and model ~= wings and model.Parent ~= wings and model.Parent.Parent ~= wings then
return true
else
return false
end
end

----------------------------------------------------------------------------

function newWeld(wp0, wp1, wc0x, wc0y, wc0z)

  local wld = Instance.new("Weld", wp1)

  wld.Part0 = wp0

  wld.Part1 = wp1

  wld.C0 = CFrame.new(wc0x, wc0y, wc0z)

  return wld

end

function weld(model)
  local parts,last = {}
  local function scan(parent)
    for _,v in pairs(parent:GetChildren()) do
      if (v:IsA("BasePart")) then
        if (last) then
          local w = Instance.new("Weld")
          w.Name = ("%s_Weld"):format(v.Name)
          w.Part0,w.Part1 = last,v
          w.C0 = last.CFrame:inverse()
          w.C1 = v.CFrame:inverse()
          w.Parent = last
        end
        last = v
        table.insert(parts,v)
      end
      scan(v)
    end
  end
  scan(model)
  for _,v in pairs(parts) do
        v.Anchored = false
        v.Locked = true
        v.Anchored = false
        v.BackSurface = Enum.SurfaceType.SmoothNoOutlines
        v.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
        v.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
        v.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
        v.RightSurface = Enum.SurfaceType.SmoothNoOutlines
        v.TopSurface = Enum.SurfaceType.SmoothNoOutlines
        v.CustomPhysicalProperties = PhysicalProperties.new(0,0,0)
  end
end

----------------------------------------------------------------------------

function calculate(part,asd)
local Head = hed
local RightShoulder = asd
local RightArm = part
local MousePosition = mouse.Hit.p
local ToMouse = (MousePosition - Head.Position).unit
local Angle = math.acos(ToMouse:Dot(Vector3.new(0, 1, 0)))
local FromRightArmPos = (Head.Position + Head.CFrame:vectorToWorldSpace(Vector3.new(((Head.Size.X / 2) + (RightArm.Size.X / 2)), ((Head.Size.Y / 2) - (RightArm.Size.Z / 2)), 0)))
local ToMouseRightArm = ((MousePosition - FromRightArmPos) * Vector3.new(1 ,0, 1)).unit
local Look = (Head.CFrame.lookVector * Vector3.new(1, 0, 1)).unit
local LateralAngle = math.acos(ToMouseRightArm:Dot(Look))
if tostring(LateralAngle) == "-1.#IND" then
LateralAngle = 0
end
local Cross = Head.CFrame.lookVector:Cross(ToMouseRightArm)
if LateralAngle > (math.pi / 2) then
LateralAngle = (math.pi / 2)
local Torso = root
local Point = Torso.CFrame:vectorToObjectSpace(mouse.Hit.p-Torso.CFrame.p)
if Point.Z > 0 then
if Point.X > -0 and RightArm == rarm then
Torso.CFrame = CFrame.new(Torso.Position,Vector3.new(mouse.Hit.X,Torso.Position.Y,mouse.Hit.Z))*CFrame.Angles(0,math.rad(110),0)
elseif Point.X < 0 and RightArm == rarm then
Torso.CFrame = CFrame.new(Torso.Position,Vector3.new(mouse.Hit.X,Torso.Position.Y,mouse.Hit.Z))*CFrame.Angles(0,math.rad(-110),0)
end
end
end
if Cross.Y < 0 then
LateralAngle = -LateralAngle
end
return(CFrame.Angles(((math.pi / 2) - Angle), ((math.pi / 2) + LateralAngle), math.pi/2))
end

----------------------------------------------------------------------------

function sound(id,position,vol,pitch,start,finish)
  coroutine.resume(coroutine.create(function()

  local part = Instance.new("Part",workspace)
  part.Position = position
  part.Size = Vector3.new(0,0,0)
  part.CanCollide = false
  part.Transparency = 1

  local sound = Instance.new("Sound",part)

  sound.SoundId = "rbxassetid://"..id

  repeat rs:wait() until sound.IsLoaded
  
  if vol ~= nil then
    sound.Volume = vol
  end

  if pitch ~= nil then
    sound.PlaybackSpeed = pitch
  end

  if start ~= nil then
    sound.TimePosition = start
  end

  if finish ~= nil then
    debris:AddItem(part,finish-start)
  else
    debris:AddItem(part,sound.TimeLength)
  end
  
  sound:Play()  

  return sound

  end))
end

----------------------------------------------------------------------------

function computeDirection(vec)
local lenSquared = vec.magnitude * vec.magnitude
local invSqrt = 1 / math.sqrt(lenSquared)
return Vector3.new(vec.x * invSqrt, vec.y * invSqrt, vec.z * invSqrt)
end

----------------------------------------------------------------------------

local shaking = 0
function shake(num) if num > shaking then shaking = num end end
game:GetService("RunService").RenderStepped:connect(function()
hum.CameraOffset = Vector3.new(math.random(-1,1),math.random(-1,1),math.random(-1,1))*(shaking/100)
if shaking > 0 then shaking = shaking - 1 else shaking = 0 end
end)

plr = game:GetService("Players").LocalPlayer
DebrisModel = Instance.new("Model",plr.Character)
DebrisModel.Name = "DebrisModel"

function Effect(mesh,size,transparency,material,color,position,rotation,sizechange,rotationchange,transparencychange,acceleration)
 
 local part = Instance.new("Part",DebrisModel)
  part.Anchored = true
  part.CanCollide = false
  part.Size = Vector3.new(1,1,1)
  part.Transparency = transparency
  part.Material = material
  part.Color = color
  part.CFrame = CFrame.new(position)*CFrame.Angles(math.rad(rotation.X),math.rad(rotation.Y),math.rad(rotation.Z))
 
 local partmesh = Instance.new("SpecialMesh",part)
  if tonumber(mesh) == nil then partmesh.MeshType = mesh else partmesh.MeshId = "rbxassetid://"..mesh end
  partmesh.Scale = size
 
 local pvalue = Instance.new("Vector3Value",part)
  pvalue.Name = "Position"
  pvalue.Value = part.Position
 
 local svalue = Instance.new("Vector3Value",part)
  svalue.Name = "Size"
  svalue.Value = sizechange

 local rvalue = Instance.new("Vector3Value",part)
  rvalue.Name = "Rotation"
  rvalue.Value = rotationchange
  
 local tvalue = Instance.new("NumberValue",part)
  tvalue.Name = "Transparency"
  tvalue.Value = transparencychange

 local avalue = Instance.new("NumberValue",part)
  avalue.Name = "Acceleration"
  avalue.Value = acceleration
 
 part.Name = "EFFECT"
 
 return part

end

game:GetService("RunService").RenderStepped:connect(function()


 if not plr.Character:FindFirstChild("DebrisModel") then
  DebrisModel = Instance.new("Model",plr.Character)
  DebrisModel.Name = "DebrisModel"
 end

 for i,v in pairs(DebrisModel:GetChildren()) do
  if v:IsA("BasePart") and v.Name == "EFFECT" then
   local pvalue = v:FindFirstChild("Position").Value
   local svalue = v:FindFirstChild("Size").Value
   local rvalue = v:FindFirstChild("Rotation").Value
   local tvalue = v:FindFirstChild("Transparency").Value
   local avalue = v:FindFirstChild("Acceleration").Value
   local mesh = v:FindFirstChild("Mesh")
   mesh.Scale = mesh.Scale + svalue
   v:FindFirstChild("Size").Value = v:FindFirstChild("Size").Value + (Vector3.new(1,1,1)*avalue)
   v.Transparency = v.Transparency + tvalue
   v.CFrame = v.CFrame*CFrame.Angles(math.rad(rvalue.X),math.rad(rvalue.Y),math.rad(rvalue.Z))
   if v.Transparency >= 1 or mesh.Scale.X < 0 or mesh.Scale.Y < 0 or mesh.Scale.Z < 0 then
     v:Destroy()
   end
  end
 end


end)

----------------------------------------------------------------------------
skin_color = BrickColor.new("Light orange")
--p:ClearCharacterAppearance()
--hed:WaitForChild("face"):Destroy()

----------------------------------------------------------------------------
music(540857600)
equalizer = Instance.new("EqualizerSoundEffect",torso:FindFirstChild("MusicRuin"))

local size = 1

newWeld(torso, larm, -1.5*size, 0.5*size, 0)
larm.Weld.C1 = CFrame.new(0, 0.5*size, 0)
newWeld(torso, rarm, 1.5*size, 0.5*size, 0)
rarm.Weld.C1 = CFrame.new(0, 0.5*size, 0)
newWeld(torso, hed, 0, 1.5*size, 0)
newWeld(torso, lleg, -0.5*size, -1, 0)
lleg.Weld.C1 = CFrame.new(0, 1*size, 0)
newWeld(torso, rleg, 0.5*size, -1*size, 0)
rleg.Weld.C1 = CFrame.new(0, 1*size, 0)
newWeld(root, torso, 0, -1*size, 0)
torso.Weld.C1 = CFrame.new(0, -1*size, 0)

emitters={}
for i,v in pairs(char:GetChildren()) do
if v:IsA("Part") and v.Name ~= "HumanoidRootPart" then
local emitter = Instance.new("ParticleEmitter",v)
emitter.LightEmission = 1
emitter.Transparency = NumberSequence.new(0.95,1)
emitter.Size = NumberSequence.new(2,5)
emitter.SpreadAngle = Vector2.new(360,360)
emitter.Speed = NumberRange.new(1)
emitter.Lifetime = NumberRange.new(0.75)
emitter.Texture = "rbxassetid://133619974"
emitter.Rate = 20
emitter.Color = ColorSequence.new(Color3.new(1,0,0))
emitter.LockedToPart = true
table.insert(emitters,emitter)
end
end
----------------------------------------------------------------------------------------


Model0 = Instance.new("Model")
Part1 = Instance.new("Part")
Part2 = Instance.new("Part")
Part3 = Instance.new("Part")
Part4 = Instance.new("Part")
Part5 = Instance.new("Part")
Part6 = Instance.new("Part")
Part7 = Instance.new("Part")









----------------------------------------------------------------------------
HitBox = Instance.new("Part",DebrisModel)
HitBox.Size = Vector3.new(0.5,0.5,2.45)
HitBox.CanCollide = false
HitBox:BreakJoints()
HitBox.Transparency = 1
atch0 = Instance.new("Attachment",HitBox)
atch0.Position = Vector3.new(0,0,HitBox.Size.Z/2)
atch1 = Instance.new("Attachment",HitBox)
atch1.Position = Vector3.new(0,0,-HitBox.Size.Z/2)
trail = Instance.new("Trail",HitBox)
trail.Attachment0 = atch0
trail.Attachment1 = atch1
trail.Lifetime = 0.2
trail.Enabled = true
trail.LightEmission = 1
trail.LightInfluence = 0
trail.Color = ColorSequence.new(Color3.new(1,0,0))
trail.Transparency = NumberSequence.new(0,1)

function ded(model)
kills = kills + 1
model.Archivable = true
model.Head:ClearAllChildren()
local clone = model:Clone()
clone.Parent = workspace
clone.Name = "DED"
model:Destroy()
clone:FindFirstChildOfClass("Humanoid")
local emitters={}
for i,v in pairs(clone:GetChildren()) do
if v:IsA("Accoutrement") then
v:Destroy()
end
if v:IsA("Part") then
v.Anchored = true
v.CanCollide = false
v.Transparency = 1
local emitter = Instance.new("ParticleEmitter",v)
emitter.LightEmission = 1
emitter.Transparency = NumberSequence.new(0,1)
emitter.Size = NumberSequence.new(0,0.8)
emitter.SpreadAngle = Vector2.new(360,360)
emitter.Speed = NumberRange.new(0.5)
emitter.Lifetime = NumberRange.new(0.75)
emitter.Texture = "rbxassetid://744949545"
emitter.Rate = 20
emitter.Color = ColorSequence.new(Color3.new(1,1,1))
emitter.LockedToPart = false
table.insert(emitters,emitter)
end
end
delay(1, function()
sound(427025525,clone.Head.Position,10,1)
for i,v in pairs(emitters) do
v.Speed = NumberRange.new(4)
v.Acceleration = Vector3.new(0,10,0)
delay(0.5, function()
v.Enabled = false
debris:AddItem(clone,0.75)
end)
end
end)
end

local alreadytouched = {}
HitBox.Touched:connect(function(ht)
coroutine.resume(coroutine.create(function()
local hit = ht.Parent
if mode == "determination" and hit.Name ~= "DED" and attacking == true and checkIfNotPlayer(ht) and hit:FindFirstChildOfClass("Humanoid") and hit:FindFirstChildOfClass("Humanoid").Health > 0 then
local hurt = true
for i,v in pairs(alreadytouched) do if v == hit then hurt = false end end
if hurt == true then
table.insert(alreadytouched,hit)
sound(388826051,ht.Position,10,1)
ded(hit)
end
end
end))
end)

function createknife()
Model0 = Instance.new("Model")
Part1 = Instance.new("Part")
BlockMesh2 = Instance.new("BlockMesh")
Part3 = Instance.new("Part")
BlockMesh4 = Instance.new("BlockMesh")
Part5 = Instance.new("Part")
Part6 = Instance.new("Part")
BlockMesh7 = Instance.new("BlockMesh")
Part8 = Instance.new("Part")
Part9 = Instance.new("Part")
Part10 = Instance.new("Part")
SpecialMesh11 = Instance.new("SpecialMesh")
Part12 = Instance.new("Part")
Model0.Parent = char
Part1.Parent = Model0
Part1.Anchored = true
Part1.CanCollide = false
Part1.Size = Vector3.new(0.280000031, 0.0500000007, 0.0500000007)
Part1.CFrame = CFrame.new(49.5, 20.7350044, 52.3199997, 0.99999994, 0, 0, 0, 1, -5.56362707e-08, 0, 5.56362707e-08, 1)
Part1.BottomSurface = Enum.SurfaceType.Smooth
Part1.TopSurface = Enum.SurfaceType.Smooth
Part1.Position = Vector3.new(49.5, 20.7350044, 52.3199997)
Part1.Color = Color3.new(0.972549, 0.972549, 0.972549)
BlockMesh2.Parent = Part1
BlockMesh2.Scale = Vector3.new(1, 0.399999797, 0.400000781)
BlockMesh2.Scale = Vector3.new(1, 0.399999797, 0.400000781)
Part3.Parent = Model0
Part3.Anchored = true
Part3.CanCollide = false
Part3.Size = Vector3.new(0.220000014, 0.0500000007, 0.0500000007)
Part3.CFrame = CFrame.new(49.5, 20.6250038, 53.6199989, 0.99999994, 0, 0, 0, 1, -5.56362707e-08, 0, 5.56362707e-08, 1)
Part3.BottomSurface = Enum.SurfaceType.Smooth
Part3.TopSurface = Enum.SurfaceType.Smooth
Part3.Position = Vector3.new(49.5, 20.6250038, 53.6199989)
Part3.Color = Color3.new(0.972549, 0.972549, 0.972549)
BlockMesh4.Parent = Part3
BlockMesh4.Scale = Vector3.new(1, 0.399999797, 0.400000781)
BlockMesh4.Scale = Vector3.new(1, 0.399999797, 0.400000781)
Part5.Parent = Model0
Part5.Anchored = true
Part5.CanCollide = false
Part5.Size = Vector3.new(0.159999996, 0.400000006, 1.70000005)
Part5.CFrame = CFrame.new(49.5, 20.5750046, 51.4300003, 0.99999994, 0, 0, 0, 1, -5.56362707e-08, 0, 5.56362707e-08, 1)
Part5.BottomSurface = Enum.SurfaceType.Smooth
Part5.TopSurface = Enum.SurfaceType.Smooth
Part5.Position = Vector3.new(49.5, 20.5750046, 51.4300003)
Part5.Color = Color3.new(1, 0, 0)
Part6.Parent = Model0
Part6.Anchored = true
Part6.CanCollide = false
Part6.Size = Vector3.new(0.280000031, 0.0500000007, 0.0500000007)
Part6.CFrame = CFrame.new(49.5, 20.4150047, 52.3199997, 0.99999994, 0, 0, 0, 1, -5.56362707e-08, 0, 5.56362707e-08, 1)
Part6.BottomSurface = Enum.SurfaceType.Smooth
Part6.TopSurface = Enum.SurfaceType.Smooth
Part6.Position = Vector3.new(49.5, 20.4150047, 52.3199997)
Part6.Color = Color3.new(0.972549, 0.972549, 0.972549)
BlockMesh7.Parent = Part6
BlockMesh7.Scale = Vector3.new(1, 0.399999797, 0.400000781)
BlockMesh7.Scale = Vector3.new(1, 0.399999797, 0.400000781)
Part8.Name = "asd"
Part8.Parent = Model0
Part8.Anchored = true
Part8.CanCollide = false
Part8.Size = Vector3.new(0.200000003, 0.200000003, 1.30000007)
Part8.CFrame = CFrame.new(49.5, 20.6250038, 52.9300003, 0.99999994, 0, 0, 0, 1, -5.56362707e-08, 0, 5.56362707e-08, 1)
Part8.BottomSurface = Enum.SurfaceType.Smooth
Part8.TopSurface = Enum.SurfaceType.Smooth
Part8.Position = Vector3.new(49.5, 20.6250038, 52.9300003)
Part8.Color = Color3.new(0.105882, 0.164706, 0.207843)
Part9.Parent = Model0
Part9.Anchored = true
Part9.CanCollide = false
Part9.Size = Vector3.new(0.200000003, 0.25999999, 0.100000039)
Part9.CFrame = CFrame.new(49.5, 20.595005, 53.6199989, 0.99999994, 0, 0, 0, 1, -5.56362707e-08, 0, 5.56362707e-08, 1)
Part9.BottomSurface = Enum.SurfaceType.Smooth
Part9.TopSurface = Enum.SurfaceType.Smooth
Part9.Position = Vector3.new(49.5, 20.595005, 53.6199989)
Part9.Color = Color3.new(0.105882, 0.164706, 0.207843)
Part10.Parent = Model0
Part10.Rotation = Vector3.new(0, 0, 180)
Part10.Anchored = true
Part10.CanCollide = false
Part10.Size = Vector3.new(0.159999996, 0.400000006, 0.800000012)
Part10.CFrame = CFrame.new(49.5, 20.5750046, 50.1800003, -0.99999994, -8.74227766e-08, 3.82137093e-15, 8.74227695e-08, -1, 3.17865059e-08, 1.04250613e-15, 3.17865059e-08, 1)
Part10.BottomSurface = Enum.SurfaceType.Smooth
Part10.TopSurface = Enum.SurfaceType.Smooth
Part10.Position = Vector3.new(49.5, 20.5750046, 50.1800003)
Part10.Color = Color3.new(1, 0, 0)
SpecialMesh11.Parent = Part10
SpecialMesh11.MeshType = Enum.MeshType.Wedge
Part12.Parent = Model0
Part12.Anchored = true
Part12.CanCollide = false
Part12.Size = Vector3.new(0.25999999, 0.460000008, 0.100000039)
Part12.CFrame = CFrame.new(49.5, 20.5750046, 52.3199997, 0.99999994, 0, 0, 0, 1, -5.56362707e-08, 0, 5.56362707e-08, 1)
Part12.BottomSurface = Enum.SurfaceType.Smooth
Part12.TopSurface = Enum.SurfaceType.Smooth
Part12.Position = Vector3.new(49.5, 20.5750046, 52.3199997)
Part12.Color = Color3.new(0.105882, 0.164706, 0.207843)
weld(Model0)
for i,v in pairs(Model0:GetChildren()) do
if v:IsA("Part") and v.Color == Color3.new(1,0,0) then
v.Material = Enum.Material.Neon
end
end
return Model0
end



----------------------------------------------------------------------------------------

function createpistol()
Model0 = Instance.new("Model")
Part1 = Instance.new("Part")
BlockMesh2 = Instance.new("BlockMesh")
Part3 = Instance.new("Part")
Part4 = Instance.new("Part")
Part5 = Instance.new("Part")
Part6 = Instance.new("Part")
Part7 = Instance.new("Part")
Part8 = Instance.new("Part")
Part9 = Instance.new("Part")
Part10 = Instance.new("Part")
Part11 = Instance.new("Part")
Part12 = Instance.new("Part")
Part13 = Instance.new("Part")
Part14 = Instance.new("Part")
Part15 = Instance.new("Part")
Part16 = Instance.new("Part")
Part17 = Instance.new("Part")
Part18 = Instance.new("Part")
Part19 = Instance.new("Part")
Model0.Name = "Pistol"
Model0.Parent = char
Part1.Name = "ShootPos"
Part1.Parent = Model0
Part1.BrickColor = BrickColor.new("Really black")
Part1.Anchored = false
Part1.CanCollide = false
Part1.Size = Vector3.new(0.100000001, 0.100000001, 0.0500000007)
Part1.CFrame = CFrame.new(-90, 10.5000019, 13.8957434, 1, 0, 0, 0, 1, -2.08616257e-07, 0, 2.08616257e-07, 1)
Part1.BottomSurface = Enum.SurfaceType.Smooth
Part1.TopSurface = Enum.SurfaceType.Smooth
Part1.Color = Color3.new(0.0666667, 0.0666667, 0.0666667)
Part1.Position = Vector3.new(-90, 10.5000019, 13.8957434)
Part1.Color = Color3.new(0.0666667, 0.0666667, 0.0666667)
BlockMesh2.Parent = Part1
BlockMesh2.Scale = Vector3.new(1, 1, 0.199999988)
BlockMesh2.Scale = Vector3.new(1, 1, 0.199999988)
Part3.Parent = Model0
Part3.BrickColor = BrickColor.new("Pearl")
Part3.Anchored = true
Part3.CanCollide = false
Part3.Size = Vector3.new(0.100000001, 0.550000012, 0.0500000007)
Part3.CFrame = CFrame.new(-90.0999985, 10.3750019, 13.8757429, 1, 0, 0, 0, 1, -2.08616257e-07, 0, 2.08616257e-07, 1)
Part3.BottomSurface = Enum.SurfaceType.Smooth
Part3.TopSurface = Enum.SurfaceType.Smooth
Part3.Color = Color3.new(0.905882, 0.905882, 0.92549)
Part3.Position = Vector3.new(-90.0999985, 10.3750019, 13.8757429)
Part3.Color = Color3.new(0.905882, 0.905882, 0.92549)
Part4.Parent = Model0
Part4.BrickColor = BrickColor.new("Pearl")
Part4.Anchored = true
Part4.CanCollide = false
Part4.Size = Vector3.new(0.300000012, 0.349999994, 0.0500000007)
Part4.CFrame = CFrame.new(-90, 10.2750025, 13.8757429, 1, 0, 0, 0, 1, -2.08616257e-07, 0, 2.08616257e-07, 1)
Part4.BottomSurface = Enum.SurfaceType.Smooth
Part4.TopSurface = Enum.SurfaceType.Smooth
Part4.Color = Color3.new(0.905882, 0.905882, 0.92549)
Part4.Position = Vector3.new(-90, 10.2750025, 13.8757429)
Part4.Color = Color3.new(0.905882, 0.905882, 0.92549)
Part5.Parent = Model0
Part5.BrickColor = BrickColor.new("Pearl")
Part5.Rotation = Vector3.new(15, 0, 0)
Part5.Anchored = true
Part5.CanCollide = false
Part5.Size = Vector3.new(0.200000003, 0.25, 0.150000006)
Part5.CFrame = CFrame.new(-90, 10.4379425, 15.8274469, 1, 0, 0, 0, 0.965925753, -0.258819252, 0, 0.258819252, 0.965925753)
Part5.BottomSurface = Enum.SurfaceType.Smooth
Part5.TopSurface = Enum.SurfaceType.Smooth
Part5.Color = Color3.new(0.905882, 0.905882, 0.92549)
Part5.Position = Vector3.new(-90, 10.4379425, 15.8274469)
Part5.Orientation = Vector3.new(15, 0, 0)
Part5.Color = Color3.new(0.905882, 0.905882, 0.92549)
Part6.Parent = Model0
Part6.BrickColor = BrickColor.new("Pearl")
Part6.Anchored = true
Part6.CanCollide = false
Part6.Size = Vector3.new(0.300000012, 0.550000012, 1.89999998)
Part6.CFrame = CFrame.new(-90, 10.3750019, 14.8507433, 1, 0, 0, 0, 1, -2.08616257e-07, 0, 2.08616257e-07, 1)
Part6.BottomSurface = Enum.SurfaceType.Smooth
Part6.TopSurface = Enum.SurfaceType.Smooth
Part6.Color = Color3.new(0.905882, 0.905882, 0.92549)
Part6.Position = Vector3.new(-90, 10.3750019, 14.8507433)
Part6.Color = Color3.new(0.905882, 0.905882, 0.92549)
Part7.Parent = Model0
Part7.BrickColor = BrickColor.new("Pearl")
Part7.Anchored = true
Part7.CanCollide = false
Part7.Size = Vector3.new(0.100000001, 0.0500000007, 0.0500000007)
Part7.CFrame = CFrame.new(-90.0999985, 10.6750021, 15.6257429, 1, 0, 0, 0, 1, -2.08616257e-07, 0, 2.08616257e-07, 1)
Part7.BottomSurface = Enum.SurfaceType.Smooth
Part7.TopSurface = Enum.SurfaceType.Smooth
Part7.Color = Color3.new(0.905882, 0.905882, 0.92549)
Part7.Position = Vector3.new(-90.0999985, 10.6750021, 15.6257429)
Part7.Color = Color3.new(0.905882, 0.905882, 0.92549)
Part8.Parent = Model0
Part8.BrickColor = BrickColor.new("Black")
Part8.Rotation = Vector3.new(-15, 0, 0)
Part8.Anchored = true
Part8.CanCollide = false
Part8.Size = Vector3.new(0.220000014, 0.5, 0.209999993)
Part8.CFrame = CFrame.new(-90, 9.71499538, 15.4898481, 1, 0, 0, 0, 0.965925872, 0.258818835, 0, -0.258818835, 0.965925872)
Part8.BottomSurface = Enum.SurfaceType.Smooth
Part8.TopSurface = Enum.SurfaceType.Smooth
Part8.Color = Color3.new(0.105882, 0.164706, 0.207843)
Part8.Position = Vector3.new(-90, 9.71499538, 15.4898481)
Part8.Orientation = Vector3.new(-15, 0, 0)
Part8.Color = Color3.new(0.105882, 0.164706, 0.207843)
Part9.Parent = Model0
Part9.BrickColor = BrickColor.new("Pearl")
Part9.Anchored = true
Part9.CanCollide = false
Part9.Size = Vector3.new(0.100000001, 0.550000012, 0.0500000007)
Part9.CFrame = CFrame.new(-89.9000015, 10.3750019, 13.8757429, 1, 0, 0, 0, 1, -2.08616257e-07, 0, 2.08616257e-07, 1)
Part9.BottomSurface = Enum.SurfaceType.Smooth
Part9.TopSurface = Enum.SurfaceType.Smooth
Part9.Color = Color3.new(0.905882, 0.905882, 0.92549)
Part9.Position = Vector3.new(-89.9000015, 10.3750019, 13.8757429)
Part9.Color = Color3.new(0.905882, 0.905882, 0.92549)
Part10.Parent = Model0
Part10.BrickColor = BrickColor.new("Pearl")
Part10.Anchored = true
Part10.CanCollide = false
Part10.Size = Vector3.new(0.100000001, 0.0500000007, 0.0500000007)
Part10.CFrame = CFrame.new(-89.9000015, 10.6750021, 15.6257429, 1, 0, 0, 0, 1, -2.08616257e-07, 0, 2.08616257e-07, 1)
Part10.BottomSurface = Enum.SurfaceType.Smooth
Part10.TopSurface = Enum.SurfaceType.Smooth
Part10.Color = Color3.new(0.905882, 0.905882, 0.92549)
Part10.Position = Vector3.new(-89.9000015, 10.6750021, 15.6257429)
Part10.Color = Color3.new(0.905882, 0.905882, 0.92549)
Part11.Parent = Model0
Part11.BrickColor = BrickColor.new("Pearl")
Part11.Anchored = true
Part11.CanCollide = false
Part11.Size = Vector3.new(0.200000003, 0.150000006, 0.600000024)
Part11.CFrame = CFrame.new(-90, 9.37500191, 15.6007433, 1, 0, 0, 0, 1, -2.08616257e-07, 0, 2.08616257e-07, 1)
Part11.BottomSurface = Enum.SurfaceType.Smooth
Part11.TopSurface = Enum.SurfaceType.Smooth
Part11.Color = Color3.new(0.905882, 0.905882, 0.92549)
Part11.Position = Vector3.new(-90, 9.37500191, 15.6007433)
Part11.Color = Color3.new(0.905882, 0.905882, 0.92549)
Part12.Parent = Model0
Part12.BrickColor = BrickColor.new("Pearl")
Part12.Rotation = Vector3.new(-30, 0, 0)
Part12.Anchored = true
Part12.CanCollide = false
Part12.Size = Vector3.new(0.100000001, 0.150000006, 0.0500000007)
Part12.CFrame = CFrame.new(-90, 9.97165203, 15.1132431, 1, 0, 0, 0, 0.866025448, 0.5, 0, -0.5, 0.866025448)
Part12.BottomSurface = Enum.SurfaceType.Smooth
Part12.TopSurface = Enum.SurfaceType.Smooth
Part12.Color = Color3.new(0.905882, 0.905882, 0.92549)
Part12.Position = Vector3.new(-90, 9.97165203, 15.1132431)
Part12.Orientation = Vector3.new(-30, 0, 0)
Part12.Color = Color3.new(0.905882, 0.905882, 0.92549)
Part13.Parent = Model0
Part13.BrickColor = BrickColor.new("Pearl")
Part13.Anchored = true
Part13.CanCollide = false
Part13.Size = Vector3.new(0.300000012, 0.100000001, 0.0500000007)
Part13.CFrame = CFrame.new(-90, 10.6000023, 13.8757429, 1, 0, 0, 0, 1, -2.08616257e-07, 0, 2.08616257e-07, 1)
Part13.BottomSurface = Enum.SurfaceType.Smooth
Part13.TopSurface = Enum.SurfaceType.Smooth
Part13.Color = Color3.new(0.905882, 0.905882, 0.92549)
Part13.Position = Vector3.new(-90, 10.6000023, 13.8757429)
Part13.Color = Color3.new(0.905882, 0.905882, 0.92549)
Part14.Parent = Model0
Part14.BrickColor = BrickColor.new("Pearl")
Part14.Rotation = Vector3.new(-30, 0, 0)
Part14.Anchored = true
Part14.CanCollide = false
Part14.Size = Vector3.new(0.200000003, 0.100000001, 0.25)
Part14.CFrame = CFrame.new(-90, 10.5216522, 15.9065447, 1, 0, 0, 0, 0.866025329, 0.49999997, 0, -0.49999997, 0.866025329)
Part14.BottomSurface = Enum.SurfaceType.Smooth
Part14.TopSurface = Enum.SurfaceType.Smooth
Part14.Color = Color3.new(0.905882, 0.905882, 0.92549)
Part14.Position = Vector3.new(-90, 10.5216522, 15.9065447)
Part14.Orientation = Vector3.new(-30, 0, 0)
Part14.Color = Color3.new(0.905882, 0.905882, 0.92549)
Part15.Parent = Model0
Part15.BrickColor = BrickColor.new("White")
Part15.Rotation = Vector3.new(-105, 0, 0)
Part15.Anchored = true
Part15.CanCollide = false
Part15.Size = Vector3.new(0.100000001, 0.200000003, 0.0500000007)
Part15.CFrame = CFrame.new(-90, 9.92812252, 15.2373915, 1, 0, 0, 0, -0.258819371, 0.965925813, 0, -0.965925813, -0.258819371)
Part15.BottomSurface = Enum.SurfaceType.Smooth
Part15.TopSurface = Enum.SurfaceType.Smooth
Part15.Color = Color3.new(0.94902, 0.952941, 0.952941)
Part15.Position = Vector3.new(-90, 9.92812252, 15.2373915)
Part15.Orientation = Vector3.new(-75, 180, 180)
Part15.Color = Color3.new(0.94902, 0.952941, 0.952941)
Part16.Name = "asd"
Part16.Parent = Model0
Part16.BrickColor = BrickColor.new("Pearl")
Part16.Rotation = Vector3.new(-15, 0, 0)
Part16.Anchored = true
Part16.CanCollide = false
Part16.Size = Vector3.new(0.200000003, 1.14999998, 0.400000006)
Part16.CFrame = CFrame.new(-90, 9.93709087, 15.5425692, 1, 0, 0, 0, 0.965925872, 0.258818835, 0, -0.258818835, 0.965925872)
Part16.BottomSurface = Enum.SurfaceType.Smooth
Part16.TopSurface = Enum.SurfaceType.Smooth
Part16.Color = Color3.new(0.905882, 0.905882, 0.92549)
Part16.Position = Vector3.new(-90, 9.93709087, 15.5425692)
Part16.Orientation = Vector3.new(-15, 0, 0)
Part16.Color = Color3.new(0.905882, 0.905882, 0.92549)
Part17.Parent = Model0
Part17.BrickColor = BrickColor.new("Pearl")
Part17.Anchored = true
Part17.CanCollide = false
Part17.Size = Vector3.new(0.100000001, 0.100000001, 0.0500000007)
Part17.CFrame = CFrame.new(-90, 10.0500021, 15.0757437, 1, 0, 0, 0, 1, -2.08616257e-07, 0, 2.08616257e-07, 1)
Part17.BottomSurface = Enum.SurfaceType.Smooth
Part17.TopSurface = Enum.SurfaceType.Smooth
Part17.Color = Color3.new(0.905882, 0.905882, 0.92549)
Part17.Position = Vector3.new(-90, 10.0500021, 15.0757437)
Part17.Color = Color3.new(0.905882, 0.905882, 0.92549)
Part18.Parent = Model0
Part18.BrickColor = BrickColor.new("Pearl")
Part18.Anchored = true
Part18.CanCollide = false
Part18.Size = Vector3.new(0.100000001, 0.0500000007, 0.0500000007)
Part18.CFrame = CFrame.new(-90, 10.6750021, 13.8757429, 1, 0, 0, 0, 1, -2.08616257e-07, 0, 2.08616257e-07, 1)
Part18.BottomSurface = Enum.SurfaceType.Smooth
Part18.TopSurface = Enum.SurfaceType.Smooth
Part18.Color = Color3.new(0.905882, 0.905882, 0.92549)
Part18.Position = Vector3.new(-90, 10.6750021, 13.8757429)
Part18.Color = Color3.new(0.905882, 0.905882, 0.92549)
Part19.Parent = Model0
Part19.BrickColor = BrickColor.new("Pearl")
Part19.Anchored = true
Part19.CanCollide = false
Part19.Size = Vector3.new(0.400000006, 0.200000003, 1.05000007)
Part19.CFrame = CFrame.new(-90, 10.1500015, 14.4757433, 1, 0, 0, 0, 1, -2.08616257e-07, 0, 2.08616257e-07, 1)
Part19.BottomSurface = Enum.SurfaceType.Smooth
Part19.TopSurface = Enum.SurfaceType.Smooth
Part19.Color = Color3.new(0.905882, 0.905882, 0.92549)
Part19.Position = Vector3.new(-90, 10.1500015, 14.4757433)
Part19.Color = Color3.new(0.905882, 0.905882, 0.92549)
for i,v in pairs(Model0:GetChildren()) do
if v:IsA("Part") then
v.Color = Color3.new(1,1,0)
v.Material = Enum.Material.Neon
v.Transparency = 0
v.CanCollide = false
end
end
weld(Model0)
return Model0
end

mode = "determination"
function justice()
mode = "justice"
for i=1,5 do rs:wait()
local asd = Vector3.new(math.random(-10000,10000)/10000,math.random(-10000,10000)/10000,math.random(-10000,10000)/10000)
Effect(Enum.MeshType.Brick,Vector3.new(1,1,1),0,Enum.Material.Neon,Color3.new(1,1,0),rarm.RightGripAttachment.WorldPosition+(asd*1),asd*360,Vector3.new(0.5,0.5,0.5),asd*1,0.1,0.0005)
end
knife:Destroy()
pistol = createpistol()
newWeld(rarm,pistol.asd,0,-1,0)
pistol.asd.Weld.C1 = CFrame.Angles(math.rad(110),0,0)
end

function determination()
mode = "determination"
for i=1,5 do rs:wait()
local asd = Vector3.new(math.random(-10000,10000)/10000,math.random(-10000,10000)/10000,math.random(-10000,10000)/10000)
Effect(Enum.MeshType.Brick,Vector3.new(1,1,1),0,Enum.Material.Neon,Color3.new(1,0,0),rarm.RightGripAttachment.WorldPosition+(asd*1),asd*360,Vector3.new(0.5,0.5,0.5),asd*1,0.1,0.0005)
end
pistol:Destroy()
knife = createknife()
newWeld(rarm,knife.asd,0,-1,0)
end

debounce = false
mouse.KeyDown:connect(function(key)
if debounce == false then
debounce = true
if key == "e" then
sound(462606062,root.Position,10,1)
if mode == "determination" then
justice()
elseif mode == "justice" then
determination()
end
end
delay(0.3,function() debounce = false end)
end
end)

----------------------------------------------------------------------------------------

function slash()
local spd = 0.2
for i=1,15 do rs:wait()
hed.Weld.C0 = Lerp(hed.Weld.C0, CFrame.new(0,1.5,-.1)     *CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)), spd)
hed.Weld.C1 = Lerp(hed.Weld.C1, CFrame.new(0,0,0)         *CFrame.Angles(math.rad(0),math.rad(-30),math.rad(0)), spd)
larm.Weld.C0 = Lerp(larm.Weld.C0, CFrame.new(-1.5,0.55,0) *CFrame.Angles(math.rad(0),math.rad(0),math.rad(-10)), spd)
rarm.Weld.C0 = Lerp(rarm.Weld.C0, CFrame.new(1.5,0.55,0)  *CFrame.Angles(math.rad(160),math.rad(0),math.rad(10)), spd)
torso.Weld.C0 = Lerp(torso.Weld.C0, CFrame.new(0, -1, 0)  *CFrame.Angles(math.rad(0),math.rad(-50),math.rad(10)), spd)
lleg.Weld.C0 = Lerp(lleg.Weld.C0, CFrame.new(-0.5,-0.95,0)*CFrame.Angles(math.rad(0),math.rad(50),math.rad(-10)), spd)
rleg.Weld.C0 = Lerp(rleg.Weld.C0, CFrame.new(0.5,-0.95,0) *CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)), spd)
end
sound(357417055,root.Position,10,1)
attacking = true
local spd = 0.4
for i=1,5 do rs:wait()
hed.Weld.C0 = Lerp(hed.Weld.C0, CFrame.new(0,1.5,-.1)     *CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)), spd)
hed.Weld.C1 = Lerp(hed.Weld.C1, CFrame.new(0,0,0)         *CFrame.Angles(math.rad(0),math.rad(80),math.rad(0)), spd)
larm.Weld.C0 = Lerp(larm.Weld.C0, CFrame.new(-1.5,0.55,0) *CFrame.Angles(math.rad(-10),math.rad(0),math.rad(-20)), spd)
rarm.Weld.C0 = Lerp(rarm.Weld.C0, CFrame.new(1.5,0.55,0)  *CFrame.Angles(math.rad(-10),math.rad(0),math.rad(0)), spd)
torso.Weld.C0 = Lerp(torso.Weld.C0, CFrame.new(0, -1, 0)  *CFrame.Angles(math.rad(0),math.rad(80),math.rad(-20)), spd)
lleg.Weld.C0 = Lerp(lleg.Weld.C0, CFrame.new(-0.5,-0.95,0)*CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)), spd)
rleg.Weld.C0 = Lerp(rleg.Weld.C0, CFrame.new(0.5,-0.95,0) *CFrame.Angles(math.rad(0),math.rad(-80),math.rad(20)), spd)
end
end

mouse.Button1Down:connect(function()
if debounce == false and mode == "determination" then
alreadytouched = {}
noidle = true
debounce = true
slash()
attacking = false
noidle = false
delay(0.05,function() debounce = false end)
end
end)

-----------------------------
local jumped = false
function boom()
freeze = true
sound(446961725,root.Position,10,1)
local bg = Instance.new("BodyGyro",root)
bg.Name = "lolnochara"
bg.P = 10000
bg.D = 100
bg.MaxTorque = Vector3.new(9e9,9e9,9e9)
if jumped == false then
root.CFrame = CFrame.new(root.Position,Vector3.new(mouse.Hit.x,root.Position.Y,mouse.Hit.z))
bg.CFrame = CFrame.new(root.Position,Vector3.new(mouse.Hit.x,root.Position.Y,mouse.Hit.z))
else
root.CFrame = CFrame.new(root.Position,mouse.Hit.p)
bg.CFrame = CFrame.new(root.Position,mouse.Hit.p)
end

local spd = 0.2
for i=1,20 do rs:wait()
if jumped == false then
bg.CFrame = CFrame.new(root.Position,Vector3.new(mouse.Hit.x,root.Position.Y,mouse.Hit.z))
else
bg.CFrame = CFrame.new(root.Position,mouse.Hit.p)
end
hed.Weld.C0 = Lerp(hed.Weld.C0, CFrame.new(0,1.5,-.1)     *CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)), spd)
hed.Weld.C1 = Lerp(hed.Weld.C1, CFrame.new(0,0,0)         *CFrame.Angles(math.rad(0),math.rad(90),math.rad(0)), spd)
larm.Weld.C0 = Lerp(larm.Weld.C0, CFrame.new(-1.5,0.55,0) *CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)), spd)
rarm.Weld.C0 = Lerp(rarm.Weld.C0, CFrame.new(1.5,0.55,0)  *CFrame.Angles(math.rad(45),math.rad(0),math.rad(90)), spd)
torso.Weld.C0 = Lerp(torso.Weld.C0, CFrame.new(0, -1, 0)  *CFrame.Angles(math.rad(0),math.rad(90),math.rad(0)), spd)
lleg.Weld.C0 = Lerp(lleg.Weld.C0, CFrame.new(-0.5,-0.95,0)*CFrame.Angles(math.rad(0),math.rad(-5),math.rad(0)), spd)
rleg.Weld.C0 = Lerp(rleg.Weld.C0, CFrame.new(0.5,-0.95,0) *CFrame.Angles(math.rad(0),math.rad(-20),math.rad(0)), spd)
end

bg:Destroy()

sound(470245800,root.Position,10,1)

local Part0 = Instance.new("Part",DebrisModel)
Part0.Name = "Bullet"
Part0.Material = Enum.Material.Neon
Part0.Color = Color3.new(1,1,0)
Part0.Anchored = true
local mesh = Instance.new("SpecialMesh",Part0)
mesh.MeshType = Enum.MeshType.Brick
Part0.CanCollide = false
local Position = rarm.Position
local Target = mouse.Hit.p
local direction = Target - Position
local direction = computeDirection(direction)
local ray = Ray.new(Position, (Target-Position).unit*1048)
local part, endPoint = workspace:FindPartOnRay(ray, char)
Part0.Size = Vector3.new(5,1,5)
mesh.Scale = Vector3.new(1,(Position-endPoint).magnitude+5,1)
local pos = Position + (direction * (mesh.Scale.Y/2))
Part0.CFrame = CFrame.new(pos,  pos + direction) * CFrame.Angles((math.pi/2)+math.rad(180), 0, 0)
local loop = nil
local i = 0
rs:connect(function()
local lole = (i/10)
mesh.Scale = Vector3.new(lole,mesh.Scale.Y,lole)
Part0.Transparency = Part0.Transparency + 0.1
i = i + 1
if Part0.Transparency >= 1 then
Part0:Destroy()
end
end)

if part and part.Parent:FindFirstChildOfClass("Humanoid") and checkIfNotPlayer(part) == true then
coroutine.resume(coroutine.create(function()
sound(388826051,part.Position,10,1)
ded(part.Parent)
end))
end

local spd = 0.5
for i=1,10 do rs:wait()
hed.Weld.C0 = Lerp(hed.Weld.C0, CFrame.new(0,1.5,-.1)     *CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)), spd)
hed.Weld.C1 = Lerp(hed.Weld.C1, CFrame.new(0,0,0)         *CFrame.Angles(math.rad(0),math.rad(90),math.rad(0)), spd)
larm.Weld.C0 = Lerp(larm.Weld.C0, CFrame.new(-1.5,0.55,0) *CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)), spd)
rarm.Weld.C0 = Lerp(rarm.Weld.C0, CFrame.new(1.5,0.55,0)  *CFrame.Angles(math.rad(45),math.rad(40),math.rad(90)), spd)
torso.Weld.C0 = Lerp(torso.Weld.C0, CFrame.new(0, -1, 0)  *CFrame.Angles(math.rad(0),math.rad(90),math.rad(0)), spd)
lleg.Weld.C0 = Lerp(lleg.Weld.C0, CFrame.new(-0.5,-0.95,0)*CFrame.Angles(math.rad(0),math.rad(-5),math.rad(0)), spd)
rleg.Weld.C0 = Lerp(rleg.Weld.C0, CFrame.new(0.5,-0.95,0) *CFrame.Angles(math.rad(0),math.rad(-20),math.rad(0)), spd)
end

freeze = false

end

mouse.Button1Down:connect(function()
if debounce == false and mode == "justice" then
alreadytouched = {}
noidle = true
debounce = true
boom()
attacking = false
noidle = false
delay(0.05,function() debounce = false end)
end
end)

----------------------------------------------------------------------------------------
velocityYFall=0
velocityYFall2=0
velocityYFall3=0
velocityYFall4=0
neckrotY=0
neckrotY2=0
torsorotY=0
torsorotY2=0
torsoY=0
torsoY2=0
colored = 0
sine = 0
change=0.4
movement=5
timeranim=0
running = false
glitched = false
backup = hed.Weld.C1
glitchedC1 = hed.Weld.C1

mouse.KeyDown:connect(function(key)
key = string.lower(key)
if string.byte(key) == 48 then
running = true
local keyup = mouse.KeyUp:connect(function(key)
if string.byte(key) == 48 then
running = false
end
end)
repeat rs:wait() until running == false
keyup:disconnect()
end
end)

icolor=1
imode=false

didjump = false
jumppower = 0
freeze = false
debounceimpact = false

function jumpimpact()
if debounceimpact == false then
debounceimpact = true
if jumppower < -150 then jumppower = -150 end
shake(-jumppower/5)
for i=1,-jumppower/20 do rs:wait()
hed.Weld.C1 = Lerp(hed.Weld.C1, CFrame.Angles(0,0,0), 0.05)
torso.Weld.C0 = Lerp(torso.Weld.C0, CFrame.new(0, (jumppower/20)*size-hum.HipHeight, 0) * CFrame.Angles(math.rad(0),math.rad(0), math.rad(0)), 0.05)
end
debounceimpact = false
end
end

local sond = nil
rs:connect(function()

if not torso:FindFirstChild("STATICSOUND") then
sond=Instance.new("Sound",torso)
sond.Name = "STATICSOUND"
sond.SoundId = "rbxassetid://223103466"
sond.Looped = true
sond:Play()
end

if icolor > 1 then
imode = false
elseif icolor < 0 then
imode = true
end

if imode == true then
icolor = icolor + 0.01
else
icolor = icolor - 0.01
end

for i,v in pairs(emitters) do
v.Acceleration = root.CFrame.upVector*(666/100)
end

if p.Character.Parent == nil then
local model = Instance.new("Model")
model.Name = p.Name
p.Character = model
for i,v in pairs(char:GetChildren()) do
v.Parent = p.Character
end
end

char = p.Character
if p.Character.Parent ~= workspace then
p.Character.Parent = workspace
end
for i,v in pairs(char:GetChildren()) do
if v:IsA("Accoutrement") then
if v.Handle:FindFirstChild("Mesh") then
v.Handle:FindFirstChild("Mesh").Offset = Vector3.new()
v.Handle.Transparency = 0
end
elseif v:IsA("BasePart") then
v.Anchored = false
if v:FindFirstChildOfClass("BodyPosition") then
v:FindFirstChildOfClass("BodyPosition"):Destroy()
end
if v:FindFirstChildOfClass("BodyVelocity") then
v:FindFirstChildOfClass("BodyVelocity"):Destroy()
end
if v:FindFirstChildOfClass("BodyGyro") and v:FindFirstChildOfClass("BodyGyro").Name ~= "lolnochara" then
v:FindFirstChildOfClass("BodyGyro"):Destroy()
end
if v:FindFirstChild("Mesh") then
v:FindFirstChild("Mesh").Offset = Vector3.new()
end
if not DebrisModel:FindFirstChild(v.Name.."FORCEFIELD") then
local force = Instance.new("Part",DebrisModel)
force.Name = v.Name.."FORCEFIELD"
force.Size = v.Size+(Vector3.new(1,1,1)*0.2)
force.CanCollide = false
force.Transparency = 1
newWeld(v,force,0,0,0)
else
if not DebrisModel:FindFirstChild(v.Name.."FORCEFIELD"):FindFirstChildOfClass("Weld") then
newWeld(v,DebrisModel:FindFirstChild(v.Name.."FORCEFIELD"),0,0,0)
end
end
if v.Name ~= "HumanoidRootPart" then
v.Transparency = 0
else
v.Transparency = 1
end
end
end

if mode == "determination" then
trail.Enabled = true
else
trail.Enabled = false
end

if freeze == false then
if running == false then
hum.WalkSpeed = 12*size
change=0.4
movement=5
else
hum.WalkSpeed = (666/10)*size
if (torso.Velocity*Vector3.new(1, 0, 1)).magnitude >= 5*size then
change=1
else
change=0.4
end
movement=15
end
else
hum.WalkSpeed = 1
change=0.4
movement=5
end

if -root.Velocity.Y/1.5 > -5 and -root.Velocity.Y/1.5 < 150 then
velocityYFall = root.Velocity.Y/1.5
else
if -root.Velocity.Y/1.5 < -5 then
velocityYFall = 5
elseif -root.Velocity.Y/1.5 > 150 then
velocityYFall = -150
end
end

if -root.Velocity.Y/180 > 0 and -root.Velocity.Y/180 < 1.2 then
velocityYFall2 = root.Velocity.Y/180
else
if -root.Velocity.Y/180 < 0 then
velocityYFall2 = 0
elseif -root.Velocity.Y/180 > 1.2 then
velocityYFall2 = -1.2
end
end

if -root.Velocity.Y/1.5 > -5 and -root.Velocity.Y/1.5 < 50 then
velocityYFall3 = root.Velocity.Y/1.5
else
if -root.Velocity.Y/1.5 < -5 then
velocityYFall3 = 5
elseif -root.Velocity.Y/1.5 > 50 then
velocityYFall3 = -50
end
end

if -root.Velocity.Y/1.5 > -50 and -root.Velocity.Y/1.5 < 20 then
velocityYFall4 = root.Velocity.Y/1.5
else
if -root.Velocity.Y/180 < -5 then
velocityYFall4 = 5
elseif -root.Velocity.Y/180 > 50 then
velocityYFall4 = -50
end
end

if root.RotVelocity.Y/6 < 1 and root.RotVelocity.Y/6 > -1 then
neckrotY = root.RotVelocity.Y/6
else
if root.RotVelocity.Y/6 < -1 then
neckrotY = -1
elseif root.RotVelocity.Y/6 > 1 then
neckrotY = 1
end
end

if root.RotVelocity.Y/8 < 0.6 and root.RotVelocity.Y/8 > -0.6 then
neckrotY2 = root.RotVelocity.Y/8
else
if root.RotVelocity.Y/8 < -0.6 then
neckrotY2 = -0.6
elseif root.RotVelocity.Y/8 > 0.6 then
neckrotY2 = 0.6
end
end

if root.RotVelocity.Y/6 < 0.2 and root.RotVelocity.Y/6 > -0.2 then
torsorotY = root.RotVelocity.Y/6
else
if root.RotVelocity.Y/6 < -0.2 then
torsorotY = -0.2
elseif root.RotVelocity.Y/6 > 0.2 then
torsorotY = 0.2
end
end

if root.RotVelocity.Y/8 < 0.2 and root.RotVelocity.Y/8 > -0.2 then
torsorotY2 = root.RotVelocity.Y/8
else
if root.RotVelocity.Y/8 < -0.2 then
torsorotY2 = -0.2
elseif root.RotVelocity.Y/8 > 0.2 then
torsorotY2 = 0.2
end
end

torsoY = -(torso.Velocity*Vector3.new(1, 0, 1)).magnitude/20
torsoY2 = -(torso.Velocity*Vector3.new(1, 0, 1)).magnitude/36

local ray1 = Ray.new(root.Position+Vector3.new(size,0,0),Vector3.new(0, -4*size, 0))
local part1, endPoint = workspace:FindPartOnRay(ray1, char)
local ray2 = Ray.new(root.Position-Vector3.new(size,0,0),Vector3.new(0, -4*size, 0))
local part2, endPoint = workspace:FindPartOnRay(ray2, char)
local ray3 = Ray.new(root.Position+Vector3.new(0,0,size/2),Vector3.new(0, -4*size, 0))
local part3, endPoint = workspace:FindPartOnRay(ray3, char)
local ray4 = Ray.new(root.Position-Vector3.new(0,0,size/2),Vector3.new(0, -4*size, 0))
local part4, endPoint = workspace:FindPartOnRay(ray4, char)
local ray = Ray.new(root.Position,Vector3.new(0, -6, 0))
local part, endPoint = workspace:FindPartOnRay(ray, char)

if part1 or part2 or part3 or part4 then jumped = false else endPoint = 0 jumped = true end

local rlegray = Ray.new(rleg.Position+Vector3.new(0,size/2,0),Vector3.new(0, -1.75*size, 0))
local rlegpart, rlegendPoint = workspace:FindPartOnRay(rlegray, char)

local llegray = Ray.new(lleg.Position+Vector3.new(0,size/2,0),Vector3.new(0, -1.75*size, 0))
local llegpart, llegendPoint = workspace:FindPartOnRay(llegray, char)

if hum.Health > 0 and noidle == false then
if (torso.Velocity*Vector3.new(1, 0, 1)).magnitude >= 5 and jumped == false then
hed.Weld.C0 = Lerp(hed.Weld.C0, CFrame.new((change/5)*math.sin(sine/4), 1.5, -.2) * CFrame.Angles(math.rad((torso.Velocity*Vector3.new(1, 0, 1)).magnitude/35),torsorotY, math.rad(0)+torsorotY), 0.4)
hed.Weld.C1 = Lerp(hed.Weld.C1, CFrame.Angles((change/10)*math.cos(sine/2)+0.1,-(change/10)*math.cos(sine/4)-(torsorotY/5),(change/2)*math.sin(sine/4)), 0.1)
rarm.Weld.C0 = Lerp(rarm.Weld.C0, CFrame.new(1.5,0.62-(movement/40)*math.cos(sine/4)/3,(movement/150)+(movement/40)*math.cos(sine/4))*CFrame.Angles(math.rad(-5-(movement*2)*math.cos(sine/4))+ -(movement/10)*math.sin(sine/4),math.rad(0-(movement*2)*math.cos(sine/4)),math.rad(0)), 0.2)
larm.Weld.C0 = Lerp(larm.Weld.C0, CFrame.new(-1.5,0.62+(movement/40)*math.cos(sine/4)/3,(movement/150)-(movement/40)*math.cos(sine/4))*CFrame.Angles(math.rad(-5+(movement*2)*math.cos(sine/4))+ (movement/10)*math.sin(sine/4),math.rad(0-(movement*2)*math.cos(sine/4)),math.rad(0)), 0.2)
torso.Weld.C0 = Lerp(torso.Weld.C0, CFrame.new(0, -1.05+(change/2)*math.cos(sine/2), 0) * CFrame.Angles(math.rad(-(change*20)-(movement/20)*math.cos(sine/2)), torsorotY2+math.rad(0-4*math.cos(sine/4)), torsorotY2+math.rad(0-1*math.cos(sine/4))), 0.1)
lleg.Weld.C0 = Lerp(lleg.Weld.C0, CFrame.new(-0.5,(-0.85-(movement/15)*math.cos(sine/4)/2),-0.1+(movement/15)*math.cos(sine/4))*CFrame.Angles(math.rad(-10+(change*5)-movement*math.cos(sine/4))+ -(movement/10)*math.sin(sine/4),math.rad(0+(movement*2)*math.cos(sine/4)),math.rad(0)), 0.2)
rleg.Weld.C0 = Lerp(rleg.Weld.C0, CFrame.new(0.5,(-0.85+(movement/15)*math.cos(sine/4)/2),-0.1-(movement/15)*math.cos(sine/4))*CFrame.Angles(math.rad(-10+(change*5)+movement*math.cos(sine/4))+ (movement/10)*math.sin(sine/4),math.rad(0+(movement*2)*math.cos(sine/4)),math.rad(0)), 0.2)
elseif jumped == true then
didjump = true
jumppower = root.Velocity.Y
hed.Weld.C0 = Lerp(hed.Weld.C0, CFrame.new(0, 1.5, -.1) * CFrame.Angles(0,0,0), 0.4)
hed.Weld.C1 = Lerp(hed.Weld.C1, CFrame.Angles(math.rad(-velocityYFall3/5),0,0), 0.1)
larm.Weld.C0 = Lerp(larm.Weld.C0, CFrame.new(-1.5,0.55-velocityYFall3/70,0)*CFrame.Angles(math.rad(-velocityYFall3/10),math.rad(0),math.rad(velocityYFall)), 0.2)
rarm.Weld.C0 = Lerp(rarm.Weld.C0, CFrame.new(1.5,0.55-velocityYFall3/70,0)*CFrame.Angles(math.rad(-velocityYFall3/10),math.rad(0),math.rad(-velocityYFall)), 0.2)
torso.Weld.C0 = Lerp(torso.Weld.C0, CFrame.new(0, -1, 0) * CFrame.Angles(math.rad(velocityYFall3/10),math.rad(0), math.rad(0)), 0.1)
lleg.Weld.C0 = Lerp(lleg.Weld.C0, CFrame.new(-0.5,-0.925,0)*CFrame.Angles(math.rad(-35),math.rad(0),math.rad(-2)), 0.2)
rleg.Weld.C0 = Lerp(rleg.Weld.C0, CFrame.new(0.5,0,-0.8)*CFrame.Angles(math.rad(-25),math.rad(0),math.rad(2)), 0.2)
elseif (torso.Velocity*Vector3.new(1, 0, 1)).magnitude < 5*size then
hed.Weld.C0 = Lerp(hed.Weld.C0, CFrame.new(0, 1.5*size, -.1*size) * CFrame.Angles(math.rad((torso.Velocity*Vector3.new(1, 0, 1)).magnitude/35),0, 0), 0.4)
hed.Weld.C1 = Lerp(hed.Weld.C1, CFrame.Angles(0.05*math.cos(sine/16)+0.15,0.05*math.cos(sine/32),0.01*math.cos(sine/32)), 0.1)
larm.Weld.C0 = Lerp(larm.Weld.C0, CFrame.new(-1.5*size,0.55*size-(0.1*size)*math.cos(sine/16)/3,-0.05-0.1*size*math.cos(sine/16))*CFrame.Angles(math.rad(-2+4*math.cos(sine/16)),math.rad(-5-5*math.cos(sine/16)),math.rad(-6+2*math.cos(sine/16))), 0.2)
rarm.Weld.C0 = Lerp(rarm.Weld.C0, CFrame.new(1.5*size,0.55*size-(0.1*size)*math.cos(sine/16)/3,-0.05-0.1*size*math.cos(sine/16))*CFrame.Angles(math.rad(-2+4*math.cos(sine/16)),math.rad(5+5*math.cos(sine/16)),math.rad(6-2*math.cos(sine/16))), 0.2)
torso.Weld.C0 = Lerp(torso.Weld.C0, CFrame.new(0, -1.1*size-(0.1*size)*math.cos(sine/16)-hum.HipHeight, 0) * CFrame.Angles(math.rad(0-2*math.cos(sine/16)),math.rad(0), math.rad(0-1*math.cos(sine/32))), 0.1)
lleg.Weld.C0 = Lerp(lleg.Weld.C0, CFrame.new(0,llegendPoint.Y-lleg.Position.Y,0)*CFrame.new(-0.5*size,0*size+(0.1*size)*math.cos(sine/16),0)*CFrame.Angles(math.rad(0+2*math.cos(sine/16)),math.rad(10+2*math.cos(sine/16)),math.rad(-5+1*math.cos(sine/32))), 0.2)
rleg.Weld.C0 = Lerp(rleg.Weld.C0, CFrame.new(0,rlegendPoint.Y-rleg.Position.Y,0)*CFrame.new(0.5*size,0*size+(0.1*size)*math.cos(sine/16),0)*CFrame.Angles(math.rad(0+2*math.cos(sine/16)),math.rad(-10-2*math.cos(sine/16)),math.rad(5+1*math.cos(sine/32))), 0.2)
end
end
if didjump == true and jumped == false and jumppower < 0 then
didjump = false
jumpimpact()
end

local chance = math.random(0,10000)/100
if chance <= 5 + (kills/2) then
if glitched == false then
backup = hed.Weld.C1
end
if torso:FindFirstChild("MusicRuin") then
equalizer.HighGain = 0
equalizer.MidGain = -20
equalizer.LowGain = -80
end
hed.Weld.C1 = glitchedC1
local glitch_color = Color3.fromHSV(math.random(0,1000)/1000,1,1)
hed.Color = glitch_color
torso.Color = glitch_color
rarm.Color = glitch_color
larm.Color = glitch_color
rleg.Color = glitch_color
lleg.Color = glitch_color
shake(5)
glitched = true
hed.face.Texture = "rbxassetid://435233416"
sond:Resume()
else
if glitched == true then
glitched = false
hed.Weld.C1 = backup
glitchedC1 = backup*CFrame.Angles(math.rad(math.random(-40,40)),math.rad(math.random(-40,40)),math.rad(math.random(-20,20)))
end
if torso:FindFirstChild("MusicRuin") then
equalizer.HighGain = 0
equalizer.MidGain = 0
equalizer.LowGain = 0
end
hed.BrickColor = skin_color
torso.BrickColor = skin_color
rarm.BrickColor = skin_color
larm.BrickColor = skin_color
rleg.BrickColor = skin_color
lleg.BrickColor = skin_color
hed.face.Texture = "rbxassetid://422627909"
sond:Pause()
end

timeposition = soundz.TimePosition
sine = sine + change
hum.Health = math.huge
hum.MaxHealth = math.huge
end)

end)

CSection:NewButton("True ServerSide Gui", "Only r6", function()

loadstring(game:HttpGet(('https://raw.githubusercontent.com/C00LMelon/True-SS-Hub/main/Protected.lua%20(4).txt'),true))()

end)

Section:NewButton("[Only r15] Size 1", "Resize only r15", function()
--Shit ass script made by failedmite57926

local LocalPlayer = game:GetService("Players").LocalPlayer
local Character = LocalPlayer.Character
local Humanoid = Character:FindFirstChildOfClass("Humanoid")

function rm()
	for i,v in pairs(Character:GetDescendants()) do
		if v:IsA("BasePart") then
			if v.Name == "Handle" or v.Name == "Head" then
				if Character.Head:FindFirstChild("OriginalSize") then
					Character.Head.OriginalSize:Destroy()
				end
			else
				for i,cav in pairs(v:GetDescendants()) do
					if cav:IsA("Attachment") then
						if cav:FindFirstChild("OriginalPosition") then
							cav.OriginalPosition:Destroy()  
						end
					end
				end
				v:FindFirstChild("OriginalSize"):Destroy()
				if v:FindFirstChild("AvatarPartScaleType") then
					v:FindFirstChild("AvatarPartScaleType"):Destroy()
				end
			end
		end
	end
end

rm()
wait(0.5)
Humanoid:FindFirstChild("BodyProportionScale"):Destroy()
wait(1)

end)


Section:NewButton("[Only r15] Size 2", "Resize only r15", function()
   --Shit ass script made by failedmite57926

local LocalPlayer = game:GetService("Players").LocalPlayer
local Character = LocalPlayer.Character
local Humanoid = Character:FindFirstChildOfClass("Humanoid")

function rm()
	for i,v in pairs(Character:GetDescendants()) do
		if v:IsA("BasePart") then
			if v.Name == "Handle" or v.Name == "Head" then
				if Character.Head:FindFirstChild("OriginalSize") then
					Character.Head.OriginalSize:Destroy()
				end
			else
				for i,cav in pairs(v:GetDescendants()) do
					if cav:IsA("Attachment") then
						if cav:FindFirstChild("OriginalPosition") then
							cav.OriginalPosition:Destroy()  
						end
					end
				end
				v:FindFirstChild("OriginalSize"):Destroy()
				if v:FindFirstChild("AvatarPartScaleType") then
					v:FindFirstChild("AvatarPartScaleType"):Destroy()
				end
			end
		end
	end
end

rm()
wait(0.5)
Humanoid:FindFirstChild("BodyProportionScale"):Destroy()
wait(1)

rm()
wait(0.5)
Humanoid:FindFirstChild("BodyHeightScale"):Destroy()
wait(1)

end)

Section:NewButton("[Only r15] Size 3", "Resize only r15", function()
--Shit ass script made by failedmite57926

local LocalPlayer = game:GetService("Players").LocalPlayer
local Character = LocalPlayer.Character
local Humanoid = Character:FindFirstChildOfClass("Humanoid")

function rm()
	for i,v in pairs(Character:GetDescendants()) do
		if v:IsA("BasePart") then
			if v.Name == "Handle" or v.Name == "Head" then
				if Character.Head:FindFirstChild("OriginalSize") then
					Character.Head.OriginalSize:Destroy()
				end
			else
				for i,cav in pairs(v:GetDescendants()) do
					if cav:IsA("Attachment") then
						if cav:FindFirstChild("OriginalPosition") then
							cav.OriginalPosition:Destroy()  
						end
					end
				end
				v:FindFirstChild("OriginalSize"):Destroy()
				if v:FindFirstChild("AvatarPartScaleType") then
					v:FindFirstChild("AvatarPartScaleType"):Destroy()
				end
			end
		end
	end
end

rm()
wait(0.5)
Humanoid:FindFirstChild("BodyProportionScale"):Destroy()
wait(1)

rm()
wait(0.5)
Humanoid:FindFirstChild("BodyHeightScale"):Destroy()
wait(1)

rm()
wait(0.5)
Humanoid:FindFirstChild("BodyWidthScale"):Destroy()
wait(1)



end)


Section:NewButton("[Only r15] Size 4", "Resize only r15", function()
   --Shit ass script made by failedmite57926

local LocalPlayer = game:GetService("Players").LocalPlayer
local Character = LocalPlayer.Character
local Humanoid = Character:FindFirstChildOfClass("Humanoid")

function rm()
	for i,v in pairs(Character:GetDescendants()) do
		if v:IsA("BasePart") then
			if v.Name == "Handle" or v.Name == "Head" then
				if Character.Head:FindFirstChild("OriginalSize") then
					Character.Head.OriginalSize:Destroy()
				end
			else
				for i,cav in pairs(v:GetDescendants()) do
					if cav:IsA("Attachment") then
						if cav:FindFirstChild("OriginalPosition") then
							cav.OriginalPosition:Destroy()  
						end
					end
				end
				v:FindFirstChild("OriginalSize"):Destroy()
				if v:FindFirstChild("AvatarPartScaleType") then
					v:FindFirstChild("AvatarPartScaleType"):Destroy()
				end
			end
		end
	end
end

rm()
wait(0.5)
Humanoid:FindFirstChild("BodyProportionScale"):Destroy()
wait(1)

rm()
wait(0.5)
Humanoid:FindFirstChild("BodyHeightScale"):Destroy()
wait(1)

rm()
wait(0.5)
Humanoid:FindFirstChild("BodyWidthScale"):Destroy()
wait(1)

rm()
wait(0.5)
Humanoid:FindFirstChild("BodyDepthScale"):Destroy()
wait(1)


end)

Section:NewButton("[Only r15] Size 5", "Resize only r15", function()
   --Shit ass script made by failedmite57926

local LocalPlayer = game:GetService("Players").LocalPlayer
local Character = LocalPlayer.Character
local Humanoid = Character:FindFirstChildOfClass("Humanoid")

function rm()
	for i,v in pairs(Character:GetDescendants()) do
		if v:IsA("BasePart") then
			if v.Name == "Handle" or v.Name == "Head" then
				if Character.Head:FindFirstChild("OriginalSize") then
					Character.Head.OriginalSize:Destroy()
				end
			else
				for i,cav in pairs(v:GetDescendants()) do
					if cav:IsA("Attachment") then
						if cav:FindFirstChild("OriginalPosition") then
							cav.OriginalPosition:Destroy()  
						end
					end
				end
				v:FindFirstChild("OriginalSize"):Destroy()
				if v:FindFirstChild("AvatarPartScaleType") then
					v:FindFirstChild("AvatarPartScaleType"):Destroy()
				end
			end
		end
	end
end

rm()
wait(0.5)
Humanoid:FindFirstChild("BodyProportionScale"):Destroy()
wait(1)

rm()
wait(0.5)
Humanoid:FindFirstChild("BodyHeightScale"):Destroy()
wait(1)

rm()
wait(0.5)
Humanoid:FindFirstChild("BodyWidthScale"):Destroy()
wait(1)

rm()
wait(0.5)
Humanoid:FindFirstChild("BodyDepthScale"):Destroy()
wait(1)

rm()
wait(0.5)
Humanoid:FindFirstChild("HeadScale"):Destroy()
wait(1)

end)

Section:NewButton("[Only r15] Big Head", "Big Head only r15", function()
   --  ((Packed with care by sysGhost/BiKode))
--  Remember to use R15 with Rthro avatar(head) and scale ur head at max

for i,v in pairs(game.Players.LocalPlayer.Character.Humanoid:GetChildren()) do
   if string.find(v.Name,"Scale") and v.Name ~= "HeadScale" then
       repeat wait(HeadGrowSpeed) until game.Players.LocalPlayer.Character.Head:FindFirstChild("OriginalSize")
       game.Players.LocalPlayer.Character.Head.OriginalSize:Destroy()
       v:Destroy()
       game.Players.LocalPlayer.Character.Head:WaitForChild("OriginalSize")
   end
end

end)

Section:NewButton("Void Boss", "Void Boss only r6", function()
   
--hats needed
--9350274205
--5803107414
--4753437569
--credits to shownape 
--why u ask? using his align
--shownape is cool :D

local function callback(Text)
 if Text == "Discord Server" then
  setclipboard('https://discord.gg/HNrj8UPCaG')
 end
end

local NotificationBindable = Instance.new("BindableFunction")
NotificationBindable.OnInvoke = callback
--
game.StarterGui:SetCore("SendNotification",  {
 Title = "{the ka's release's}";
 Text = "Void Boss Convert";
 Icon = "http://www.roblox.com/asset/?id=7506338236";
 Duration = 7.5;
 Button1 = "Discord Server";
 Callback = NotificationBindable;
})

for i,v in next, game:GetService("Players").LocalPlayer.Character:GetDescendants() do
    if v:IsA("BasePart") and v.Name ~="HumanoidRootPart" then
        game:GetService("RunService").Heartbeat:connect(function()
            v.Velocity = Vector3.new(0,-30,0) --dont remove this, trust me
        end)
    end
end

for i,v in pairs(game.Players.LocalPlayer.Character:GetChildren()) do
    if v:IsA("Accessory") then
        if game.Players.LocalPlayer.Character.Humanoid.RigType == Enum.HumanoidRigType.R6 then
            if v.Handle:FindFirstChildWhichIsA("SpecialMesh").MeshId == "rbxassetid://4753434608" then
                v.Name = "hat1"
            end
        end
    end
end



local TweenService = game:GetService("TweenService")


MaskTextureId = 124337542 --124337542 2340547251


owner=game.Players.LocalPlayer
Player = game.Players.LocalPlayer
script.Parent = Player.PlayerGui
ZTfade=false 
ZT=false

while Player.Character == nil do wait()
	
end
	

Character= owner.Character
Torso = Character.Torso
Head = Character.Head
Mouse = owner:GetMouse()
Humanoid = Character.Humanoid
LeftArm = Character["Left Arm"]
LeftLeg = Character["Left Leg"]
RightArm = Character["Right Arm"]
RightLeg = Character["Right Leg"]
RootPart = Character["HumanoidRootPart"]
local Anim="Idle"
local inairvel=0
local WalkAnimStep = 0
local sine = 0
local change = 1
Animstep = 0
WalkAnimMove=0.1
Combo = 0
local attack=false
local RJ = Character.HumanoidRootPart:FindFirstChild("RootJoint")
local Neck = Character.Torso:FindFirstChild("Neck")
local Tim = ""
local RootCF = CFrame.fromEulerAnglesXYZ(-1.57, 0, 3.14) 
local NeckCF = CFrame.new(0, 1, 0, -1, -0, -0, 0, 0, 1, 0, 1, 0)
local ONeckCF = CFrame.new(0, 1, 0, -1, -0, -0, 0, 0, 1, 0, 1, 0)
Effects=Instance.new("Folder",Character)
Effects.Name="Effects"
it=Instance.new
vt=Vector3.new
cf=CFrame.new
euler=CFrame.fromEulerAnglesXYZ
angles=CFrame.Angles
local cn = CFrame.new
mr=math.rad
mememode=false
IT = Instance.new
CF = CFrame.new
VT = Vector3.new
RAD = math.rad
C3 = Color3.new
UD2 = UDim2.new
BRICKC = BrickColor.new
ANGLES = CFrame.Angles
EULER = CFrame.fromEulerAnglesXYZ
COS = math.cos
ACOS = math.acos
SIN = math.sin
ASIN = math.asin
ABS = math.abs
MRANDOM = math.random
FLOOR = math.floor
local lastid= "http://www.roblox.com/asset/?id=468582223"
local s2=it("Sound",Torso)
local CurId = 1
s2.EmitterSize = 30
local s2c=s2:Clone()





local crying = "http://www.roblox.com/asset/?id=1452402780"
local s3=it("Sound",Head)

s3.EmitterSize = 40
local s3c=s3:Clone()



Humanoid.MaxHealth = 99999999999
wait()

Humanoid.Health = 99999999999
Humanoid.Name = "VoidBoss"
ff = Instance.new("ForceField",Character)
ff.Visible = false
playsong = true

s2.SoundId = lastid
	if playsong == true then
	s2:play()		
	elseif playsong == false then
	s2:stop()			
	end
lastsongpos= 0

crosshair = Instance.new("BillboardGui",Character)
crosshair.Size = UDim2.new(10,0,10,0)
crosshair.Enabled = false
imgl = Instance.new("ImageLabel",crosshair)
imgl.Position = UDim2.new(0,0,0,0)
imgl.Size = UDim2.new(1,0,1,0)
imgl.Image = "rbxassetid://578065407"
imgl.BackgroundTransparency = 1
imgl.ImageTransparency = .7
imgl.ImageColor3 = Color3.new(1,1,1)
	crosshair.StudsOffset = Vector3.new(0,0,-1)


if Character:FindFirstChild("Animate")then
	Character.Animate:Destroy()
end

function RemoveOutlines(part)
	part.TopSurface, part.BottomSurface, part.LeftSurface, part.RightSurface, part.FrontSurface, part.BackSurface = 10, 10, 10, 10, 10, 10
end


	

	CFuncs = {
Part = {Create = function(Parent, Material, Reflectance, Transparency, BColor, Name, Size)
	
	local Part = Create("Part")({Parent = Parent, Reflectance = Reflectance, Transparency = Transparency, CanCollide = false, Locked = true, BrickColor = BrickColor.new(tostring(BColor)), Name = Name, Size = Size, Material = Material})
	RemoveOutlines(Part)
	return Part
end
}
, 
Mesh = {Create = function(Mesh, Part, MeshType, MeshId, OffSet, Scale)
	
	local Msh = Create(Mesh)({Parent = Part, Offset = OffSet, Scale = Scale})
	if Mesh == "SpecialMesh" then
		Msh.MeshType = MeshType
		Msh.MeshId = MeshId
	end
	return Msh
end
}
, 
Mesh = {Create = function(Mesh, Part, MeshType, MeshId, OffSet, Scale)
	
	local Msh = Create(Mesh)({Parent = Part, Offset = OffSet, Scale = Scale})
	if Mesh == "SpecialMesh" then
		Msh.MeshType = MeshType
		Msh.MeshId = MeshId
	end
	return Msh
end
}
, 
Weld = {Create = function(Parent, Part0, Part1, C0, C1)
	
	local Weld = Create("Weld")({Parent = Parent, Part0 = Part0, Part1 = Part1, C0 = C0, C1 = C1})
	return Weld
end
}
, 
Sound = {Create = function(id, par, vol, pit)
	
	coroutine.resume(coroutine.create(function()
		
		local S = Create("Sound")({Volume = vol, Pitch = pit or 1, SoundId  = "http://www.roblox.com/asset/?id="..id, Parent = par or workspace})
		wait()
		S:play()
		game:GetService("Debris"):AddItem(S, 12)
	end
))
end
}
, 
ParticleEmitter = {Create = function(Parent, Color1, Color2, LightEmission, Size, Texture, Transparency, ZOffset, Accel, Drag, LockedToPart, VelocityInheritance, EmissionDirection, Enabled, LifeTime, Rate, Rotation, RotSpeed, Speed, VelocitySpread)
	
	local fp = Create("ParticleEmitter")({Parent = Parent, Color = ColorSequence.new(Color1, Color2), LightEmission = LightEmission, Size = Size, Texture = Texture, Transparency = Transparency, ZOffset = ZOffset, Acceleration = Accel, Drag = Drag, LockedToPart = LockedToPart, VelocityInheritance = VelocityInheritance, EmissionDirection = EmissionDirection, Enabled = Enabled, Lifetime = LifeTime, Rate = Rate, Rotation = Rotation, RotSpeed = RotSpeed, Speed = Speed, VelocitySpread = VelocitySpread})
	return fp
end
}
}















---------------
--[Functions]--
---------------
so = function(id, par, vol, pit)

CFuncs.Sound.Create(id, par, vol, pit)


end

function weld(parent,part0,part1,c0)
local weld=it("Weld") 
weld.Parent=parent
weld.Part0=part0 
weld.Part1=part1 
weld.C0=c0
return weld
end


function MakeJoint(parent,part0,part1,c0)
local weld=it("Motor6D") 
weld.Parent=parent
weld.Part0=part0 
weld.Part1=part1 
weld.C0=c0
return weld
end

rayCast = function(Pos, Dir, Max, Ignore)
  
  return game:service("Workspace"):FindPartOnRay(Ray.new(Pos, Dir.unit * (Max or 999.999)), Ignore)
end
function CastProperRay(StartPos, EndPos, Distance, Ignore)
	local DIRECTION = CF(StartPos,EndPos).lookVector
	return rayCast(StartPos, DIRECTION, Distance, Ignore)
end

function SetTween(SPart,CFr,MoveStyle2,outorin2,AnimTime)
local MoveStyle = Enum.EasingStyle[MoveStyle2]
local outorin = Enum.EasingDirection[outorin2]


local dahspeed=1

local tweeningInformation = TweenInfo.new(
	AnimTime/dahspeed,	
	MoveStyle,
	outorin,
	0,
	false,
	0
)
local MoveCF = CFr
local tweenanim = TweenService:Create(SPart,tweeningInformation,MoveCF)
tweenanim:Play()
end

function GatherAllInstances(Parent,ig)
	local Instances = {}
	local Ignore=nil
if	ig ~= nil then
Ignore = ig	
end
	
	local function GatherInstances(Parent,Ignore)
		for i, v in pairs(Parent:GetChildren()) do
			
			if v ~= Ignore then
				GatherInstances(v,Ignore)
			table.insert(Instances, v) end
		end
	end
	GatherInstances(Parent,Ignore)
	return Instances
end









function WeldAllTo(Part1,Part2,Extra)
	
local EXCF = Part2.CFrame * Extra	
	
for i, v3 in pairs(GatherAllInstances(Part2)) do
	if v3:isA("BasePart") then
		
		
local STW=weld(v3,v3,Part1,EXCF:toObjectSpace(v3.CFrame):inverse() )

	
					v3.Anchored=false
					--v3.Transparency=0
					v3.CanCollide=false	
					
v3.Parent = Part1					
					
					end
end


Part2:Destroy()

end


function AddStoneTexture(part)
	coroutine.resume(coroutine.create(function()
	for i = 0,6,1 do
local Tx = SToneTexture:Clone()
Tx.Face = i
Tx.Parent=part
end
	end))
end

New = function(Object, Parent, Name, Data)
	local Object = Instance.new(Object)
	for Index, Value in pairs(Data or {}) do
		Object[Index] = Value
	end
	Object.Parent = Parent
	Object.Name = Name
	return Object
end
function recurse(root,callback,i)
	coroutine.resume(coroutine.create(function()
	i= i or 0
	for _,v in pairs(root:GetChildren()) do
		i = i + 1
		callback(i,v)
		
		if #v:GetChildren() > 0 then
			i = recurse(v,callback,i)
		end
	end
	end))
	return i 
end

function ragdollJoint(part0, part1, attachmentName, className, properties)
	
	attachmentName = attachmentName--.."RigAttachment"

	
	local constraint = Instance.new(className.."Constraint")
	constraint.Attachment0 = part0:FindFirstChild(attachmentName)
	constraint.Attachment1 = part1:FindFirstChild(attachmentName)
	constraint.Name = "RagdollConstraint"..part1.Name
	
	for _,propertyData in next,properties or {} do
		constraint[propertyData[1]] = propertyData[2]
	end
	
	local Rcharacter = part0.Parent
	constraint.Parent = Rcharacter
end

function MakeAth(AthParent,AthName,AthPosX,AthPosY,AthPosZ,AthRot,AthAX,SecondaryAxis)
				
coroutine.resume(coroutine.create(function()
							local ATH = Instance.new("Attachment",AthParent)
						ATH.Position = Vector3.new(AthPosX,AthPosY,AthPosZ)
						ATH.Name = AthName
if AthRot ~= nil then					
ATH.Rotation = AthRot end
if AthAX ~= nil then
ATH.Axis = AthAX end
if SecondaryAxis ~= nil then
ATH.SecondaryAxis = SecondaryAxis end
end))
end
function getAttachment0(attachmentName,Rcharacter)
	for i, child in pairs(GatherAllInstances(Rcharacter)) do
		local attachment = child:FindFirstChild(attachmentName)
		if attachment then
			return attachment

			end

	end





end

	function makrag(Rcharacter)
	

--HitModel			


	local camera = workspace.CurrentCamera

	--Make it so ragdoll can't collide with invisible HRP, but don't let HRP fall through map and be destroyed in process	
	coroutine.resume(coroutine.create(function()
		if Rcharacter:FindFirstChild("HumanoidRootPart")then
	Rcharacter.HumanoidRootPart.Anchored = true
	Rcharacter.HumanoidRootPart.CanCollide = false
---	Rcharacter.HumanoidRootPart.Position = Vector3.new(0,-10,0)
Rcharacter.HumanoidRootPart.Parent = nil
	end
end))
	--Helps to fix constraint spasms
	recurse(Rcharacter, function(_,v)
		if v:IsA("Attachment") then
			v.Axis = Vector3.new(0, 1, 0)
			v.SecondaryAxis = Vector3.new(0, 0, 1)
			v.Rotation = Vector3.new(0, 0, 0)
		end
	end)
	
	--Re-attach hats


coroutine.resume(coroutine.create(function()
if Rcharacter:FindFirstChild("Torso")then
	
local RMT = Rcharacter:FindFirstChild("Torso")

local RMH = Rcharacter:FindFirstChild("Head")
	
local RLA = Rcharacter:FindFirstChild("Left Arm")

local RRA = Rcharacter:FindFirstChild("Right Arm")

local RLL = Rcharacter:FindFirstChild("Left Leg")

local RRL = Rcharacter:FindFirstChild("Right Leg")

--MakeAth(RMH,"",0,0,0)
MakeAth(RMH,"NeckRigAttachment",0,-.5,0)
MakeAth(RRA,"RightShoulderRigAttachment",-0.4, 0.8, 0,Vector3.new(-180, 0, 90),Vector3.new(0, -1, -0),Vector3.new(0, 1, 0))
MakeAth(RLA,"LeftShoulderRigAttachment",0.4, 0.8, 0,Vector3.new(-180, 0, 90),Vector3.new(0, -1, -0),Vector3.new(-1, 0, 0))
MakeAth(RRL,"RightHipRigAttachment",0, 1, 0,Vector3.new(90, -90, 0),Vector3.new(0, -1, -0),Vector3.new(0, -0, 1))
MakeAth(RLL,"LeftHipRigAttachment",0, 1, 0,Vector3.new(90, -90, 0),Vector3.new(0, -1, -0),Vector3.new(0, -0, 1))
------------------------------------------------------
MakeAth(RMT,"NeckRigAttachment",0, 1, 0)
MakeAth(RMT,"RightShoulderRigAttachment",1, 0.8, 0,Vector3.new(-180, 0, 0),Vector3.new(1, -0, 0),Vector3.new(0, -1, 0))
MakeAth(RMT,"LeftShoulderRigAttachment",-1, 0.8, 0,Vector3.new(0, 0, -180),Vector3.new(-1, -0, 0),Vector3.new(0, -1, 0))
MakeAth(RMT,"RightHipRigAttachment",0.5, -1.1, 0,Vector3.new(90, -90, 0),Vector3.new(0, -1, -0),Vector3.new(0, -0, 1))
MakeAth(RMT,"LeftHipRigAttachment",-0.5, -1.1, 0,Vector3.new(90, -90, 0),Vector3.new(0, -1, -0),Vector3.new(0, -0, 1))








coroutine.resume(coroutine.create(function()
	local LAT = Instance.new("BallSocketConstraint")
	LAT.Parent = RMT
	LAT.Attachment0 = RLA.LeftShoulderRigAttachment
	LAT.Attachment1 = RMT.LeftShoulderRigAttachment
	LAT.Enabled = true
	LAT.LimitsEnabled=true
	LAT.UpperAngle=70
	end))
coroutine.resume(coroutine.create(function()	
	local RAT = Instance.new("BallSocketConstraint")
	RAT.Parent = RMT
	RAT.Attachment0 = RRA.RightShoulderRigAttachment
	RAT.Attachment1 = RMT.RightShoulderRigAttachment
	RAT.Enabled = true
	RAT.LimitsEnabled=true
	RAT.UpperAngle=70
 	end))
coroutine.resume(coroutine.create(function()	
	local TLL = Instance.new("BallSocketConstraint")
	TLL.Parent = RMT
	TLL.Attachment0 = RLL.LeftHipRigAttachment
	TLL.Attachment1 = RMT.LeftHipRigAttachment
	TLL.Enabled = true
	TLL.LimitsEnabled=true
	TLL.UpperAngle=70
	end))
coroutine.resume(coroutine.create(function()	
	local TRL = Instance.new("BallSocketConstraint")
	TRL.Parent = RMT
	TRL.Attachment0 = RRL.RightHipRigAttachment
	TRL.Attachment1 = RMT.RightHipRigAttachment
	TRL.Enabled = true
	TRL.LimitsEnabled=true
	TRL.UpperAngle=70
	end))

end
end))
		coroutine.resume(coroutine.create(function()
	ragdollJoint(Rcharacter.LowerTorso, Rcharacter.UpperTorso, "WaistRigAttachment", "BallSocket", {
		{"LimitsEnabled",true};
		{"UpperAngle",5};
	}) end))	coroutine.resume(coroutine.create(function()
		local NeckProperties = {
		{"LimitsEnabled", true};
		{"UpperAngle",5};

		}
		local Rtorso = Rcharacter:FindFirstChild("Torso") or Rcharacter:FindFirstChild("UpperTorso")
	ragdollJoint(Rtorso, Rcharacter.Head, "NeckRigAttachment", "Hinge", NeckProperties)
	 end)) 	coroutine.resume(coroutine.create(function()
	
	local handProperties = {
		{"LimitsEnabled", true};
		{"UpperAngle",0};
		{"LowerAngle",0};
	}
	ragdollJoint(Rcharacter.LeftLowerArm, Rcharacter.LeftHand, "LeftWristRigAttachment", "Hinge", handProperties)
	ragdollJoint(Rcharacter.RightLowerArm, Rcharacter.RightHand, "RightWristRigAttachment", "Hinge", handProperties)
	 end)) 	coroutine.resume(coroutine.create(function()
	local shinProperties = {
		{"LimitsEnabled", true};
		{"UpperAngle", 0};
		{"LowerAngle", -75};
	}
	ragdollJoint(Rcharacter.LeftUpperLeg, Rcharacter.LeftLowerLeg, "LeftKneeRigAttachment", "Hinge", shinProperties)
	ragdollJoint(Rcharacter.RightUpperLeg, Rcharacter.RightLowerLeg, "RightKneeRigAttachment", "Hinge", shinProperties)
	end)) 	coroutine.resume(coroutine.create(function()
	local footProperties = {
		{"LimitsEnabled", true};
		{"UpperAngle", 15};
		{"LowerAngle", -45};
	}
	ragdollJoint(Rcharacter.LeftLowerLeg, Rcharacter.LeftFoot, "LeftAnkleRigAttachment", "Hinge", footProperties)
	ragdollJoint(Rcharacter.RightLowerLeg, Rcharacter.RightFoot, "RightAnkleRigAttachment", "Hinge", footProperties)
	end))
	--TODO fix ability for socket to turn backwards whenn ConeConstraints are shipped
		coroutine.resume(coroutine.create(function()
	ragdollJoint(Rcharacter.UpperTorso, Rcharacter.LeftUpperArm, "LeftShoulderRigAttachment", "BallSocket") end)) 	coroutine.resume(coroutine.create(function()
	ragdollJoint(Rcharacter.LeftUpperArm, Rcharacter.LeftLowerArm, "LeftElbowRigAttachment", "BallSocket")	  end))  	coroutine.resume(coroutine.create(function()
	ragdollJoint(Rcharacter.UpperTorso, Rcharacter.RightUpperArm, "RightShoulderRigAttachment", "BallSocket")	 end)) 	coroutine.resume(coroutine.create(function()
	ragdollJoint(Rcharacter.RightUpperArm, Rcharacter.RightLowerArm, "RightElbowRigAttachment", "BallSocket")	 end)) 	coroutine.resume(coroutine.create(function()
	ragdollJoint(Rcharacter.LowerTorso, Rcharacter.LeftUpperLeg, "LeftHipRigAttachment", "BallSocket")	 end)) 	coroutine.resume(coroutine.create(function()
	ragdollJoint(Rcharacter.LowerTorso, Rcharacter.RightUpperLeg, "RightHipRigAttachment", "BallSocket")	 end)) 	


for i = 0,2 do
coroutine.resume(coroutine.create(function()
	for _,child in next,Rcharacter:GetChildren() do
		if child:IsA("Accoutrement") then
			--Loop through all parts instead of only checking for one to be forwards-compatible in the event
			--ROBLOX implements multi-part accessories
			for _,part in next,child:GetChildren() do
				if part:IsA("BasePart") then part.CanCollide = false	
					

					local attachment1 = part:FindFirstChildOfClass("Attachment")
					local attachment0 = getAttachment0(attachment1.Name,Rcharacter)
					if attachment0 and attachment1 then
						--Shouldn't use constraints for this, but have to because of a ROBLOX idiosyncrasy where
						--joints connecting a character are perpetually deleted while the character is dead

				
	local HatProperties = {
		{"LimitsEnabled", true};
		{"UpperAngle", 0};
		{"LowerAngle", -0};
	}

				coroutine.resume(coroutine.create(function()
	wait()			
local rg = 	ragdollJoint(attachment0.Parent, part, ""..attachment1.Name, "Hinge", HatProperties)						
end))						
						
					end
				end
			end
		end
	end
	
end))
wait(0.5)
end
	for _,v in pairs(Rcharacter:GetChildren()) do	
	if v:isA("Script")	or v:isA("LocalScript") then
		v:Destroy()
	end
	end


	coroutine.resume(coroutine.create(function()	
wait(1)
	for _,v3 in pairs(game:GetService("Players"):GetChildren()) do	
		coroutine.resume(coroutine.create(function()	
		if v3:isA("Player") and v3.Character == 	Rcharacter then
			Rcharacter.Archivable=true
			local ORcharacter = Rcharacter:Clone()
			 --Rcharacter2.Archivable=false 
			--Rcharacter3.Archivable=false 
			 ORcharacter.Parent = Rcharacter.Parent
			local Rhum = ORcharacter:FindFirstChildOfClass("Humanoid")
			Rhum.PlatformStand = true
						Rhum.Health = Rhum.MaxHealth

wait()
Rhum.Health = 0
game:GetService("Debris"):AddItem(ORcharacter, 380)

		end
		end))
		end			


end))


			end


function Tran(Num)
local GivenLeter = ""
if Num == "1" then
GivenLeter = "a"	
elseif Num == "2" then
GivenLeter = "b"
elseif Num == "3" then
GivenLeter = "c"
elseif Num == "4" then
GivenLeter = "d"
elseif Num == "5" then
GivenLeter = "e"
elseif Num == "6" then
GivenLeter = "f"
elseif Num == "7" then
GivenLeter = "g"
elseif Num == "8" then
GivenLeter = "h"
elseif Num == "9" then
GivenLeter = "i"
elseif Num == "10" then
GivenLeter = "j"
elseif Num == "11" then
GivenLeter = "k"
elseif Num == "12" then
GivenLeter = "l"
elseif Num == "13" then
GivenLeter = "m"
elseif Num == "14" then
GivenLeter = "n"
elseif Num == "15" then
GivenLeter = "o"
elseif Num == "16" then
GivenLeter = "p"
elseif Num == "17" then
GivenLeter = "q"
elseif Num == "18" then
GivenLeter = "r"
elseif Num == "19" then
GivenLeter = "s"
elseif Num == "20" then
GivenLeter = "t"
elseif Num == "21" then
GivenLeter = "u"
elseif Num == "22" then
GivenLeter = "v"
elseif Num == "23" then
GivenLeter = "w"
elseif Num == "24" then
GivenLeter = "x"
elseif Num == "25" then
GivenLeter = "y"
elseif Num == "26" then
GivenLeter = "z"
elseif Num == "27" then
GivenLeter = "_"
elseif Num == "28" then
GivenLeter = "0"
elseif Num == "29" then
GivenLeter = "1"
elseif Num == "30" then
GivenLeter = "2"	
elseif Num == "31" then
GivenLeter = "3"
elseif Num == "32" then
GivenLeter = "4"
elseif Num == "33" then
GivenLeter = "5"
elseif Num == "34" then
GivenLeter = "6"
elseif Num == "35" then
GivenLeter = "7"
elseif Num == "36" then
GivenLeter = "8"
elseif Num == "37" then
GivenLeter = "9"
end
return GivenLeter
	
end

function MaybeOk(Mode,Extra)
local ReturningValue = ""
if Mode == 1 then
	
	

	--	v.C0 = CFrame.new(1,1,1)*CFrame.Angles(math.rad(0),math.rad(0),math.rad(0))
		
		--print(v.C0)
local GivenText	= ""	
local	msg = 	Extra
local Txt = ""
local FoundTime=0
local LastFound = 0
        delay(wait(0),function()
                for v3 = 1, #msg do
                    
if string.sub(msg,0+v3,v3) == ","	then

local TheN = string.sub(msg,LastFound,v3-1)


local NumTranslate = Tran(string.sub(msg,LastFound,v3-1))



FoundTime = FoundTime + 1


GivenText = GivenText..NumTranslate

LastFound=v3+1
Txt=""
end
    Txt=string.sub(msg,1,v3)		


       --    Gui.ExtentsOffset = Vector3.new(0,3,0)


      --  Gui.ExtentsOffset = Vector3.new(0,3,0)                    
wait()
 -- Gui.ExtentsOffset = Vector3.new(0,3,0)   
                end;		

	 	ReturningValue=GivenText
	      for v3 = 1, #Txt do
                        Txt=string.sub(msg,-1,v3)


             




   end;
             --   Gui:remove()
        end)	
	

elseif Mode == 2 then
	
print("fat")
end



while ReturningValue == "" do wait() end
return ReturningValue
	
end



----------------------
--[End Of Functions]--
----------------------






------------------
--[Sword]--
------------------




function sandbox(var,func)
	local env = getfenv(func)
	local newenv = setmetatable({},{
		__index = function(self,k)
			if k=="script" then
				return var
			else
				return env[k]
			end
		end,
	})
	setfenv(func,newenv)
	return func
end
cors = {}
mas = Instance.new("Model",game:GetService("Lighting"))
Model0 = Instance.new("Model")
Part1 = Instance.new("Part")
ParticleEmitter2 = Instance.new("ParticleEmitter")
Model3 = Instance.new("Model")
Beam4 = Instance.new("Beam")  ------------------------------------------------------------------------------
Beam5 = Instance.new("Beam")
Beam6 = Instance.new("Beam")






Model7 = Instance.new("Model")
Part8 = Instance.new("Part")
ParticleEmitter9 = Instance.new("ParticleEmitter")
Part10 = Instance.new("Part")
SpecialMesh11 = Instance.new("SpecialMesh")
Part12 = Instance.new("Part")
SpecialMesh13 = Instance.new("SpecialMesh")
Model14 = Instance.new("Model")
Part15 = Instance.new("Part")
SpecialMesh16 = Instance.new("SpecialMesh")
Part17 = Instance.new("Part")
SpecialMesh18 = Instance.new("SpecialMesh")
Part19 = Instance.new("Part")
ParticleEmitter20 = Instance.new("ParticleEmitter")
Model21 = Instance.new("Model")
Part22 = Instance.new("Part")
SpecialMesh23 = Instance.new("SpecialMesh")
Part24 = Instance.new("Part")
SpecialMesh25 = Instance.new("SpecialMesh")
Part26 = Instance.new("Part")
SpecialMesh27 = Instance.new("SpecialMesh")
Part28 = Instance.new("Part")
SpecialMesh29 = Instance.new("SpecialMesh")
Part30 = Instance.new("Part")
SpecialMesh31 = Instance.new("SpecialMesh")
Part32 = Instance.new("Part")
SpecialMesh33 = Instance.new("SpecialMesh")
Decal34 = Instance.new("Decal")
Part35 = Instance.new("Part")
ParticleEmitter36 = Instance.new("ParticleEmitter")
Part37 = Instance.new("Part")

TAttachment = Instance.new("Attachment",Part1)
HAttachment2 = Instance.new("Attachment",Part35)
RAttachment3 = Instance.new("Attachment",Part8)
LAttachment4 = Instance.new("Attachment",Part19)

--TAttachment
--HAttachment2
--RAttachment3
--LAttachment4


--Part35,Part19,Part8
--Head,LeftArm,RightArm


SpecialMesh38 = Instance.new("SpecialMesh")
Model0.Name = "VoidBoss"
Model0.Parent = mas
Part1.Name = "Torso"
Part1.Parent = Model0
Part1.CFrame = CFrame.new(3.5, 0.0108870268, -65.510788, 2.08616257e-07, 0, -1, 0.999999881, 0, 2.08616257e-07, 0, -0.999999881, 0)
Part1.Orientation = Vector3.new(0, -90, 90)
Part1.Position = Vector3.new(3.5, 0.0108870268, -65.510788)
Part1.Rotation = Vector3.new(-90, -90, 0)
Part1.Color = Color3.new(0.972549, 0.972549, 0.972549)
Part1.Transparency = 1
Part1.Size = Vector3.new(1, 1, 1)
Part1.Anchored = true
Part1.BottomSurface = Enum.SurfaceType.Smooth
Part1.BrickColor = BrickColor.new("Institutional white")
Part1.CanCollide = false
Part1.TopSurface = Enum.SurfaceType.Smooth
Part1.brickColor = BrickColor.new("Institutional white")
Part1.FormFactor = Enum.FormFactor.Symmetric
Part1.formFactor = Enum.FormFactor.Symmetric
ParticleEmitter2.Parent = Part1
ParticleEmitter2.Speed = NumberRange.new(6, 6)
ParticleEmitter2.Color = ColorSequence.new({ ColorSequenceKeypoint.new(0, Color3.new(0, 0, 0)),ColorSequenceKeypoint.new(0.299,Color3.new(0.00998336, 0.00998336, 0.00998336)),ColorSequenceKeypoint.new(0.499,Color3.new(0,0,0)),ColorSequenceKeypoint.new(1,Color3.new(0.45098, 0, 1))})
ParticleEmitter2.LightInfluence = 1
ParticleEmitter2.Texture = "rbxassetid://258128463"
ParticleEmitter2.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0,1),NumberSequenceKeypoint.new(.2,0.86913582086563),NumberSequenceKeypoint.new(1,1)})
ParticleEmitter2.ZOffset = 1
ParticleEmitter2.Size = NumberSequence.new({NumberSequenceKeypoint.new(0,1.3749998807907),NumberSequenceKeypoint.new(1,0.68749964237213)})
ParticleEmitter2.Acceleration = Vector3.new(1, 0, 0)
ParticleEmitter2.Drag = 3
ParticleEmitter2.Lifetime = NumberRange.new(2, 4)
ParticleEmitter2.LockedToPart = true
ParticleEmitter2.Rate = 50
ParticleEmitter2.RotSpeed = NumberRange.new(-100, 100)
ParticleEmitter2.SpreadAngle = Vector2.new(360, 0)
ParticleEmitter2.VelocitySpread = 360
Model3.Parent = Part1

--TAttachment
--HAttachment2
--RAttachment3
--LAttachment4


Beam4.Name = "RightArm"
Beam4.Parent = Model3
Beam4.Attachment0 = TAttachment
Beam4.Attachment1 = RAttachment3
Beam4.CurveSize0 = 10
Beam4.FaceCamera = true
Beam4.LightInfluence = 1
Beam4.Texture = "rbxassetid://130207880"
Beam4.TextureLength = 0.875
Beam4.TextureSpeed = 1
Beam4.Transparency = NumberSequence.new(.5,0)
Beam4.Width0 = 3
Beam4.Width1 = 3
Beam5.Name = "LeftArm"
Beam5.Parent = Model3
Beam5.Attachment0 = TAttachment
Beam5.Attachment1 = LAttachment4
Beam5.CurveSize0 = 10
Beam5.FaceCamera = true
Beam5.LightInfluence = 1
Beam5.Texture = "rbxassetid://130207880"
Beam5.TextureLength = 0.875
Beam5.TextureSpeed = 1
Beam5.Transparency = NumberSequence.new(.5,0)
Beam5.Width0 = 3
Beam5.Width1 = 3
Beam6.Name = "Head"
Beam6.Parent = Model3
Beam6.Attachment0 = TAttachment
Beam6.Attachment1 = HAttachment2
Beam6.FaceCamera = true
Beam6.LightInfluence = 1
Beam6.Segments = 1
Beam6.Texture = "rbxassetid://130207880"
Beam6.TextureSpeed = 1
Beam6.Transparency = NumberSequence.new(.5,0)
Beam6.Width0 = 3
Beam6.Width1 = 1.5
Model7.Name = "RightArm"
Model7.Parent = Model0
Part8.Name = "Particles"
Part8.Parent = Model7
Part8.CFrame = CFrame.new(-3, 3.62246037, -66.4395981, -1, 0, 0, 0, 0.999390841, 0.0348994173, 0, 0.0348994173, -0.999390841)
Part8.Orientation = Vector3.new(-2, 180, 0)
Part8.Position = Vector3.new(-3, 3.62246037, -66.4395981)
Part8.Rotation = Vector3.new(-178, 0, -180)
Part8.Color = Color3.new(0, 0, 0)
Part8.Transparency = 1
Part8.Size = Vector3.new(0.5, 0.5, 0.5)
Part8.Anchored = true
Part8.BottomSurface = Enum.SurfaceType.Smooth

Part8.CanCollide = false
Part8.Material = Enum.Material.Neon
Part8.TopSurface = Enum.SurfaceType.Smooth

Part8.FormFactor = Enum.FormFactor.Symmetric
Part8.formFactor = Enum.FormFactor.Symmetric
ParticleEmitter9.Parent = Part8
ParticleEmitter9.Speed = NumberRange.new(1.2000000476837, 1.2000000476837)
ParticleEmitter9.Color = ColorSequence.new({ ColorSequenceKeypoint.new(0, Color3.new(0, 0, 0)),ColorSequenceKeypoint.new(0.699,Color3.new(0.00998336, 0.00998336, 0.00998336)),ColorSequenceKeypoint.new(1,Color3.new(0.45098, 0, 1))})
ParticleEmitter9.LightInfluence = 1
ParticleEmitter9.Texture = "rbxassetid://258128463"
ParticleEmitter9.Transparency= NumberSequence.new({NumberSequenceKeypoint.new(0,1),NumberSequenceKeypoint.new(0.5,0.7),NumberSequenceKeypoint.new(1,1)})
ParticleEmitter9.ZOffset = 2
ParticleEmitter9.Size = NumberSequence.new({NumberSequenceKeypoint.new(0,1.9999998807907),NumberSequenceKeypoint.new(0.43749988079071,0.37499964237213),NumberSequenceKeypoint.new(1,0.68749964237213)})  
ParticleEmitter9.Acceleration = Vector3.new(0, 0, -0.400000006)
ParticleEmitter9.Drag = 1
ParticleEmitter9.Lifetime = NumberRange.new(3, 3)
ParticleEmitter9.LockedToPart = true
ParticleEmitter9.Rate = 100
ParticleEmitter9.RotSpeed = NumberRange.new(-100, 100)
ParticleEmitter9.SpreadAngle = Vector2.new(360, 360)
ParticleEmitter9.VelocitySpread = 360
Part10.Parent = Model7
Part10.CFrame = CFrame.new(-2, 4.33036613, -62.6395836, -0.965925813, 0.0669872463, -0.25, 0, 0.965925872, 0.258818835, 0.258819044, 0.249999791, -0.933012724)
Part10.Orientation = Vector3.new(-15, -165, 0)
Part10.Position = Vector3.new(-2, 4.33036613, -62.6395836)
Part10.Rotation = Vector3.new(-164.5, -14.4799995, -176.029999)
Part10.Color = Color3.new(0, 0, 0)
Part10.Size = Vector3.new(1, 1, 0.5)
Part10.Anchored = true
Part10.BottomSurface = Enum.SurfaceType.Smooth

Part10.CanCollide = false
Part10.Material = Enum.Material.Neon
Part10.TopSurface = Enum.SurfaceType.Smooth

Part10.FormFactor = Enum.FormFactor.Symmetric
Part10.formFactor = Enum.FormFactor.Symmetric
SpecialMesh11.Parent = Part10
SpecialMesh11.MeshType = Enum.MeshType.Sphere
Part12.Parent = Model7
Part12.CFrame = CFrame.new(-1.5, 4.83036566, -63.1395836, 1, 0, 8.74227766e-08, 0, 1, 0, -8.74227766e-08, 0, 1)
Part12.Position = Vector3.new(-1.5, 4.83036566, -63.1395836)
Part12.Color = Color3.new(0.792157, 0.796079, 0.819608)
Part12.Size = Vector3.new(1, 1, 1)
Part12.Anchored = true
Part12.BottomSurface = Enum.SurfaceType.Smooth
Part12.BrickColor = BrickColor.new("Ghost grey")
Part12.CanCollide = false
Part12.Material = Enum.Material.Fabric
Part12.TopSurface = Enum.SurfaceType.Smooth
Part12.brickColor = BrickColor.new("Ghost grey")
Part12.FormFactor = Enum.FormFactor.Symmetric
Part12.formFactor = Enum.FormFactor.Symmetric
SpecialMesh13.Parent = Part12
SpecialMesh13.MeshId = "rbxassetid://1282322452"
SpecialMesh13.Scale = Vector3.new(0.600000024, 0.600000024, 0.600000024)
SpecialMesh13.MeshType = Enum.MeshType.FileMesh
Model14.Name = "LeftArm"
Model14.Parent = Model0
Part15.Parent = Model14
Part15.CFrame = CFrame.new(8.5, 4.83036566, -63.1395836, 1, 0, 8.74227766e-08, 0, 1, 0, -8.74227766e-08, 0, 1)
Part15.Position = Vector3.new(8.5, 4.83036566, -63.1395836)
Part15.Color = Color3.new(0.792157, 0.796079, 0.819608)
Part15.Size = Vector3.new(1, 1, 1)
Part15.Anchored = true
Part15.BottomSurface = Enum.SurfaceType.Smooth
Part15.BrickColor = BrickColor.new("Ghost grey")
Part15.CanCollide = false
Part15.Material = Enum.Material.Fabric
Part15.TopSurface = Enum.SurfaceType.Smooth
Part15.brickColor = BrickColor.new("Ghost grey")
Part15.FormFactor = Enum.FormFactor.Symmetric
Part15.formFactor = Enum.FormFactor.Symmetric
SpecialMesh16.Parent = Part15
SpecialMesh16.MeshId = "rbxassetid://1279765257"
SpecialMesh16.Scale = Vector3.new(0.600000024, 0.600000024, 0.600000024)
SpecialMesh16.MeshType = Enum.MeshType.FileMesh
Part17.Parent = Model14
Part17.CFrame = CFrame.new(9, 4.33036613, -62.6395836, -0.965925872, -0.0669871867, 0.249999806, 0, 0.965925872, 0.258818835, -0.258818835, 0.249999806, -0.933012784)
Part17.Orientation = Vector3.new(-15, 165, 0)
Part17.Position = Vector3.new(9, 4.33036613, -62.6395836)
Part17.Rotation = Vector3.new(-164.5, 14.4799995, 176.029999)
Part17.Color = Color3.new(0, 0, 0)
Part17.Size = Vector3.new(1, 1, 0.5)
Part17.Anchored = true
Part17.BottomSurface = Enum.SurfaceType.Smooth

Part17.CanCollide = false
Part17.Material = Enum.Material.Neon
Part17.TopSurface = Enum.SurfaceType.Smooth

Part17.FormFactor = Enum.FormFactor.Symmetric
Part17.formFactor = Enum.FormFactor.Symmetric
SpecialMesh18.Parent = Part17
SpecialMesh18.MeshType = Enum.MeshType.Sphere
Part19.Name = "Particles"
Part19.Parent = Model14
Part19.CFrame = CFrame.new(10, 3.62246037, -66.4395981, -1, 0, 0, 0, 0.999390841, 0.0348994173, 0, 0.0348994173, -0.999390841)
Part19.Orientation = Vector3.new(-2, 180, 0)
Part19.Position = Vector3.new(10, 3.62246037, -66.4395981)
Part19.Rotation = Vector3.new(-178, 0, -180)
Part19.Color = Color3.new(0, 0, 0)
Part19.Transparency = 1
Part19.Size = Vector3.new(0.5, 0.5, 0.5)
Part19.Anchored = true
Part19.BottomSurface = Enum.SurfaceType.Smooth

Part19.CanCollide = false
Part19.Material = Enum.Material.Neon
Part19.TopSurface = Enum.SurfaceType.Smooth

Part19.FormFactor = Enum.FormFactor.Symmetric
Part19.formFactor = Enum.FormFactor.Symmetric
ParticleEmitter20.Parent = Part19
ParticleEmitter20.Speed = NumberRange.new(1.2000000476837, 1.2000000476837)
ParticleEmitter20.Color =  ColorSequence.new({ ColorSequenceKeypoint.new(0, Color3.new(0, 0, 0)),ColorSequenceKeypoint.new(0.699,Color3.new(0.00998336, 0.00998336, 0.00998336)),ColorSequenceKeypoint.new(1,Color3.new(0.45098, 0, 1))})
ParticleEmitter20.LightInfluence = 1
ParticleEmitter20.Texture = "rbxassetid://258128463"
ParticleEmitter20.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0,1),NumberSequenceKeypoint.new(0.5,0.7),NumberSequenceKeypoint.new(1,1)})
ParticleEmitter20.ZOffset = 2
ParticleEmitter20.Size = NumberSequence.new({NumberSequenceKeypoint.new(0,1.9999998807907),NumberSequenceKeypoint.new(0.43749988079071,0.37499964237213),NumberSequenceKeypoint.new(1,0.68749964237213)})  
ParticleEmitter20.Acceleration = Vector3.new(0, 0, -0.400000006)
ParticleEmitter20.Drag = 1
ParticleEmitter20.Lifetime = NumberRange.new(3, 3)
ParticleEmitter20.LockedToPart = true
ParticleEmitter20.Rate = 100
ParticleEmitter20.RotSpeed = NumberRange.new(-100, 100)
ParticleEmitter20.SpreadAngle = Vector2.new(360, 360)
ParticleEmitter20.VelocitySpread = 360
Model21.Name = "Head"
Model21.Parent = Model0
Part22.Parent = Model21
Part22.CFrame = CFrame.new(4, 8.9408741, -63.4595413, -1, 0, 0, 0, 0.965925872, 0.258818984, 0, 0.258818984, -0.965925872)
Part22.Orientation = Vector3.new(-15, 180, 0)
Part22.Position = Vector3.new(4, 8.9408741, -63.4595413)
Part22.Rotation = Vector3.new(-165, 0, -180)
Part22.Color = Color3.new(0.972549, 0.972549, 0.972549)
Part22.Size = Vector3.new(0.400000036, 0.400000036, 1.20000005)
Part22.Anchored = true
Part22.BottomSurface = Enum.SurfaceType.Smooth
Part22.BrickColor = BrickColor.new("Institutional white")
Part22.CanCollide = false
Part22.Locked = true
Part22.Material = Enum.Material.Neon
Part22.TopSurface = Enum.SurfaceType.Smooth
Part22.brickColor = BrickColor.new("Institutional white")
Part22.FormFactor = Enum.FormFactor.Symmetric
Part22.formFactor = Enum.FormFactor.Symmetric
Part22.Name = "Eye1"
SpecialMesh23.Parent = Part22
SpecialMesh23.MeshType = Enum.MeshType.Sphere
Part24.Parent = Model21
Part24.CFrame = CFrame.new(3.5, 8.93740559, -63.2534142, -1, 0, 0, 0, 0.965925872, 0.258818984, 0, 0.258818984, -0.965925872)
Part24.Orientation = Vector3.new(-15, 180, 0)
Part24.Position = Vector3.new(3.5, 8.93740559, -63.2534142)
Part24.Rotation = Vector3.new(-165, 0, -180)
Part24.Color = Color3.new(0, 0, 0)
Part24.Size = Vector3.new(2, 1, 0.800000012)
Part24.Anchored = true
Part24.BottomSurface = Enum.SurfaceType.Smooth

Part24.CanCollide = false
Part24.Locked = true
Part24.Material = Enum.Material.Neon
Part24.TopSurface = Enum.SurfaceType.Smooth

Part24.FormFactor = Enum.FormFactor.Symmetric
Part24.formFactor = Enum.FormFactor.Symmetric
SpecialMesh25.Parent = Part24
SpecialMesh25.MeshType = Enum.MeshType.Sphere
Part26.Parent = Model21
Part26.CFrame = CFrame.new(3.5, 7.62994099, -63.3966942, -1, 0, 0, 0, 0.965925872, 0.258818984, 0, 0.258818984, -0.965925872)
Part26.Orientation = Vector3.new(-15, 180, 0)
Part26.Position = Vector3.new(3.5, 7.62994099, -63.3966942)
Part26.Rotation = Vector3.new(-165, 0, -180)
Part26.Color = Color3.new(0, 0, 0)
Part26.Size = Vector3.new(1.80000007, 1.5999999, 0.600000024)
Part26.Anchored = true
Part26.BottomSurface = Enum.SurfaceType.Smooth

Part26.CanCollide = false
Part26.Locked = true
Part26.Material = Enum.Material.Neon
Part26.TopSurface = Enum.SurfaceType.Smooth

Part26.FormFactor = Enum.FormFactor.Symmetric
Part26.formFactor = Enum.FormFactor.Symmetric
SpecialMesh27.Parent = Part26
SpecialMesh27.MeshType = Enum.MeshType.Sphere
Part28.Parent = Model21
Part28.CFrame = CFrame.new(3, 8.9408741, -63.4595413, -1, 0, 0, 0, 0.965925872, 0.258818984, 0, 0.258818984, -0.965925872)
Part28.Orientation = Vector3.new(-15, 180, 0)
Part28.Position = Vector3.new(3, 8.9408741, -63.4595413)
Part28.Rotation = Vector3.new(-165, 0, -180)
Part28.Color = Color3.new(0.972549, 0.972549, 0.972549)
Part28.Size = Vector3.new(0.400000036, 0.400000036, 1.20000005)
Part28.Anchored = true
Part28.BottomSurface = Enum.SurfaceType.Smooth
Part28.BrickColor = BrickColor.new("Institutional white")
Part28.CanCollide = false
Part28.Locked = true
Part28.Material = Enum.Material.Neon
Part28.TopSurface = Enum.SurfaceType.Smooth
Part28.brickColor = BrickColor.new("Institutional white")
Part28.FormFactor = Enum.FormFactor.Symmetric
Part28.formFactor = Enum.FormFactor.Symmetric
Part28.Name = "Eye2"
SpecialMesh29.Parent = Part28
SpecialMesh29.MeshType = Enum.MeshType.Sphere
Part30.Parent = Model21
Part30.CFrame = CFrame.new(3.5, 8.98917007, -63.4466019, -1, 0, 0, 0, 0.965925872, 0.258818984, 0, 0.258818984, -0.965925872)
Part30.Orientation = Vector3.new(-15, 180, 0)
Part30.Position = Vector3.new(3.5, 8.98917007, -63.4466019)
Part30.Rotation = Vector3.new(-165, 0, -180)
Part30.Color = Color3.new(0, 0, 0)
Part30.Size = Vector3.new(1, 1, 1)
Part30.Anchored = true
Part30.BottomSurface = Enum.SurfaceType.Smooth

Part30.CanCollide = false
Part30.Locked = true
Part30.Material = Enum.Material.Neon
Part30.TopSurface = Enum.SurfaceType.Smooth

Part30.FormFactor = Enum.FormFactor.Symmetric
Part30.formFactor = Enum.FormFactor.Symmetric
SpecialMesh31.Parent = Part30
SpecialMesh31.MeshType = Enum.MeshType.Sphere
Part32.Name = "Handle"
Part32.Parent = Model21
Part32.CFrame = CFrame.new(3.5, 8.19017696, -63.2465782, -1, 0, 0, 0, 0.965925872, 0.258818984, 0, 0.258818984, -0.965925872)
Part32.Orientation = Vector3.new(-15, 180, 0)
Part32.Position = Vector3.new(3.5, 8.19017696, -63.2465782)
Part32.Rotation = Vector3.new(-165, 0, -180)
Part32.Color = Color3.new(0.0666667, 0.0666667, 0.0666667)
Part32.Size = Vector3.new(0.100000001, 0.100000001, 0.100000001)
Part32.Anchored = true
Part32.BottomSurface = Enum.SurfaceType.Smooth
Part32.BrickColor = BrickColor.new("Really black")
Part32.CanCollide = false
Part32.Locked = true
Part32.Material = Enum.Material.Fabric
Part32.TopSurface = Enum.SurfaceType.Smooth
Part32.brickColor = BrickColor.new("Really black")
Part32.FormFactor = Enum.FormFactor.Symmetric
Part32.formFactor = Enum.FormFactor.Symmetric
SpecialMesh33.Parent = Part32
SpecialMesh33.MeshId = "http://www.roblox.com/asset/?id=13520257"
SpecialMesh33.Scale = Vector3.new(3, 3.0999999, 3)
SpecialMesh33.MeshType = Enum.MeshType.FileMesh
SpecialMesh33.TextureId = "http://www.roblox.com/asset/?id=2349706532"
Decal34.Parent = Part32
--Decal34.Texture = "http://www.roblox.com/asset/?id="..MaskTextureId--124337542 2340547251
Part35.Name = "Particles"
Part35.Parent = Model21
Part35.CFrame = CFrame.new(3.5, 8.64255619, -64.4712448, -1, 0, 0, 0, 0.956304669, 0.292371869, 0, 0.292371869, -0.956304669)
Part35.Orientation = Vector3.new(-17, 180, 0)
Part35.Position = Vector3.new(3.5, 8.64255619, -64.4712448)
Part35.Rotation = Vector3.new(-163, 0, -180)
Part35.Color = Color3.new(0, 0, 0)
Part35.Transparency = 1
Part35.Size = Vector3.new(0.0500000007, 0.0500000007, 0.0500000007)
Part35.Anchored = true
Part35.BottomSurface = Enum.SurfaceType.Smooth

Part35.CanCollide = false
Part35.Locked = true
Part35.Material = Enum.Material.Neon
Part35.TopSurface = Enum.SurfaceType.Smooth

Part35.FormFactor = Enum.FormFactor.Symmetric
Part35.formFactor = Enum.FormFactor.Symmetric
ParticleEmitter36.Parent = Part35
ParticleEmitter36.Speed = NumberRange.new(2, 2)
ParticleEmitter36.Color = ColorSequence.new({ ColorSequenceKeypoint.new(0, Color3.new(0, 0, 0)),ColorSequenceKeypoint.new(0.699,Color3.new(0.00998336, 0.00998336, 0.00998336)),ColorSequenceKeypoint.new(1,Color3.new(0.45098, 0, 1))})
ParticleEmitter36.LightInfluence = 1
ParticleEmitter36.Texture = "rbxassetid://258128463"
ParticleEmitter36.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0,1),NumberSequenceKeypoint.new(0.5,0.5),NumberSequenceKeypoint.new(1,1)})
ParticleEmitter36.ZOffset = -2
ParticleEmitter36.Size = NumberSequence.new({NumberSequenceKeypoint.new(0,1.7500001192093),NumberSequenceKeypoint.new(0.7500001192093,0.74999988079071),NumberSequenceKeypoint.new(1,0.68749964237213)})
ParticleEmitter36.Acceleration = Vector3.new(0, 0.25, 0)
ParticleEmitter36.Drag = 2
ParticleEmitter36.Lifetime = NumberRange.new(1, 3)
ParticleEmitter36.LockedToPart = true
ParticleEmitter36.Rate = 100.01999664307
ParticleEmitter36.RotSpeed = NumberRange.new(-100, 100)
ParticleEmitter36.SpreadAngle = Vector2.new(360, 360)
ParticleEmitter36.VelocitySpread = 360
Part37.Name = "Head"
Part37.Parent = Model21
Part37.CFrame = CFrame.new(3.5, 8.64255619, -64.4712448, -1, 0, 0, 0, 0.956304669, 0.292371869, 0, 0.292371869, -0.956304669)
Part37.Orientation = Vector3.new(-17, 180, 0)
Part37.Position = Vector3.new(3.5, 8.64255619, -64.4712448)
Part37.Rotation = Vector3.new(-163, 0, -180)
Part37.Color = Color3.new(0.00784314, 0.00784314, 0.00784314)
Part37.Size = Vector3.new(3, 3, 3)
Part37.Anchored = true
Part37.BottomSurface = Enum.SurfaceType.Smooth

Part37.CanCollide = false
Part37.Locked = true
Part37.Material = Enum.Material.Fabric
Part37.TopSurface = Enum.SurfaceType.Smooth

Part37.FormFactor = Enum.FormFactor.Symmetric
Part37.formFactor = Enum.FormFactor.Symmetric
SpecialMesh38.Parent = Part37
for i,v in pairs(mas:GetChildren()) do
	v.Parent = script
	pcall(function() v:MakeJoints() end)
end
mas:Destroy()
for i,v in pairs(cors) do
	spawn(function()
		pcall(v)
	end)
end

script:WaitForChild("VoidBoss")
script.VoidBoss:WaitForChild("LeftArm")
script.VoidBoss:WaitForChild("RightArm")
script.VoidBoss:WaitForChild("Head")
local LAP=Instance.new("Part")
		LAP.Reflectance = 0
		LAP.Transparency = 1
		LAP.CanCollide = false
		LAP.Locked = true
		LAP.Anchored=true
		LAP.BrickColor = BrickColor.new("Really blue")
		LAP.Name = "Left Leg"
		LAP.Size = Vector3.new()
		LAP.Material = "SmoothPlastic"
		LAP:BreakJoints()		
	--	LAP.Parent = Character		
		LAP.CFrame = CFrame.new(8.5, 4.83036566, -63.1395836, 1, 0, 8.74227766e-08, 0, 1, 0, -8.74227766e-08, 0, 1)*angles(math.rad(90),0,math.rad(180))
for i,v in pairs(script.VoidBoss.LeftArm:GetChildren()) do
	v.Parent = LAP
end	
script.VoidBoss.LeftArm:Destroy()
	LAP.Parent = script.VoidBoss	
	
local RAP=Instance.new("Part")
		RAP.Reflectance = 0
		RAP.Transparency = 1
		RAP.CanCollide = false
		RAP.Locked = true
		RAP.Anchored=true
		RAP.BrickColor = BrickColor.new("Really blue")
		RAP.Name = "Right Leg"
		RAP.Size = Vector3.new()
		RAP.Material = "SmoothPlastic"
		RAP:BreakJoints()		
	--	RAP.Parent = Character		
		RAP.CFrame = CFrame.new(-1.5, 4.83036566, -63.1395836, 1, 0, 8.74227766e-08, 0, 1, 0, -8.74227766e-08, 0, 1)*angles(math.rad(90),0,math.rad(180))
for i,v in pairs(script.VoidBoss.RightArm:GetChildren()) do
	v.Parent = RAP
end	
script.VoidBoss.RightArm:Destroy()
	RAP.Parent = script.VoidBoss	

local HHP=Instance.new("Part")
		HHP.Reflectance = 0
		HHP.Transparency = 1
		HHP.CanCollide = false
		HHP.Locked = true
		HHP.Anchored=true
		HHP.BrickColor = BrickColor.new("Really blue")
		HHP.Name = "Head"
		HHP.Size = Vector3.new()
		HHP.Material = "SmoothPlastic"
		HHP:BreakJoints()		
		
		HHP.CFrame = CFrame.new(3.5, 8.64255619, -64.4712448, -1, 0, 0, 0, 0.956304669, 0.292371869, 0, 0.292371869, -0.956304669)
for i,v in pairs(script.VoidBoss.Head:GetChildren()) do
	v.Parent = HHP
end	
script.VoidBoss.Head:Destroy()
	HHP.Parent = script.VoidBoss	


--[ ACTIVATE MODEL BY GETING RID OF THIS LINE
for i, v in pairs(GatherAllInstances(script.VoidBoss)) do
	if v:isA("BasePart") then
	RemoveOutlines(v)
	if v:FindFirstChildOfClass("SpecialMesh") and v:FindFirstChildOfClass("SpecialMesh").MeshId~=nil then
	--local mesh = v:FindChildOfClass("SpecialMesh")	
	--v.Size = v.Size/2
	
	
	end
	end
	end

for _,v in pairs(script.VoidBoss:children()) do
		if v:IsA("BasePart")  then
			
			if  Character:FindFirstChild(""..v.Name) then
				local Part1=Character:FindFirstChild(""..v.Name)
				local Part2=v
				
WeldAllTo(Part1,Part2,CFrame.new(0,0,0))

			end
			
			
		end
end	

--]]







	
DGT= function()
local Tlifetime = 0.17
local DaggerTrail=Instance.new("Trail",Sword)	
local Attach1 = Instance.new("Attachment",Sword.HitBox)	
local Attach2 = Instance.new("Attachment",Sword.HitBox)	
Attach2.Position = Vector3.new(0,0,3)
Attach1.Position = Vector3.new(0,0,-3)       
DaggerTrail.Attachment0 = Attach1
DaggerTrail.Attachment1 = Attach2 
DaggerTrail.Texture = "rbxassetid://1251856844"
DaggerTrail.Lifetime = .1
DaggerTrail.MaxLength = 10
DaggerTrail.MinLength = 0
DaggerTrail.TextureMode= "Static"
DaggerTrail.Transparency=NumberSequence.new({NumberSequenceKeypoint.new(0,0),NumberSequenceKeypoint.new(1,1)})
DaggerTrail.WidthScale=NumberSequence.new({NumberSequenceKeypoint.new(0,1),NumberSequenceKeypoint.new(1,0)})
DaggerTrail.LightEmission=0
DaggerTrail.Color = ColorSequence.new(Color3.new(0,1,0),Color3.new(0,1,0))
DaggerTrail.LightEmission = 1
game:GetService("Debris"):AddItem(DaggerTrail, Tlifetime)
game:GetService("Debris"):AddItem(Attach1, Tlifetime)
game:GetService("Debris"):AddItem(Attach2, Tlifetime)
end

function CreatePart( Parent, Material, Reflectance, Transparency, BColor, Name, Size)
	local Part = Create("Part"){
		
		Parent = Parent,
		Reflectance = Reflectance,
		Transparency = Transparency,
		CanCollide = false,
		Locked = true,
		BrickColor = BrickColor.new(tostring(BColor)),
		Name = Name,
		Size = Size,
		Material = Material,
	}
	RemoveOutlines(Part)
	return Part
end

function CreateMesh2(MESH, PARENT, MESHTYPE, MESHID, TEXTUREID, SCALE, OFFSET)
	local NEWMESH = IT(MESH)
	if MESH == "SpecialMesh" then
		NEWMESH.MeshType = MESHTYPE
		if MESHID ~= "nil" and MESHID ~= "" then
			NEWMESH.MeshId = "http://www.roblox.com/asset/?id="..MESHID
		end
		if TEXTUREID ~= "nil" and TEXTUREID ~= "" then
			NEWMESH.TextureId = "http://www.roblox.com/asset/?id="..TEXTUREID
		end
	end
	NEWMESH.Offset = OFFSET or VT(0, 0, 0)
	NEWMESH.Scale = SCALE
	NEWMESH.Parent = PARENT
	return NEWMESH
end

function CreatePart2(FORMFACTOR, PARENT, MATERIAL, REFLECTANCE, TRANSPARENCY, BRICKCOLOR, NAME, SIZE, ANCHOR)
	local NEWPART = IT("Part")
	NEWPART.formFactor = FORMFACTOR
	NEWPART.Reflectance = REFLECTANCE
	NEWPART.Transparency = TRANSPARENCY
	NEWPART.CanCollide = false
	NEWPART.Locked = true
	NEWPART.Anchored = true
	if ANCHOR == false then
		NEWPART.Anchored = false
	end
	NEWPART.BrickColor = BRICKC(tostring(BRICKCOLOR))
	NEWPART.Name = NAME
	NEWPART.Size = SIZE
	NEWPART.Position = Torso.Position
	NEWPART.Material = MATERIAL
	NEWPART:BreakJoints()
	NEWPART.Parent = PARENT
	return NEWPART
end

local S = IT("Sound")
function CreateSound2(ID, PARENT, VOLUME, PITCH, DOESLOOP)
	local NEWSOUND = nil
	coroutine.resume(coroutine.create(function()
		NEWSOUND = S:Clone()
		NEWSOUND.Parent = PARENT
		NEWSOUND.Volume = VOLUME
		NEWSOUND.Pitch = PITCH
		NEWSOUND.SoundId = "http://www.roblox.com/asset/?id="..ID
		NEWSOUND:play()
		if DOESLOOP == true then
			NEWSOUND.Looped = true
		else
			repeat wait(1) until NEWSOUND.Playing == false
			NEWSOUND:remove()
		end
	end))
	return NEWSOUND
end


	function WACKYEFFECT(Table)
	local TYPE = (Table.EffectType or "Sphere")
	local SIZE = (Table.Size or VT(1,1,1))
	local ENDSIZE = (Table.Size2 or VT(0,0,0))
	local TRANSPARENCY = (Table.Transparency or 0)
	local ENDTRANSPARENCY = (Table.Transparency2 or 1)
	local CFRAME = (Table.CFrame or Torso.CFrame)
	local MOVEDIRECTION = (Table.MoveToPos or nil)
	local ROTATION1 = (Table.RotationX or 0)
	local ROTATION2 = (Table.RotationY or 0)
	local ROTATION3 = (Table.RotationZ or 0)
	local MATERIAL = (Table.Material or "Neon")
	local COLOR = (Table.Color or C3(1,1,1))
	local TIME = (Table.Time or 45)
	local SOUNDID = (Table.SoundID or nil)
	local SOUNDPITCH = (Table.SoundPitch or nil)
	local SOUNDVOLUME = (Table.SoundVolume or nil)
	local TweenNameType = (Table.TweenNType or "Linear" )
	local TweenInOutType = (Table.TweenOType or "InOut" )
	coroutine.resume(coroutine.create(function()
		local PLAYSSOUND = false
		local SOUND = nil
		local EFFECT = CreatePart2(3, Effects, MATERIAL, 0, TRANSPARENCY, BRICKC("Pearl"), "Effect", VT(1,1,1), true)
		if SOUNDID ~= nil and SOUNDPITCH ~= nil and SOUNDVOLUME ~= nil then
			PLAYSSOUND = true
			SOUND = CreateSound2(SOUNDID, EFFECT, SOUNDVOLUME, SOUNDPITCH, false)
		end
		EFFECT.Color = COLOR
		local MSH = nil
		if TYPE == "Sphere" then
			MSH = CreateMesh2("SpecialMesh", EFFECT, "Sphere", "", "", SIZE, VT(0,0,0))
		elseif TYPE == "Block" then
			MSH = IT("BlockMesh",EFFECT)
			MSH.Scale = VT(SIZE.X,SIZE.X,SIZE.X)
		elseif TYPE == "Wave" then
			MSH = CreateMesh2("SpecialMesh", EFFECT, "FileMesh", "20329976", "", SIZE, VT(0,0,-SIZE.X/8))
		elseif TYPE == "Ring" then
			MSH = CreateMesh2("SpecialMesh", EFFECT, "FileMesh", "559831844", "", VT(SIZE.X,SIZE.X,0.1), VT(0,0,0))
		elseif TYPE == "Slash" then
			MSH = CreateMesh2("SpecialMesh", EFFECT, "FileMesh", "662586858", "", VT(SIZE.X/10,0,SIZE.X/10), VT(0,0,0))
		elseif TYPE == "Round Slash" then
			MSH = CreateMesh2("SpecialMesh", EFFECT, "FileMesh", "662585058", "", VT(SIZE.X/10,0,SIZE.X/10), VT(0,0,0))
		elseif TYPE == "Swirl" then
			MSH = CreateMesh2("SpecialMesh", EFFECT, "FileMesh", "1051557", "", SIZE, VT(0,0,0))
		elseif TYPE == "Skull" then
			MSH = CreateMesh2("SpecialMesh", EFFECT, "FileMesh", "4770583", "", SIZE, VT(0,0,0))
		elseif TYPE == "Crystal" then
			MSH = CreateMesh2("SpecialMesh", EFFECT, "FileMesh", "9756362", "", SIZE, VT(0,0,0))
		elseif TYPE == "Crown" then
			MSH = CreateMesh2("SpecialMesh", EFFECT, "FileMesh", "173770780", "", SIZE, VT(0,0,0))
		end
		if MSH ~= nil then
			local MOVESPEED = nil
			if MOVEDIRECTION ~= nil then
				MOVESPEED = (CFRAME.p - MOVEDIRECTION).Magnitude/TIME
			end
			local GROWTH = SIZE - ENDSIZE
			local TRANS = TRANSPARENCY - ENDTRANSPARENCY
			if TYPE == "Block" then
			
				SetTween(EFFECT,{CFrame = CFRAME*ANGLES(RAD(MRANDOM(0,360)),RAD(MRANDOM(0,360)),RAD(MRANDOM(0,360)))},"Linear","InOut",TIME/60)
			else
		
			SetTween(EFFECT,{CFrame = CFRAME},"Linear","InOut",0)
				
			end
			
			
			
			wait()
			
			SetTween(EFFECT,{Transparency = EFFECT.Transparency - TRANS},"Linear","InOut",TIME/60)
			
							if TYPE == "Block" then
	
					SetTween(EFFECT,{CFrame = CFRAME*ANGLES(RAD(MRANDOM(0,360)),RAD(MRANDOM(0,360)),RAD(MRANDOM(0,360)))},"Linear","InOut",0)
				else

					SetTween(EFFECT,{CFrame = EFFECT.CFrame*ANGLES(RAD(ROTATION1),RAD(ROTATION2),RAD(ROTATION3))},"Linear","InOut",0)
					
				end
							if MOVEDIRECTION ~= nil then
					local ORI = EFFECT.Orientation

					SetTween(EFFECT,{CFrame=CF(MOVEDIRECTION)},"Linear","InOut",TIME/60)
						SetTween(EFFECT,{Orientation=ORI},"Linear","InOut",TIME/60)
				
					
							end
							MSH.Scale = MSH.Scale - GROWTH/TIME
									SetTween(MSH,{Scale=ENDSIZE},TweenNameType,TweenInOutType,TIME/60)
										if TYPE == "Wave" then
				
						SetTween(MSH,{Offset=VT(0,0,-MSH.Scale.X/8)},TweenNameType,TweenInOutType,TIME/60)
				end
			for LOOP = 1, TIME+1 do
				wait(.05)

				--SetTween(EFFECT,{Transparency = EFFECT.Transparency - TRANS/TIME},"Linear","InOut",0)
				
				
				if TYPE == "Block" then
	
	--				SetTween(EFFECT,{CFrame = CFRAME*ANGLES(RAD(MRANDOM(0,360)),RAD(MRANDOM(0,360)),RAD(MRANDOM(0,360)))},"Linear","InOut",0)
				else

	--				SetTween(EFFECT,{CFrame = EFFECT.CFrame*ANGLES(RAD(ROTATION1),RAD(ROTATION2),RAD(ROTATION3))},"Linear","InOut",0)
					
				end
				if MOVEDIRECTION ~= nil then
					local ORI = EFFECT.Orientation

--					SetTween(EFFECT,{CFrame=CF(EFFECT.Position,MOVEDIRECTION)*CF(0,0,-MOVESPEED)},"Linear","InOut",0)
--						SetTween(EFFECT,{Orientation=ORI},"Linear","InOut",0)
				
					
				end
			end
				game:GetService("Debris"):AddItem(EFFECT, 15)
				coroutine.resume(coroutine.create(function()
			if PLAYSSOUND == false then
				EFFECT:remove()
			else
				SOUND.Stopped:Connect(function()
					EFFECT:remove()
				end)
			end
			end))
		else
			coroutine.resume(coroutine.create(function()
			if PLAYSSOUND == false then
				EFFECT:remove()
			else
				repeat wait() until SOUND.Playing == false
				EFFECT:remove()
			end
			end))
		end
	end))
		end	
		
		
		
		
		
		
	Damagefunc = function(Part, hit, minim, maxim, knockback, Type, Property, Delay, HitSound, HitPitch)
	
	if hit.Parent == nil then
		return 
	end
	local h = hit.Parent:FindFirstChild("Humanoid")
	for _,v in pairs(hit.Parent:children()) do
		if v:IsA("Humanoid") then

	h = v 
		
	end
	
end
	
	--gg
	
--local FoundTorso = hit.Parent:FindFirstChild("Torso") or hit.Parent:FindFirstChild("UpperTorso")	
		coroutine.resume(coroutine.create(function()	
if h.Health >9999999 and minim <9999 and Type~= "IgnoreType" and(h.Parent:FindFirstChild("Torso") or h.Parent:FindFirstChild("UpperTorso")) and not h.Parent:FindFirstChild("Fly away")then
	
	
	local FATag = Instance.new("Model",h.Parent)

	FATag.Name = "Fly away"
game:GetService("Debris"):AddItem(FATag, 2.5)	
	
	
	for _,v in pairs(h.Parent:children()) do
		if v:IsA("BasePart")and v.Parent:FindFirstChildOfClass("Humanoid") then
			v.Anchored=true
		end
	end	

wait(.25)
	
if 	h.Parent:FindFirstChildOfClass("Body Colors")then
h.Parent:FindFirstChildOfClass("Body Colors"):Destroy()
end


	local FoundTorso = h.Parent:FindFirstChild("Torso") or h.Parent:FindFirstChild("UpperTorso")
	
	coroutine.resume(coroutine.create(function()	
		
		
local YourGone = Instance.new("Part")
		YourGone.Reflectance = 0
		YourGone.Transparency = 1
		YourGone.CanCollide = false
		YourGone.Locked = true
		YourGone.Anchored=true
		YourGone.BrickColor = BrickColor.new("Really blue")
		YourGone.Name = "YourGone"
		YourGone.Size = Vector3.new()
		YourGone.Material = "SmoothPlastic"
		YourGone:BreakJoints()
		YourGone.Parent = FoundTorso		
		YourGone.CFrame = FoundTorso.CFrame
				
	local NewParticle = Instance.new("ParticleEmitter")
NewParticle.Parent = YourGone
NewParticle.Acceleration =  Vector3.new(0,0,0)
NewParticle.Size = NumberSequence.new({NumberSequenceKeypoint.new(0,10),NumberSequenceKeypoint.new(1,.0)})
NewParticle.Color = ColorSequence.new(Color3.new (1,0,0), Color3.new (1, 0, 0))
NewParticle.Lifetime = NumberRange.new(0.55,0.95)
NewParticle.Transparency=NumberSequence.new({NumberSequenceKeypoint.new(0,1),NumberSequenceKeypoint.new(.25,.0),NumberSequenceKeypoint.new(1,1)})
NewParticle.Speed = NumberRange.new(0,0.0)
NewParticle.ZOffset = 2
NewParticle.Texture = "rbxassetid://243660364"
NewParticle.RotSpeed = NumberRange.new(-0,0)
NewParticle.Rotation = NumberRange.new(-180,180)
NewParticle.Enabled = false
game:GetService("Debris"):AddItem(YourGone, 3)	
for i = 0,2,1 do
NewParticle:Emit(1)
so("1448044156", FoundTorso,2, 1)
h.Parent:BreakJoints()
YourGone.CFrame = FoundTorso.CFrame
	for _,v in pairs(h.Parent:children()) do
		if v:IsA("BasePart")and v.Parent:FindFirstChildOfClass("Humanoid") then
			v.Anchored=false
--			v.Material = "Neon"
			--v.BrickColor = BrickColor.new("Really red")
			if v:FindFirstChildOfClass("SpecialMesh")then
	--v:Destroy()
			end	
						if v:FindFirstChildOfClass("Decal") and v.Name == "face" then
--	v:Destroy()
end		
					local vp = Create("BodyVelocity")({P = 500, maxForce = Vector3.new(1000, 1000, 1000), velocity = Vector3.new(math.random(-10,10),4,math.random(-10,10)) })
										
				vp.Parent = v		
						game:GetService("Debris"):AddItem(vp, math.random(50,100)/1000)				
			
			
		end
		
		
		
	end	

	
	
wait(.2)	
end
wait(.1)	
NewParticle:Emit(3)
so("1448044156", FoundTorso,2, .8)
h.Parent:BreakJoints()
YourGone.CFrame = FoundTorso.CFrame
	for _,v in pairs(h.Parent:children()) do
		if v:IsA("BasePart")and v.Parent:FindFirstChildOfClass("Humanoid") then
			v.Anchored=false
--			v.Material = "Neon"
			--v.BrickColor = BrickColor.new("Really red")
			if v:FindFirstChildOfClass("SpecialMesh")then
	--v:Destroy()
			end	
						if v:FindFirstChildOfClass("Decal") and v.Name == "face" then
--	v:Destroy()
end		
					local vp = Create("BodyVelocity")({P = 500, maxForce = Vector3.new(1000, 1000, 1000), velocity = Vector3.new(math.random(-10,10),4,math.random(-10,10)) })
										
				vp.Parent = v		
						game:GetService("Debris"):AddItem(vp, math.random(100,200)/1000)				
			
			
		end
		
		
		
	end	

	
	
	
	end))
	



wait(.1)



	
	
	
	
	end
	
	
	end))
	if h ~= nil and hit.Parent ~= Character and hit.Parent:FindFirstChild("Torso") or hit.Parent:FindFirstChild("UpperTorso") ~= nil then
		if hit.Parent:findFirstChild("DebounceHit") ~= nil and hit.Parent.DebounceHit.Value == true then
			return 
		end
		local c = Create("ObjectValue")({Name = "creator", Value = game:service("Players").basstracker1970, Parent = h})
		game:GetService("Debris"):AddItem(c, 0.5)
		if HitSound ~= nil and HitPitch ~= nil then
			so(HitSound, hit, 1, HitPitch)
		end
		local Damage = math.random(minim, maxim)
		local blocked = false
		local block = hit.Parent:findFirstChild("Block")
		if block ~= nil and block.className == "IntValue" and block.Value > 0 then
			blocked = true
			block.Value = block.Value - 1
			print(block.Value)
		end
		lockon(h.Parent)
		if blocked == false then
			h.Health = h.Health - Damage
			ShowDamage(Part.CFrame * CFrame.new(0, 0, Part.Size.Z / 2).p + Vector3.new(0, 1.5, 0), -Damage, 2.5, Color3.new(0,0,0))
		else
			h.Health = h.Health - Damage / 2
			ShowDamage(Part.CFrame * CFrame.new(0, 0, Part.Size.Z / 2).p + Vector3.new(0, 1.5, 0), -Damage, 2.5, Color3.new(0,0,0))
			
		end

		if Type == "Knockdown" then
					local hum = h
		
			hum.PlatformStand = true
			coroutine.resume(coroutine.create(function(HHumanoid)
		
		wait(.2)
		HHumanoid.PlatformStand = false
	end
			), hum)
			
			
			
			local FoundTorso = h.Parent:FindFirstChild("Torso") or h.Parent:FindFirstChild("UpperTorso")
			local angle = hit.Position - (Property.Position + Vector3.new(0, 0, 0)).unit
			local bodvol = Create("BodyVelocity")({P = 500, maxForce = Vector3.new(math.huge, 0, math.huge), velocity = CFrame.new(Part.Position,FoundTorso.Position).lookVector * knockback, Parent = hit})
			local rl = Create("BodyAngularVelocity")({P = 3000, maxTorque = Vector3.new(5000, 5000, 5000) * 50, angularvelocity = Vector3.new(math.random(-10, 10), math.random(-10, 10), math.random(-10, 10)), Parent = hit})
			game:GetService("Debris"):AddItem(bodvol, .2)
			game:GetService("Debris"):AddItem(rl, 0.2)



		elseif Type == "Knockdown2" then
					local hum = h
		
			hum.PlatformStand = true
			coroutine.resume(coroutine.create(function(HHumanoid)
		
						
 Combo = 1			wait(.2)
		HHumanoid.PlatformStand = false
	end
), hum)
			local angle = hit.Position - (Property.Position + Vector3.new(0, 0, 0)).unit
			local bodvol = Create("BodyVelocity")({P = 500, maxForce = Vector3.new(math.huge, 0, math.huge), velocity = CFrame.new(Part.Position,Property.Position).lookVector * knockback})
			local rl = Create("BodyAngularVelocity")({P = 3000, maxTorque = Vector3.new(5000, 5000, 5000) * 50, angularvelocity = Vector3.new(math.random(-10, 10), math.random(-10, 10), math.random(-10, 10)), Parent = hit})
			game:GetService("Debris"):AddItem(bodvol, 0.2)
			game:GetService("Debris"):AddItem(rl, 0.2)






							local bodyVelocity2 = Create("BodyVelocity")({velocity = Vector3.new(0, 60, 0), P = 5000, maxForce = Vector3.new(8000, 12000, 8000), Parent = RootPart})
							game:GetService("Debris"):AddItem(bodyVelocity2, 0.1)

		elseif Type == "Normal" then
					local vp = Create("BodyVelocity")({P = 500, maxForce = Vector3.new(math.huge, 0, math.huge), velocity = CFrame.new(Part.Position,Property.Position).lookVector * knockback})
					if knockback > 0 then
						
				local HTorso = hit.Parent:FindFirstChild("Torso") or hit.Parent:FindFirstChild("UpperTorso")
						vp.Parent = HTorso
					end
					game:GetService("Debris"):AddItem(vp, 0.25)
					
					
					
					
					
					
					
					
					
					
					
					
					
		elseif Type== "Instakill" 	then
					coroutine.resume(coroutine.create(function()	
if  (h.Parent:FindFirstChild("Torso") or h.Parent:FindFirstChild("UpperTorso")) and not h.Parent:FindFirstChild("Fly away")then
	
	
	local FATag = Instance.new("Model",h.Parent)

	FATag.Name = "Fly away"
game:GetService("Debris"):AddItem(FATag, 2.5)	
	
	
	for _,v in pairs(h.Parent:children()) do
		if v:IsA("BasePart")and v.Parent:FindFirstChildOfClass("Humanoid") then
			v.Anchored=true
		end
	end	

wait(.25)
	
if 	h.Parent:FindFirstChildOfClass("Body Colors")then
h.Parent:FindFirstChildOfClass("Body Colors"):Destroy()
end


	local FoundTorso = h.Parent:FindFirstChild("Torso") or h.Parent:FindFirstChild("UpperTorso")
	
	coroutine.resume(coroutine.create(function()	
		
		
local YourGone = Instance.new("Part")
		YourGone.Reflectance = 0
		YourGone.Transparency = 1
		YourGone.CanCollide = false
		YourGone.Locked = true
		YourGone.Anchored=true
		YourGone.BrickColor = BrickColor.new("Really blue")
		YourGone.Name = "YourGone"
		YourGone.Size = Vector3.new()
		YourGone.Material = "SmoothPlastic"
		YourGone:BreakJoints()
		YourGone.Parent = FoundTorso		
		YourGone.CFrame = FoundTorso.CFrame
				
	local NewParticle = Instance.new("ParticleEmitter")
NewParticle.Parent = YourGone
NewParticle.Acceleration =  Vector3.new(0,0,0)
NewParticle.Size = NumberSequence.new({NumberSequenceKeypoint.new(0,10),NumberSequenceKeypoint.new(1,.0)})
NewParticle.Color = ColorSequence.new(Color3.new (1,0,0), Color3.new (1, 0, 0))
NewParticle.Lifetime = NumberRange.new(0.55,0.95)
NewParticle.Transparency=NumberSequence.new({NumberSequenceKeypoint.new(0,1),NumberSequenceKeypoint.new(.25,.0),NumberSequenceKeypoint.new(1,1)})
NewParticle.Speed = NumberRange.new(0,0.0)
NewParticle.ZOffset = 2
NewParticle.Texture = "rbxassetid://243660364"
NewParticle.RotSpeed = NumberRange.new(-0,0)
NewParticle.Rotation = NumberRange.new(-180,180)
NewParticle.Enabled = false
game:GetService("Debris"):AddItem(YourGone, 3)	
for i = 0,2,1 do
NewParticle:Emit(1)
so("1448044156", FoundTorso,2, 1)
h.Parent:BreakJoints()
YourGone.CFrame = FoundTorso.CFrame
	for _,v in pairs(h.Parent:children()) do
		if v:IsA("BasePart")and v.Parent:FindFirstChildOfClass("Humanoid") then
			v.Anchored=false
--			v.Material = "Neon"
			--v.BrickColor = BrickColor.new("Really red")
			if v:FindFirstChildOfClass("SpecialMesh")then
	--v:Destroy()
			end	
						if v:FindFirstChildOfClass("Decal") and v.Name == "face" then
--	v:Destroy()
end		
					local vp = Create("BodyVelocity")({P = 500, maxForce = Vector3.new(1000, 1000, 1000), velocity = Vector3.new(math.random(-10,10),4,math.random(-10,10)) })
										
				vp.Parent = v		
						game:GetService("Debris"):AddItem(vp, math.random(50,100)/1000)				
			
			
		end
		
		
		
	end	

	
	
wait(.2)	
end
wait(.1)	
NewParticle:Emit(3)
so("1448044156", FoundTorso,2, .8)
h.Parent:BreakJoints()
YourGone.CFrame = FoundTorso.CFrame
	for _,v in pairs(h.Parent:children()) do
		if v:IsA("BasePart")and v.Parent:FindFirstChildOfClass("Humanoid") then
			v.Anchored=false
--			v.Material = "Neon"
			--v.BrickColor = BrickColor.new("Really red")
			if v:FindFirstChildOfClass("SpecialMesh")then
	--v:Destroy()
			end	
						if v:FindFirstChildOfClass("Decal") and v.Name == "face" then
--	v:Destroy()
end		
					local vp = Create("BodyVelocity")({P = 500, maxForce = Vector3.new(1000, 1000, 1000), velocity = Vector3.new(math.random(-10,10),4,math.random(-10,10)) })
										
				vp.Parent = v		
						game:GetService("Debris"):AddItem(vp, math.random(100,200)/1000)				
			
			
		end
		
		
		
	end	

	
	
	
	end))
	



wait(.1)



	
	
	
	
	end
	
	
	end))
				
					
					
					
		elseif Type == "HPSteal" then
					Humanoid.Health = Humanoid.Health + Damage
								local hum = h
		
			hum.PlatformStand = true
			coroutine.resume(coroutine.create(function(HHumanoid)
		
						
 Combo = 1			wait(.2)
		HHumanoid.PlatformStand = false
	end
), hum)
			local angle = hit.Position - (Property.Position + Vector3.new(0, 0, 0)).unit
			local bodvol = Create("BodyVelocity")({P = 500, maxForce = Vector3.new(math.huge, 0, math.huge), velocity = CFrame.new(Part.Position,Property.Position).lookVector * knockback})
			local rl = Create("BodyAngularVelocity")({P = 3000, maxTorque = Vector3.new(5000, 5000, 5000) * 50, angularvelocity = Vector3.new(math.random(-10, 10), math.random(-10, 10), math.random(-10, 10)), Parent = hit})
			game:GetService("Debris"):AddItem(bodvol, 0.2)
			game:GetService("Debris"):AddItem(rl, 0.2)






							local bodyVelocity2 = Create("BodyVelocity")({velocity = Vector3.new(0, 60, 0), P = 5000, maxForce = Vector3.new(8000, 12000, 8000), Parent = RootPart})
							game:GetService("Debris"):AddItem(bodyVelocity2, 0.1)

			
					elseif Type == "Impale" then






	

CFuncs.Sound.Create("http://www.roblox.com/asset/?id=268249319", Spike, .8, 2)	
			hit.Parent.Humanoid.PlatformStand = true
			
		
		wait(1)
		hit.Parent.Humanoid.PlatformStand = false
		elseif Type == "IgnoreType" then
			

			
			
			
				elseif Type == "Up" then
							local bodyVelocity = Create("BodyVelocity")({velocity = Vector3.new(0, 20, 0), P = 5000, maxForce = Vector3.new(8000, 8000, 8000), Parent = hit})
							game:GetService("Debris"):AddItem(bodyVelocity, 0.1)
							local bodyVelocity = Create("BodyVelocity")({velocity = Vector3.new(0, 20, 0), P = 5000, maxForce = Vector3.new(8000, 8000, 8000), Parent = hit})
							game:GetService("Debris"):AddItem(bodyVelocity, .1)
				
				

		
			
			
			
						elseif Type == "Snare" then
									local bp = Create("BodyPosition")({P = 900, D = 1000, maxForce = Vector3.new(math.huge, math.huge, math.huge), position = hit.Parent.Torso.Position, Parent = hit.Parent.Torso})
									game:GetService("Debris"):AddItem(bp, 1)
			
						

							elseif Type == "Freeze2" then
											local BodPos = Create("BodyPosition")({P = 50000, D = 1000, maxForce = Vector3.new(math.huge, math.huge, math.huge), position = hit.Parent.Torso.Position, Parent = hit.Parent.Torso})
											local BodGy = Create("BodyGyro")({maxTorque = Vector3.new(400000, 400000, 400000) * math.huge, P = 20000, Parent = hit.Parent.Torso, cframe = hit.Parent.Torso.CFrame})
											hit.Parent.Torso.Anchored = true
											coroutine.resume(coroutine.create(function(Part)
		
		wait(1.5)
		Part.Anchored = false
	end
), hit.Parent.Torso)
											game:GetService("Debris"):AddItem(BodPos, 3)
											game:GetService("Debris"):AddItem(BodGy, 3)
										end
											local debounce = Create("BoolValue")({Name = "DebounceHit", Parent = hit.Parent, Value = true})
											game:GetService("Debris"):AddItem(debounce, Delay)
											c = Instance.new("ObjectValue")
											c.Name = "creator"
											c.Value = Player
											c.Parent = h
											game:GetService("Debris"):AddItem(c, 0.5)
										end
									end



	ShowDamage = function(Pos, Text, Time, Color)
	
	local Rate = 0.033333333333333
	if not Pos then
		local Pos = Vector3.new(0, 0, 0)
	end
	local Text = Text or ""
	local Time = Time or 2
	if not Color then
		local Color = Color3.new(1, 0, 1)
	end
	local EffectPart = CreatePart(workspace, "SmoothPlastic", 0, 1, BrickColor.new(Color), "Effect", Vector3.new(0, 0, 0))
	EffectPart.Anchored = true
	local BillboardGui = Create("BillboardGui")({Size = UDim2.new(2, 0, 2, 0), Adornee = EffectPart, Parent = EffectPart})
	local TextLabel = Create("TextLabel")({BackgroundTransparency = 1, Size = UDim2.new(1, 0, 1, 0), Text = "DMG: "..Text.."", TextColor3 = Color, TextScaled = true, Font = Enum.Font.ArialBold, Parent = BillboardGui})
	game.Debris:AddItem(EffectPart, Time + 0.1)
	EffectPart.Parent = game:GetService("Workspace")
	delay(0, function()
		
		local Frames = Time / Rate
		
		
		
print(Frames)
		TextLabel.TextTransparency=0
		EffectPart.CFrame=CFrame.new(Pos)
		wait()
		SetTween(TextLabel,{TextTransparency=1},"Quad","In",Frames/60)
		SetTween(TextLabel,{Rotation=math.random(-25,25)},"Elastic","InOut",Frames/60)
		SetTween(TextLabel,{TextColor3=Color3.new(.15,0,.5)},"Elastic","InOut",Frames/60)

SetTween(EffectPart,{CFrame = CFrame.new(Pos) + Vector3.new(math.random(-5,5), math.random(1,5), math.random(-5,5))},"Linear","InOut",Frames/60)


		wait(Frames/60)
		
		if EffectPart and EffectPart.Parent then
			EffectPart:Destroy()
		end
	end
)
end

	MagniDamage = function(Part, magni, mindam, maxdam, knock, Type2)
		
		
		
		
local Type=""




if  mememode == true then
 
Type=	"Instakill"

else
Type=Type2
end 
if Type2 == "NormalKnockdown" then
	Type= "Knockdown"
end
		
	for _,c in pairs(workspace:children()) do
		
		
		
		
		
		local hum = c:FindFirstChild("Humanoid")
	for _,v in pairs(c:children()) do
		if v:IsA("Humanoid") then
			hum = v
		end
	end	
		
		
		
		
		if hum ~= nil then
			local head = c:findFirstChild("Head")
			if head ~= nil then
				local targ = head.Position - Part.Position
				local mag = targ.magnitude
				if mag <= magni and c.Name ~= Player.Name then
					Damagefunc(Part, head, mindam, maxdam, knock, Type, RootPart, 0.1, "851453784", 1.2)
				end
			end
		end
	end
end


function CFMagniDamage(HTCF,magni, mindam, maxdam, knock, Type)
local DGP = Instance.new("Part")

DGP.Parent = Character
DGP.Size = Vector3.new(0.05, 0.05, 0.05)
DGP.Transparency = 1
DGP.CanCollide = false
DGP.Anchored = true
RemoveOutlines(DGP)
DGP.Position=DGP.Position + Vector3.new(0,-.1,0)
DGP.CFrame = HTCF

coroutine.resume(coroutine.create(function()
MagniDamage(DGP, magni, mindam, maxdam, knock, Type)
end))
game:GetService("Debris"):AddItem(DGP, .05)


DGP.Archivable = false
end

		
		
		
------------------
--[End of Sword]--
------------------

---------------
--[Particles]--
---------------























----------------------
--[End Of Particles]--
----------------------




-----------------

function lockon_OnOff ()
	coroutine.resume(coroutine.create(function()
		
		local NewParticleH = Instance.new("Attachment",eye)
		NewParticleH.Position = Vector3.new(0,0,.25)
			coroutine.resume(coroutine.create(function()
			local CrystalMainColor = Color3.new(0,1,0)	
		
		
		local NewParticle = Particle2_1:Clone()
NewParticle.Parent = NewParticleH
NewParticle.Enabled = true
NewParticle.Texture = "rbxassetid://68942583"
NewParticle.Acceleration =  Vector3.new(0,0,0)
NewParticle.Speed = NumberRange.new(0)
NewParticle.LockedToPart = true
NewParticle.ZOffset = .25
NewParticle.Size = NumberSequence.new({NumberSequenceKeypoint.new(0,2.5),NumberSequenceKeypoint.new(1,0)})
NewParticle.Rate = 50
NewParticle.Color = ColorSequence.new(CrystalMainColor, CrystalMainColor)
NewParticle.Transparency=NumberSequence.new({NumberSequenceKeypoint.new(0,1),NumberSequenceKeypoint.new(1,.9)})
NewParticle.Name = "XEF"		
		
		
	end))	
		
		
while ZT == true do 
	
	
	
	SetTween(imgl,{Rotation=imgl.Rotation+25.5},"Elastic","Out",3)
	if ZTfade==true then
	SetTween(imgl,{ImageTransparency=.7},"Elastic","Out",3)
	SetTween(crosshair,{Size = UDim2.new(10,0,10,0)},"Elastic","Out",1.5)
end


wait(1.5)	
	if ZTfade==true then
SetTween(imgl,{ImageTransparency=0},"Linear","InOut",0)
SetTween(crosshair,{Size = UDim2.new(11,0,11,0)},"Elastic","InOut",0)
end
wait()
end

	crosshair.Adornee = nil
	crosshair.Enabled = false
NewParticleH:Destroy()

end))
	end

function lockon (targetted)
	if ZT == true then
	
		coroutine.resume(coroutine.create(function()
	crosshair.Adornee = targetted:FindFirstChild("Torso") or targetted:FindFirstChild("UpperTorso")
	crosshair.Enabled = true
	
ZTfade = false
SetTween(imgl,{ImageTransparency=1},"Linear","InOut",0)

SetTween(crosshair,{Size = UDim2.new(40,0,40,0)},"Linear","InOut",0)

wait()

SetTween(imgl,{ImageTransparency=.7},"Bounce","Out",2)

SetTween(crosshair,{Size = UDim2.new(10,0,10,0)},"Elastic","InOut",1)
wait(1)
ZTfade = true
		end))
		end
end






-----------------


	


--[[
		for i, v in pairs(C:GetChildren()) do
if v:IsA("Accessory")then
v:Destroy()	
end
if v:IsA("BasePart")then
v.Transparency =1
if v.Name == "Head" then
	v:FindFirstChildOfClass("Decal"):Destroy()
end
end
		end--]]
--[[













local tweeningInformation = TweenInfo.new(
	0.5,	
	Enum.EasingStyle.Back,
	Enum.EasingDirection.Out,
	0,
	false,
	0
)
--]]


local RJW=weld(RJ.Parent,RJ.Part0,RJ.Part1,RJ.C0)
RJW.C1 = RJ.C1
RJW.Name = RJ.Name

local NeckW=weld(Neck.Parent,Neck.Part0,Neck.Part1,Neck.C0)
NeckW.C1 = Neck.C1
NeckW.Name = Neck.Name


--print(WRJ.Parent.Name)

local RW=weld(Torso,Torso,RightArm,cf(0,0,0))

local LW=weld(Torso,Torso,LeftArm,cf(0,0,0))

local RH=weld(Torso,RightArm,RightLeg,cf(0,0,0))

local LH=weld(Torso,LeftArm,LeftLeg,cf(0,0,0))



RW.C1 = cn(0, 0.5, 0)
LW.C1 = cn(0, 0.5, 0)
RH.C1 = cn(0, 1, 0) *CFrame.Angles(math.rad(0),math.rad(0),math.rad(0))
LH.C1 = cn(0, 1, 0) *CFrame.Angles(math.rad(0),math.rad(0),math.rad(0))






--------
--(#Torso)
SetTween(RJW,{C0=RootCF*CFrame.new(0,0,0)},"Quad","InOut",0.1)
--------
--(#Head)
SetTween(NeckW,{C0=NeckCF*CFrame.new(0,0,0)},"Quad","InOut",0.1)
--------
--(#Right Arm)
SetTween(RW,{C0=CFrame.new(1.5 , 0.5, -.0)},"Quad","InOut",0.1)
--------
--(#Left Arm)
SetTween(LW,{C0=CFrame.new(-1.5, 0.5, -.0)},"Quad","InOut",0.1)
--------
--(#Right Leg)
SetTween(RH,{C0=CFrame.new(0, -0.90, 0)},"Quad","InOut",0.1)
--------
--(#Left Leg)
SetTween(LH,{C0=CFrame.new(0, -0.90, 0)},"Quad","InOut",0.1)



--[[
SetTween(RJW,{C0=RootCF*CFrame.new(0,0,0)*angles(math.rad(0),math.rad(0),math.rad(0))},"Quad","InOut",0.1)
SetTween(NeckW,{C0=NeckCF*CFrame.new(0,0,2)*angles(math.rad(0),math.rad(0),math.rad(0))},"Quad","InOut",0.1)
SetTween(RW,{C0=CFrame.new(3.5 , 0.5, -.0)*angles(math.rad(0),math.rad(0),math.rad(30))},"Quad","Out",0.1)
SetTween(LW,{C0=CFrame.new(-3.5, 0.5, -.0)*angles(math.rad(0),math.rad(0),math.rad(-30))},"Quad","Out",0.1)
SetTween(RH,{C0=CFrame.new(0, -3, 0)*angles(math.rad(0),math.rad(0),math.rad(0))},"Quad","InOut",0.1)
SetTween(LH,{C0=CFrame.new(-0, -3, 0)*angles(math.rad(0),math.rad(0),math.rad(0))},"Quad","InOut",0.1)
--]]

function Attack1()
attack = true
SetTween(RJW,{C0=RootCF*CFrame.new(0,-2,2)*angles(math.rad(30),math.rad(0),math.rad(0))},"Quad","InOut",1)
SetTween(NeckW,{C0=NeckCF*CFrame.new(0,0,-2)*angles(math.rad(20),math.rad(0),math.rad(0))},"Quad","InOut",1)
SetTween(RW,{C0=CFrame.new(2.5 , 3.5, 1.5)*angles(math.rad(30),math.rad(0),math.rad(30))},"Quad","InOut",1)
SetTween(LW,{C0=CFrame.new(-2.5, 3.5, 1.5)*angles(math.rad(30),math.rad(0),math.rad(-30))},"Quad","InOut",1)
SetTween(RH,{C0=CFrame.new(0, -3, 0)*angles(math.rad(50),math.rad(0),math.rad(-90))},"Quad","InOut",1)
SetTween(LH,{C0=CFrame.new(-0, -3, 0)*angles(math.rad(50),math.rad(0),math.rad(90))},"Quad","InOut",1)


wait(1)

	WACKYEFFECT({Time = 10, EffectType = "Slash", Size = (VT(60,0,60)), Size2 = (VT(0,0,0)), Transparency = 1, Transparency2 = .5, CFrame = RootPart.CFrame * ANGLES(RAD(MRANDOM(0,15)), RAD(MRANDOM(0,360)), RAD(MRANDOM(0,15))), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = C3(0,0,0), SoundID = 454850461, SoundPitch = 1, SoundVolume = 8})
						
						for i = 10, 60,10 do
							WACKYEFFECT({Time = 10+i, EffectType = "Slash", Size = (VT(60,0,60)), Size2 = (VT(0,0,0)), Transparency = 1, Transparency2 = .5, CFrame = RootPart.CFrame * ANGLES(RAD(MRANDOM(0,15)), RAD(MRANDOM(0,360)), RAD(MRANDOM(0,15))), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = C3(0,0,0), SoundID = nil, SoundPitch = 1, SoundVolume = 5})
						end					
for i = 0,10 do wait() wait() wait()
				local AREA = RootPart.CFrame * ANGLES(RAD(0), RAD(MRANDOM(0,360)), RAD(0))*CF(0,0,MRANDOM(2,20))
			local TIMER = MRANDOM(30,50)/4
			WACKYEFFECT({Time = TIMER, EffectType = "Sphere", Size = VT(5,0,5)/1.1, Size2 = VT(0,15,0)/1.1, Transparency = .9, Transparency2 = 0, CFrame = AREA, MoveToPos = AREA.p+VT(0,MRANDOM(35,60),0), RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = C3(.5,0,1), SoundID = nil, SoundPitch = 0.8, SoundVolume = 5})
			WACKYEFFECT({Time = TIMER, EffectType = "Sphere", Size = VT(5,0,5), Size2 = VT(0,15,0), Transparency = 0.9, Transparency2 = 0.5, CFrame = AREA, MoveToPos = AREA.p+VT(0,MRANDOM(35,60),0), RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = C3(0,0,0), SoundID = nil, SoundPitch = 0.8, SoundVolume = 5})
			
end	
		if mememode == false then
SetTween(RJW,{C0=RootCF*CFrame.new(0,0,3)*angles(math.rad(-40),math.rad(0),math.rad(0))},"Quad","InOut",.4)
SetTween(NeckW,{C0=NeckCF*CFrame.new(0,0,2)*angles(math.rad(-20),math.rad(0),math.rad(0))},"Quad","InOut",.4)
SetTween(RW,{C0=CFrame.new(3.5 , 0.5, -3.5)*angles(math.rad(-70),math.rad(0),math.rad(30))},"Quad","InOut",.4)
SetTween(LW,{C0=CFrame.new(-3.5, 0.5, -3.5)*angles(math.rad(-70),math.rad(0),math.rad(-30))},"Quad","InOut",.4)
SetTween(RH,{C0=CFrame.new(0, -3, -3)*angles(math.rad(50),math.rad(0),math.rad(0))},"Quad","InOut",.4)
SetTween(LH,{C0=CFrame.new(-0, -3, -3)*angles(math.rad(50),math.rad(0),math.rad(-0))},"Quad","InOut",.4)

						for i = 10, 30,10 do
							WACKYEFFECT({Time = 20+i, EffectType = "Wave", Size = VT(5,0,5), Size2 = (VT(31,0,31)*7)/4.1, Transparency = 0.4, Transparency2 = 1, CFrame = RootPart.CFrame*cn(0,5,0) * ANGLES(RAD(MRANDOM(0,15)), RAD(MRANDOM(0,360)), RAD(MRANDOM(0,15))), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = C3(1,1,1), SoundID = nil, SoundPitch = 1, SoundVolume = 5})
						end
						WACKYEFFECT({Time = 120, EffectType = "Sphere", Size = VT(0,0,0), Size2 = VT(600,600,600), Transparency = 0.4, Transparency2 = 1, CFrame = RootPart.CFrame, MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = C3(.5,0,1), SoundID = 376976397, SoundPitch = .5, SoundVolume = 7})
						WACKYEFFECT({Time = 100, EffectType = "Sphere", Size = VT(0,0,0), Size2 = VT(600,600,600), Transparency = 0, Transparency2 = 1, CFrame=RootPart.CFrame, MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = C3(0,0,0), SoundID = 528589382, SoundPitch = 1.5, SoundVolume = 10})
	WACKYEFFECT({Time = 120, EffectType = "Crown", Size = VT(0,0,0), Size2 = (VT(600,600,600)), Transparency = 0.5, Transparency2 = 1, CFrame = RootPart.CFrame , MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = C3(0,0,0), SoundID = nil, SoundPitch = 1, SoundVolume = 5,TweenNType="Quad",TweenOType="Out"})
						
CFMagniDamage(Head.CFrame,600,80,90,100,"Knockdown")



else






SetTween(RJW,{C0=RootCF*CFrame.new(0,0,3)*angles(math.rad(-40),math.rad(0),math.rad(0))},"Quad","InOut",.4)
SetTween(NeckW,{C0=NeckCF*CFrame.new(0,0,2)*angles(math.rad(-20),math.rad(0),math.rad(0))},"Quad","InOut",.4)
SetTween(RW,{C0=CFrame.new(3.5 , 0.5, -3.5)*angles(math.rad(-70),math.rad(0),math.rad(30))},"Quad","InOut",.4)
SetTween(LW,{C0=CFrame.new(-3.5, 0.5, -3.5)*angles(math.rad(-70),math.rad(0),math.rad(-30))},"Quad","InOut",.4)
SetTween(RH,{C0=CFrame.new(0, -3, -3)*angles(math.rad(50),math.rad(0),math.rad(0))},"Quad","InOut",.4)
SetTween(LH,{C0=CFrame.new(-0, -3, -3)*angles(math.rad(50),math.rad(0),math.rad(-0))},"Quad","InOut",.4)


						WACKYEFFECT({Time = 120*2, EffectType = "Sphere", Size = VT(0,0,0), Size2 = VT(1600,1600,1600), Transparency = 0.4, Transparency2 = 1, CFrame = RootPart.CFrame, MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = C3(.5,0,1), SoundID = 376976397, SoundPitch = .5, SoundVolume = 5})
						WACKYEFFECT({Time = 100*2, EffectType = "Sphere", Size = VT(0,0,0), Size2 = VT(1600,1600,1600), Transparency = 0, Transparency2 = 1, CFrame=RootPart.CFrame, MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = C3(0,0,0), SoundID = 132164034, SoundPitch = 1.2, SoundVolume = 10})
					for i = 10, 60,10 do
							WACKYEFFECT({Time = 20+i*2, EffectType = "Wave", Size = VT(5,0,5), Size2 = (VT(31,0,31)*7)/4.1, Transparency = 0.4, Transparency2 = 1, CFrame = RootPart.CFrame*cn(0,5,0) * ANGLES(RAD(MRANDOM(0,15)), RAD(MRANDOM(0,360)), RAD(MRANDOM(0,15))), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = C3(1,1,1), SoundID = nil, SoundPitch = 1, SoundVolume = 5})
		WACKYEFFECT({Time = 12*i, EffectType = "Crown", Size = VT(0,0,0), Size2 = (VT(1600,1600,1600)), Transparency = 0.5, Transparency2 = 1, CFrame = RootPart.CFrame , MoveToPos = nil, RotationX = 0, RotationY = math.random(-180,180), RotationZ = 0, Material = "Neon", Color = C3(0,0,0), SoundID = nil, SoundPitch = 1, SoundVolume = 5,TweenNType="Quad",TweenOType="Out"})
	
	CFMagniDamage(Head.CFrame,1600,80,90,100,"Knockdown")					
						wait(.05)
						end						










end

wait(1)





attack=false	
end


function Attack2()
attack = true

SetTween(RJW,{C0=RootCF*CFrame.new(0,0,2)*angles(math.rad(-0),math.rad(0),math.rad(0))},"Quad","InOut",.4)
SetTween(NeckW,{C0=NeckCF*CFrame.new(0,0,2)*angles(math.rad(-0),math.rad(0),math.rad(0))},"Quad","InOut",.4)
SetTween(RW,{C0=CFrame.new(3.5 , 2.5, -0)*angles(math.rad(90),math.rad(0),math.rad(0))},"Back","Out",.4)
SetTween(LW,{C0=CFrame.new(-3.5, 2.5, -0)*angles(math.rad(-0),math.rad(0),math.rad(-30))},"Quad","InOut",.4)
SetTween(RH,{C0=CFrame.new(0, -3, -3)*angles(math.rad(0),math.rad(0),math.rad(0))},"Quad","InOut",.4)
SetTween(LH,{C0=CFrame.new(-0, -3, -3)*angles(math.rad(0),math.rad(0),math.rad(-0))},"Quad","InOut",.4)





wait(.3)


SetTween(RJW,{C0=RootCF*CFrame.new(0,-5,2)*angles(math.rad(-0),math.rad(0),math.rad(0))},"Quad","InOut",.2)
SetTween(NeckW,{C0=NeckCF*CFrame.new(0,0,2)*angles(math.rad(20),math.rad(40),math.rad(0))},"Quad","InOut",.2)
SetTween(RW,{C0=CFrame.new(3.5 , -4.5, -10)*angles(math.rad(90),math.rad(0),math.rad(0))},"Quad","InOut",.2)
SetTween(LW,{C0=CFrame.new(-3.5, 2.5, 2)*angles(math.rad(-30),math.rad(0),math.rad(-30))},"Quad","InOut",.2)
SetTween(RH,{C0=CFrame.new(0, -3, -3)*angles(math.rad(-90),math.rad(-40),math.rad(20))},"Quad","InOut",.2)
SetTween(LH,{C0=CFrame.new(-0, -3, -3)*angles(math.rad(0),math.rad(0),math.rad(-0))},"Quad","InOut",.2)




	--	LAP.Parent = Character	
wait(.1)
local portal =Instance.new("Part")
		portal.Reflectance = 0
		portal.Transparency = 1
		portal.CanCollide = false
		portal.Locked = true
		portal.Anchored=true
		portal.BrickColor = BrickColor.new("Really blue")
		portal.Name = "portal"
		portal.Size = Vector3.new()
		portal.Material = "SmoothPlastic"
		portal:BreakJoints()	
		portal.CFrame = RootPart.CFrame*cn(4,0,-17)
		   local Portalfloor,PortalPos = rayCast(portal.Position, CFrame.new(portal.Position, portal.Position - Vector3.new(0, 1, 0)).lookVector, 80, Character)
portal.CFrame = cn(PortalPos)
			
						local max = 50
							local min = 6.5
							local light = min
							if mememode == true then	
							min = 0
							max = 100
							light = 3
							end		

	coroutine.resume(coroutine.create(function()
		WACKYEFFECT({Time = 120, EffectType = "Crown", Size = VT(0,0,0), Size2 = (VT(max+15,1,max+15)), Transparency = 0.9, Transparency2 = 1, CFrame = portal.CFrame , MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = C3(0,0,0), SoundID = nil, SoundPitch = 1, SoundVolume = 5,TweenNType="Quad",TweenOType="Out"})
						WACKYEFFECT({Time = 240, EffectType = "Sphere", Size = VT(0,.1,0), Size2 = VT(light-.5,0.1,light-.5)*1.5, Transparency = 0, Transparency2 = 1, CFrame=portal.CFrame*cn(0,-0,0), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = C3(1,1,1), SoundID = 376976397, SoundPitch = 1, SoundVolume = 3,TweenNType="Back",TweenOType="Out"})
		wait(120/60)
		
		coroutine.resume(coroutine.create(function()
			wait(.1)
				for _,c in pairs(workspace:children()) do			
		
		
		

		
		
		
					

	

	if h ~= nil and head ~= nil then
				local targ = head.Position - portal.Position
							local mag = targ.magnitude

							
				if mag < max and mag > min  and c ~= Character then
			
print("Kill")
	coroutine.resume(coroutine.create(function()
local Shade =Instance.new("Model",Effects)
local hed =Instance.new("Part")
		hed.Reflectance = 0
		hed.Transparency = 1
		hed.CanCollide = false
		hed.Locked = true
		hed.Anchored=false
		hed.Color = Color3.new(0,0,0)
		head.Material = "SmoothPlastic"
local sTor=hed:Clone()
		sTor.Name = "Torso2"
		sTor.Size = Vector3.new(2,2,1)
		sTor.Material = "SmoothPlastic"
		sTor:BreakJoints()	
		sTor.CFrame = portal.CFrame*cn(0,-10,0)
local sraor=hed:Clone()
		sraor.Name = "RightArm"
		sraor.Size = Vector3.new(1,2,1)
		sraor.Material = "SmoothPlastic"
		sraor:BreakJoints()	
		sraor.CFrame = portal.CFrame*cn(0,-10,0)
local slaor=sraor:Clone()
slaor.Name = "LeftArm"
local srlor=sraor:Clone() 
srlor.Name = "RightLeg"
local sllor=sraor:Clone() 
sllor.Name = "LeftLeg"
		hed.Name = "Head2"
		hed.Size = Vector3.new(1,1,1)
		hed.Material = "SmoothPlastic"
		hed:BreakJoints()	
		hed.CFrame = portal.CFrame*cn(0,-10,0)

 local Mesh =Instance.new("SpecialMesh",hed)

Mesh.Scale=Vector3.new(1.25,1.25,1.25)
coroutine.resume(coroutine.create(function()
local Eye = Instance.new("Part")
		Eye.Reflectance = 0
		Eye.Transparency = 0
		Eye.CanCollide = false
		Eye.Locked = true
		Eye.Anchored=false
		Eye.BrickColor = BrickColor.new("White")
		Eye.Name = "BEGONE"
		Eye.Size = Vector3.new(0.05,0.3,0.05)
		Eye.Material = "Neon"
		Eye:BreakJoints()
		Eye.Parent = Shade
 local EMesh =Instance.new("SpecialMesh",Eye)

EMesh.MeshType = "Sphere"
	



local Eye=weld(Eye,hed,Eye,cf(.18,.18,-.55))

end))
coroutine.resume(coroutine.create(function()
local Eye = Instance.new("Part")
		Eye.Reflectance = 0
		Eye.Transparency = 0
		Eye.CanCollide = false
		Eye.Locked = true
		Eye.Anchored=false
		Eye.BrickColor = BrickColor.new("White")
		Eye.Name = "BEGONE"
		Eye.Size = Vector3.new(.05,.3,.05)
		Eye.Material = "Neon"
		Eye:BreakJoints()
		Eye.Parent = Shade

		
 local EMesh =Instance.new("SpecialMesh",Eye)

EMesh.MeshType = "Sphere"


local Eye=weld(Eye,hed,Eye,cf(-.18,.18,-.55))

end))

sTor.Anchored = true
hed.Parent = Shade
sTor.Parent = Shade
sraor.Parent = Shade
slaor.Parent = Shade
srlor.Parent = Shade
sllor.Parent = Shade


SetTween(sTor,{Transparency=0},"Quad","InOut",1)
SetTween(hed,{Transparency=0},"Quad","InOut",1)
SetTween(sraor,{Transparency=0},"Quad","InOut",1)
SetTween(slaor,{Transparency=0},"Quad","InOut",1)
SetTween(srlor,{Transparency=0},"Quad","InOut",1)
SetTween(sllor,{Transparency=0},"Quad","InOut",1)





local NeckW2=MakeJoint(sTor,sTor,hed,CFrame.new(0,0,0))
NeckW2.C1 = NeckW.C1

--print(WRJ.Parent.Name)

local RW2=MakeJoint(sTor,sTor,sraor,cf(0,0,0))

local LW2=MakeJoint(sTor,sTor,slaor,cf(0,0,0))

local RH2=MakeJoint(sTor,sTor,srlor,cf(0,0,0))

local LH2=MakeJoint(sTor,sTor,sllor,cf(0,0,0))



RW2.C1 = cn(0, 0.5, 0)
LW2.C1 = cn(0, 0.5, 0)
RH2.C1 = cn(0, 1, 0) *CFrame.Angles(math.rad(0),math.rad(0),math.rad(0))
LH2.C1 = cn(0, 1, 0) *CFrame.Angles(math.rad(0),math.rad(0),math.rad(0))




head.Anchored = true

--------
--(#Torso)
SetTween(sTor,{CFrame=cn(head.Position.x,portal.Position.y-5,head.Position.z)},"Quad","InOut", .1)
--------
--(#Head)
SetTween(NeckW2,{C0=NeckCF*CFrame.new(0,0,0)},"Quad","InOut",0.1)
--------
--(#Right Arm)
SetTween(RW2,{C0=CFrame.new(1.5 , 0.5, -.0)},"Quad","InOut",0.1)
--------
--(#Left Arm)
SetTween(LW2,{C0=CFrame.new(-1.5, 0.5, -.0)},"Quad","InOut",0.1)
--------
--(#Right Leg)
SetTween(RH2,{C0=CFrame.new(.5, -0.90, 0)},"Quad","InOut",0.1)
--------
--(#Left Leg)
SetTween(LH2,{C0=CFrame.new(-.5, -0.90, 0)},"Quad","InOut",0.1)


wait(.1)


--------
--(#Torso)
SetTween(sTor,{CFrame=head.CFrame*CFrame.new(0,0,2)},"Quad","InOut",1/2)
--------
--(#Head)
SetTween(NeckW2,{C0=NeckCF*CFrame.new(0,0,0)*angles(math.rad(-40),math.rad(0),math.rad(0))},"Quad","InOut",1/2)
--------
--(#Right Arm)
SetTween(RW2,{C0=CFrame.new(1.5 , 0.5, -.0)},"Quad","InOut",1/2)
--------
--(#Left Arm)
SetTween(LW2,{C0=CFrame.new(-1.5, 0.5, -.0)},"Quad","InOut",1/2)

wait(1/2)
--------
--(#Torso)
SetTween(sTor,{CFrame=head.CFrame*CFrame.new(0,0,1)},"Quad","InOut",1/3)
--------
--(#Head)
SetTween(NeckW2,{C0=NeckCF*CFrame.new(0,0,0)*angles(math.rad(0),math.rad(30),math.rad(0))},"Quad","InOut",1/3)
--------
--(#Right Arm)
SetTween(RW2,{C0=CFrame.new(1.5 , 0.5, -.0)*angles(math.rad(90),math.rad(0),math.rad(0))},"Quad","InOut",1/3)
--------
--(#Left Arm)
SetTween(LW2,{C0=CFrame.new(-1.5, 0.5, -.0)*angles(math.rad(90),math.rad(0),math.rad(0))},"Quad","InOut",1/3)

wait(1/3)
--------
local Grab=MakeJoint(sTor,sTor,head,cf(0,0,-1))
head.Anchored = false
--(#Torso)

--------
--(#Head)
SetTween(NeckW2,{C0=NeckCF*CFrame.new(0,0,0)*angles(math.rad(0),math.rad(30),math.rad(0))},"Quad","InOut",1/3)
--------
--(#Right Arm)
SetTween(RW2,{C0=CFrame.new(1.3 , 0.5, -.3)*angles(math.rad(90),math.rad(0),math.rad(-50))},"Quad","InOut",1/3)
--------
--(#Left Arm)
SetTween(LW2,{C0=CFrame.new(-1.3, 0.5, -.3)*angles(math.rad(90),math.rad(0),math.rad(50))},"Quad","InOut",1/3)

wait(1/3)
		WACKYEFFECT({Time = 40, EffectType = "Crown", Size = VT(1,16,1), Size2 = (VT(10,0,10)), Transparency = 0.2, Transparency2 = 1, CFrame = cn(head.Position.x,portal.Position.y,head.Position.z) , MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = C3(0,0,0), SoundID = nil, SoundPitch = 1, SoundVolume = 5})
		
SetTween(sTor,{CFrame=cn(head.Position.x,portal.Position.y-5,head.Position.z)},"Quad","InOut", .2)

wait(.2)

Shade:Destroy()
coroutine.resume(coroutine.create(function()
c:BreakJoints()
end))
c.Parent = nil
h:Destroy()
c:Destroy()


end))

				end
				end
				end
		end))
		--CFMagniDamage(portal.CFrame,60,10,20,0,"Normal")

								WACKYEFFECT({Time = 160, EffectType = "Sphere", Size = VT(max+15,1,max+15)*1.5, Size2 = VT(0,.05,0), Transparency = 1, Transparency2 = 0, CFrame=portal.CFrame*cn(0,-0.025,0), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = C3(0,0,0), SoundID = 424195979, SoundPitch = .5, SoundVolume = 4,TweenNType="Quad",TweenOType="InOut"})
		portal:Destroy()	
	end))




wait(.3)



attack=false	
end




--[[
SetTween(RJW,{C0=RootCF*CFrame.new(0,0,0)*angles(math.rad(0),math.rad(0),math.rad(0))},"Quad","InOut",0.1)
SetTween(NeckW,{C0=NeckCF*CFrame.new(0,0,2)*angles(math.rad(0),math.rad(0),math.rad(0))},"Quad","InOut",0.1)
SetTween(RW,{C0=CFrame.new(3.5 , 0.5, -.0)*angles(math.rad(0),math.rad(0),math.rad(30))},"Quad","Out",0.1)
SetTween(LW,{C0=CFrame.new(-3.5, 0.5, -.0)*angles(math.rad(0),math.rad(0),math.rad(-30))},"Quad","Out",0.1)
SetTween(RH,{C0=CFrame.new(0, -3, 0)*angles(math.rad(0),math.rad(0),math.rad(0))},"Quad","InOut",0.1)
SetTween(LH,{C0=CFrame.new(-0, -3, 0)*angles(math.rad(0),math.rad(0),math.rad(0))},"Quad","InOut",0.1)
--]]



function AT1()
attack = true	


SetTween(RJW,{C0=RootCF*CFrame.new(0,0,2)*angles(math.rad(-50),math.rad(40),math.rad(80))},"Quad","InOut",.3)
SetTween(NeckW,{C0=NeckCF*CFrame.new(0,0,2)*angles(math.rad(50),math.rad(-40),math.rad(-40))},"Quad","InOut",.3)
SetTween(RW,{C0=CFrame.new(3.5 , 0.5, -.0)*angles(math.rad(40),math.rad(-30),math.rad(-25))},"Quad","Out",.3)
SetTween(LW,{C0=CFrame.new(-3.5, 5.5, -.0)*angles(math.rad(-78),math.rad(0),math.rad(-120))},"Quad","Out",.3)
SetTween(RH,{C0=CFrame.new(0, -3, 0)*angles(math.rad(50),math.rad(45),math.rad(0))},"Quad","InOut",.3)
SetTween(LH,{C0=CFrame.new(-0, -3, 0)*angles(math.rad(90),math.rad(0),math.rad(0))},"Quad","InOut",.3)	
wait(.3)	
	so("160773067", RootPart, 1.5, math.random(120,150)/100)
SetTween(RJW,{C0=RootCF*CFrame.new(0,0,2)*angles(math.rad(0),math.rad(0),math.rad(-40))},"Quad","InOut",.15)
SetTween(NeckW,{C0=NeckCF*CFrame.new(0,0,2)*angles(math.rad(0),math.rad(0),math.rad(40))},"Quad","InOut",.15)
SetTween(RW,{C0=CFrame.new(3.5 , 0.5, -.0)*angles(math.rad(-0),math.rad(-50),math.rad(90))},"Quad","Out",.15)
SetTween(LW,{C0=CFrame.new(-3.5, 2.5, -.0)*angles(math.rad(0),math.rad(0),math.rad(-30))},"Quad","Out",.15)
SetTween(RH,{C0=CFrame.new(0, -3, 0)*angles(math.rad(0),math.rad(0),math.rad(0))},"Quad","InOut",.15)
SetTween(LH,{C0=CFrame.new(-0, -3, 0)*angles(math.rad(0),math.rad(0),math.rad(0))},"Quad","InOut",.15)	
wait(.15/2)

CFMagniDamage(RootPart.CFrame*cn(4,0,-4),12.5,10,20,20,"HPSteal")

wait(.15/2)	




attack = false	
end


function AT2()
attack = true	
	
SetTween(RJW,{C0=RootCF*CFrame.new(0,0,2)*angles(math.rad(-50),math.rad(-40),math.rad(-80))},"Quad","InOut",.3)
SetTween(NeckW,{C0=NeckCF*CFrame.new(0,0,2)*angles(math.rad(50),math.rad(40),math.rad(40))},"Quad","InOut",.3)
SetTween(RW,{C0=CFrame.new(3.5 , 5.5, -.0)*angles(math.rad(-78),math.rad(0),math.rad(120))},"Quad","Out",.3)
SetTween(LW,{C0=CFrame.new(-3.5, 0.5, -.0)*angles(math.rad(40),math.rad(30),math.rad(25))},"Quad","Out",.3)
SetTween(RH,{C0=CFrame.new(0, -3, 0)*angles(math.rad(90),math.rad(0),math.rad(0))},"Quad","InOut",.3)
SetTween(LH,{C0=CFrame.new(-0, -3, 0)*angles(math.rad(50),math.rad(-45),math.rad(0))},"Quad","InOut",.3)	
wait(.3)	
	so("160773067", RootPart, 1.5, math.random(120,150)/100)
SetTween(RJW,{C0=RootCF*CFrame.new(0,0,2)*angles(math.rad(0),math.rad(0),math.rad(40))},"Quad","InOut",.15)
SetTween(NeckW,{C0=NeckCF*CFrame.new(0,0,2)*angles(math.rad(0),math.rad(0),math.rad(-40))},"Quad","InOut",.15)
SetTween(RW,{C0=CFrame.new(3.5 , 2.5, -.0)*angles(math.rad(-0),math.rad(0),math.rad(30))},"Quad","Out",.15)
SetTween(LW,{C0=CFrame.new(-3.5, 0.5, -.0)*angles(math.rad(0),math.rad(50),math.rad(-90))},"Quad","Out",.15)
SetTween(RH,{C0=CFrame.new(0, -3, 0)*angles(math.rad(0),math.rad(0),math.rad(0))},"Quad","InOut",.15)
SetTween(LH,{C0=CFrame.new(-0, -3, 0)*angles(math.rad(0),math.rad(0),math.rad(0))},"Quad","InOut",.15)	
wait(.15/2)

CFMagniDamage(RootPart.CFrame*cn(-4,0,-4),12.5,10,20,50,"HPSteal")

wait(.15/2)	



	
attack = false	
end

function findNearestTorso(pos)
	local list = game.Workspace:children()
	local torso = nil
	local dist = 1000
	local temp = nil
	local human = nil
	local temp2 = nil
	for x = 1, #list do
		temp2 = list[x]
		if (temp2.className == "Model") and (temp2 ~= Character) then
			temp = (temp2:FindFirstChild("Torso") or temp2:FindFirstChild("UpperTorso"))
			human = temp2:FindFirstChildOfClass("Humanoid")
			if (temp ~= nil) and (human ~= nil) and (human.Health > 0) then
				if (temp.Position - pos).magnitude < dist then
					torso = temp
					dist = (temp.Position - pos).magnitude
				end
			end
		end
	end
	return torso
end

function Attack3()
attack = true	
	
SetTween(RJW,{C0=RootCF*CFrame.new(0,0,2)*angles(math.rad(0),math.rad(0),math.rad(0))},"Quad","InOut",.4)
SetTween(NeckW,{C0=NeckCF*CFrame.new(0,0,2)*angles(math.rad(0),math.rad(0),math.rad(0))},"Quad","InOut",.4)
SetTween(RW,{C0=CFrame.new(3.5 , 0.5, -.0)*angles(math.rad(90),math.rad(0),math.rad(0))},"Quad","Out",.4)
SetTween(LW,{C0=CFrame.new(-3.5, 0.5, -.0)*angles(math.rad(90),math.rad(0),math.rad(-0))},"Quad","Out",.4)
SetTween(RH,{C0=CFrame.new(0, -3, 0)*angles(math.rad(0),math.rad(0),math.rad(0))},"Quad","InOut",.4)
SetTween(LH,{C0=CFrame.new(-0, -3, 0)*angles(math.rad(0),math.rad(0),math.rad(0))},"Quad","InOut",.4)	
wait(.05)
		
SetTween(RJW,{C0=RootCF*CFrame.new(0,0,2)*angles(math.rad(0),math.rad(0),math.rad(0))},"Quad","InOut",.3)
SetTween(NeckW,{C0=NeckCF*CFrame.new(0,0,2)*angles(math.rad(0),math.rad(0),math.rad(0))},"Quad","InOut",.3)
SetTween(RW,{C0=CFrame.new(3.5 , 3.5, -.0)*angles(math.rad(0),math.rad(0),math.rad(80))},"Quad","Out",.3)
SetTween(LW,{C0=CFrame.new(-3.5, 3.5, -.0)*angles(math.rad(0),math.rad(0),math.rad(-80))},"Quad","Out",.3)
SetTween(RH,{C0=CFrame.new(0, -3, 0)*angles(math.rad(0),math.rad(-90),math.rad(0))},"Quad","InOut",.3)
SetTween(LH,{C0=CFrame.new(-0, -3, 0)*angles(math.rad(0),math.rad(90),math.rad(-0))},"Quad","InOut",.3)	
wait(.3)	
	so("260435136", RootPart, 2, .8)
SetTween(RJW,{C0=RootCF*CFrame.new(0,0,2)*angles(math.rad(0),math.rad(0),math.rad(0))},"Quad","InOut",.3)
SetTween(NeckW,{C0=NeckCF*CFrame.new(0,-5,2)*angles(math.rad(30),math.rad(-40),math.rad(0))},"Quad","InOut",.3)
SetTween(RW,{C0=CFrame.new(6.0 , -2, -8)*angles(math.rad(85),math.rad(0),math.rad(-80))},"Quad","Out",.3)
SetTween(LW,{C0=CFrame.new(-6.0, -2, -8)*angles(math.rad(90),math.rad(0),math.rad(80))},"Quad","Out",.3)
SetTween(RH,{C0=CFrame.new(0, -3, 0)*angles(math.rad(0),math.rad(-90),math.rad(0))},"Quad","InOut",.3)
SetTween(LH,{C0=CFrame.new(-0, -3, 0)*angles(math.rad(0),math.rad(90),math.rad(-0))},"Quad","InOut",.3)	
wait(.3)

	
	  local TheGunHandle = Instance.new("Part")
		TheGunHandle.Reflectance = 0
		TheGunHandle.Transparency = 1
		TheGunHandle.CanCollide = false
		TheGunHandle.Locked = true
		TheGunHandle.Anchored=false
		TheGunHandle.BrickColor = BrickColor.new("Really blue")
		TheGunHandle.Name = "BHandle"
		TheGunHandle.Size = Vector3.new(2.5,1,2.5)
		TheGunHandle.Material = "SmoothPlastic"
		TheGunHandle:BreakJoints()
		TheGunHandle.Parent = workspace		
		TheGunHandle.CFrame = RootPart.CFrame	
		
		
		local SWeld=weld(TheGunHandle,RootPart,TheGunHandle,cf(0,0,-9)*angles(math.rad(0),math.rad(0),math.rad(0)))
		local IsHit = false
local function onTouch(HitPa)
	if IsHit == false then
		local c = HitPa.Parent
				local h = HitPa.Parent:FindFirstChild("Humanoid")
	for _,v in pairs(HitPa.Parent:children()) do
		if v:IsA("Humanoid") then
	
				h = v end
		
	end
		local head = c:FindFirstChild("Torso") or c:FindFirstChild("UpperTorso")
		local realhead = c:FindFirstChild("Head")
	if h ~= nil and head ~= nil and realhead ~= nil then
	
	IsHit = true
	RootPart.Anchored=true
  SetTween(NeckW,{C0=NeckCF*CFrame.new(0,-5,2)*angles(math.rad(30),math.rad(40),math.rad(0))},"Quad","InOut",3)
			local SWeld=MakeJoint(head,Torso,head,cf(0,-1,-9)*angles(math.rad(180),math.rad(0),math.rad(180)))
			
	coroutine.resume(coroutine.create(function()		
local pem = VoidEmitter:Clone()		
pem.Enabled = true			
pem.Parent = realhead			
	so("2162238854", RootPart, 2, .5)
	wait(2.9)
		if mememode == false then
			wait(.1)
		end
	pem.Rate = 0	
	if mememode == true then
		coroutine.resume(coroutine.create(function()	
	
local	Dust = Instance.new("Model") 
local DustTorso = Instance.new("Part",Dust) 
local DustHead = Instance.new("Part",Dust) 
game:GetService("Debris"):AddItem(DustHead, 120)
DustHead.Name = "Head"
DustHead.Size = Vector3.new(realhead.Size.y,realhead.Size.y,realhead.Size.y)
RemoveOutlines(DustHead)
DustHead:BreakJoints()
DustHead.CFrame = CFrame.new(0,1000,0)		
DustHead.Transparency = 1
DustTorso.Name = "Torso"
DustTorso.Size = Vector3.new(realhead.Size.y,realhead.Size.y,realhead.Size.y)
RemoveOutlines(DustTorso)
DustTorso:BreakJoints()
DustTorso.CFrame = CFrame.new(0,1000,0)
DustTorso.Transparency = 1
Dust.Name = "DustMinion"










pem.Parent = DustHead
pem.Rate = 100

local DustWeld=weld(DustTorso,DustHead,DustTorso,cf(0,0,0))
DustTorso.CFrame = realhead.CFrame
wait(.2)
local DustHumanoid = Instance.new("Humanoid",Dust) 
DustHumanoid.MaxHealth = 40
DustHumanoid.Health = 40
DustHumanoid.WalkSpeed = 17
Dust.Parent = Effects
	
					so("438666001", DustTorso, 2, .8)
			
	
			coroutine.resume(coroutine.create(function()	
			local DustAlive = true	
		
			while DustAlive == true do 
			


if DustHumanoid.Health > 0.001 then



local FindNewTorso = findNearestTorso(DustTorso.Position)

if FindNewTorso ~= nil then
	
	DustHumanoid:MoveTo(FindNewTorso.Position)
	--print(DustHumanoid.Name)
local mag = 	(DustTorso.Position-FindNewTorso.Position).magnitude
if mag < 10 and FindNewTorso.Parent:FindFirstChildOfClass("Humanoid") and FindNewTorso.Parent:FindFirstChildOfClass("Humanoid").Health > 0.001 then


coroutine.resume(coroutine.create(function()
				
			coroutine.resume(coroutine.create(function()
	makrag(FindNewTorso.Parent)
	end))
	FindNewTorso.Parent:FindFirstChildOfClass("Humanoid").Health = 0
		FindNewTorso.Parent:BreakJoints()
if FindNewTorso.Parent:FindFirstChild("Head") then
pem.Parent = FindNewTorso.Parent.Head
pem:Emit(10)	
	so("215395388", DustTorso, 2, .8)
end
end))
DustHumanoid.Health = 0	
end	
	
else
	wait(2)
	DustHumanoid.Health = 0
end


end




			
			if DustHumanoid.Health < 0.001 then
					coroutine.resume(coroutine.create(function()
				pem.Rate = 0
					end))
					DustAlive = false
					game:GetService("Debris"):AddItem(Dust, 2)
	so("2162238854", DustTorso, 2, .8)
			end
			
			
			if Dust.Parent ~= Effects then
			coroutine.resume(coroutine.create(function()	
				Dust:Destroy()
			end))
			DustAlive = false	
			end
			
			
			
			
			
			wait(1)	
			end
			
			
			
			end))
	
	
	
	
	end))
	end
	end))
	
	
	
	wait(3)	
	coroutine.resume(coroutine.create(function()
		head.Velocity = RootPart.CFrame.lookVector * 1.2			
			coroutine.resume(coroutine.create(function()
	makrag(c)
	end))
	h.Health = 0
		c:BreakJoints()
RootPart.CFrame = Torso.CFrame*cn(0,-2,0)		
		RootPart.Anchored=false
end))
		attack = false
		
	end
	
	end	
	end		



wait(1)
coroutine.resume(coroutine.create(function()
	TheGunHandle:Destroy()
end))

if IsHit == false then	
attack = false
end		
end


function Attack4()
	attack=true
SetTween(RJW,{C0=RootCF*CFrame.new(0,0,2)*angles(math.rad(0),math.rad(0),math.rad(0))},"Quad","InOut",.6)
SetTween(NeckW,{C0=NeckCF*CFrame.new(0,0,2)*angles(math.rad(20),math.rad(0),math.rad(0))},"Quad","InOut",.6)
SetTween(RW,{C0=CFrame.new(3.5 , 0.5, -.0)*angles(math.rad(90),math.rad(0),math.rad(50))},"Back","Out",.6)
SetTween(LW,{C0=CFrame.new(-3.5, 0.5, -.0)*angles(math.rad(90),math.rad(0),math.rad(-50))},"Back","Out",.6)
SetTween(RH,{C0=CFrame.new(0, -3, 0)*angles(math.rad(0),math.rad(0),math.rad(0))},"Quad","InOut",.6)
SetTween(LH,{C0=CFrame.new(-0, -3, 0)*angles(math.rad(0),math.rad(0),math.rad(0))},"Quad","InOut",.6)	
wait(.6)	
SetTween(RJW,{C0=RootCF*CFrame.new(0,0,2)*angles(math.rad(30),math.rad(0),math.rad(0))},"Quad","InOut",.4)
SetTween(NeckW,{C0=NeckCF*CFrame.new(0,0,2)*angles(math.rad(-20),math.rad(0),math.rad(0))},"Quad","InOut",.4)
SetTween(RW,{C0=CFrame.new(3.5 , 4.5, 4.0)*angles(math.rad(90),math.rad(0),math.rad(10))},"Quad","Out",.4)
SetTween(LW,{C0=CFrame.new(-3.5, 4.5, 4.0)*angles(math.rad(90),math.rad(0),math.rad(-10))},"Quad","Out",.4)
SetTween(RH,{C0=CFrame.new(0, -3, 0)*angles(math.rad(50),math.rad(0),math.rad(0))},"Quad","InOut",.4)
SetTween(LH,{C0=CFrame.new(-0, -3, 0)*angles(math.rad(50),math.rad(0),math.rad(0))},"Quad","InOut",.4)	
wait(.4)
SetTween(RJW,{C0=RootCF*CFrame.new(0,0,2)*angles(math.rad(0),math.rad(0),math.rad(0))},"Quad","InOut",.2)
SetTween(NeckW,{C0=NeckCF*CFrame.new(0,0,2)*angles(math.rad(60),math.rad(0),math.rad(0))},"Quad","InOut",.2)
SetTween(RW,{C0=CFrame.new(3.5 , 0.5, -.0)*angles(math.rad(30),math.rad(0),math.rad(-20))},"Back","Out",.2)
SetTween(LW,{C0=CFrame.new(-3.5, 0.5, -.0)*angles(math.rad(30),math.rad(0),math.rad(20))},"Back","Out",.2)
SetTween(RH,{C0=CFrame.new(0, -3, 0)*angles(math.rad(0),math.rad(0),math.rad(0))},"Quad","InOut",.2)
SetTween(LH,{C0=CFrame.new(-0, -3, 0)*angles(math.rad(0),math.rad(0),math.rad(0))},"Quad","InOut",.2)
wait(.2)
	
local pilarsize= 1

if mememode == true then
	pilarsize= 3
end	






		WACKYEFFECT({Time = 30, EffectType = "Crown", Size = VT(9,0,9)*pilarsize, Size2 = (VT(10.5,110,10.5)*pilarsize), Transparency = 0.2, Transparency2 = 1, CFrame = RootPart.CFrame*cn(0,-3,-6)*angles(RAD(40),0,0), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = C3(0,0,0), SoundID = 357540482, SoundPitch = 1.8/(pilarsize/2), SoundVolume = 2*pilarsize})
			


coroutine.resume(coroutine.create(function()	
	wait(.1)
		local RPP = RootPart.Position + Vector3.new(0,5,0)
	local lookv= RootPart.CFrame.lookVector
	coroutine.resume(coroutine.create(function()
	for i = 1,10,1 do 
local attackP = RPP+lookv*i*(15*pilarsize)
local attackCF = CF(attackP,attackP+lookv*5)
			   local Portalfloor,PortalPos,test1 = rayCast(attackP, CFrame.new(attackP, attackP - Vector3.new(0, 1, 0)).lookVector, 80, Character)

local PortalPosCF = CF(PortalPos,PortalPos+test1)*ANGLES(RAD(-90+math.random(-10,10)),RAD(math.random(-360,360)),RAD(math.random(-10,10)))
	if PortalPosCF ~= nil then
	local Pillar = Instance.new("Part")
		Pillar.Reflectance = 0
		Pillar.Transparency = 0
		Pillar.CanCollide = true
		Pillar.Locked = true
		Pillar.Anchored=true
		Pillar.BrickColor = BrickColor.new("White")
		Pillar.Name = "Pillar"
		Pillar.Size = Vector3.new(8.108, 29.681, 8.108)*pilarsize
		Pillar.Material = "Concrete"
		Pillar:BreakJoints()
		Pillar.Parent = Effects
		Pillar.CFrame = PortalPosCF*cn(0,-30*pilarsize,0)
		local NewPillarMesh = Instance.new("SpecialMesh")
NewPillarMesh.Parent = Pillar
NewPillarMesh.MeshId = "http://www.roblox.com/asset/?id=2449719398"
NewPillarMesh.TextureId = "http://www.roblox.com/asset/?id=1693385655"
NewPillarMesh.Scale = Vector3.new(1,1,1)*pilarsize
NewPillarMesh.VertexColor = Vector3.new(23/255, 21/255, 29/255)
NewPillarMesh.MeshType = Enum.MeshType.FileMesh	
		
		SetTween(Pillar,{CFrame=PortalPosCF*cn(0,12*pilarsize,0)},"Quad","Out",.5)
		coroutine.resume(coroutine.create(function()
		wait(math.random(3,6))
		SetTween(Pillar,{CFrame=PortalPosCF*cn(0,-30*pilarsize,0)*ANGLES(RAD(math.random(-90,90)),RAD(math.random(-360,360)),RAD(math.random(-90,90)))},"Bounce","In",2)
			Pillar.CanCollide = false
			wait(1.5)
				CFMagniDamage(cn(PortalPos),18*pilarsize,20*pilarsize,30*pilarsize,50*pilarsize,"Knockdown")

						WACKYEFFECT({Time = 50, EffectType = "Crown", Size = VT(15,0,15)*pilarsize, Size2 = (VT(19,120,19)*pilarsize), Transparency = 0.6, Transparency2 = 1, CFrame = CF(PortalPos,PortalPos+test1)*ANGLES(RAD(-90),RAD(math.random(-360,360)),RAD(0)) , MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = C3(0,0,0), SoundID = 1788899396, SoundPitch = 1/(pilarsize/2), SoundVolume = 3*pilarsize})
	
					SetTween(Pillar,{Transparency=1},"Quad","Out",2)
					wait(4)
			Pillar:Destroy()
		end))
		CFMagniDamage(cn(PortalPos),16*pilarsize,10*pilarsize,20*pilarsize,-20*pilarsize,"NormalKnockdown")

			WACKYEFFECT({Time = 40, EffectType = "Crown", Size = VT(9,0,9)*pilarsize, Size2 = (VT(4.5,160,4.5)*pilarsize), Transparency = 0.2, Transparency2 = 1, CFrame = PortalPosCF, MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = C3(0,0,0), SoundID = 2175667385, SoundPitch = 0.8/(pilarsize/2), SoundVolume = 2*pilarsize})
			WACKYEFFECT({Time = 40, EffectType = "Crown", Size = VT(4.5,40,4.5)*pilarsize, Size2 = (VT(30,0,30)*pilarsize), Transparency = 0.7, Transparency2 = 1, CFrame = CF(PortalPos,PortalPos+test1)*ANGLES(RAD(-90),RAD(math.random(-360,360)),RAD(0)) , MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = C3(0,0,0), SoundID = nil, SoundPitch = 1, SoundVolume = 3})
	
	end
	
	wait(.05)
	end
	end))
	
	
	
	end))		

SetTween(RJW,{C0=RootCF*CFrame.new(0,0,2)*angles(math.rad(0),math.rad(0),math.rad(0))},"Quad","InOut",.4)
SetTween(NeckW,{C0=NeckCF*CFrame.new(0,0,2)*angles(math.rad(20),math.rad(0),math.rad(0))},"Quad","InOut",.4)
SetTween(RW,{C0=CFrame.new(3.5 , 0.5, -2.0)*angles(math.rad(90),math.rad(0),math.rad(-20))},"Back","Out",.4)
SetTween(LW,{C0=CFrame.new(-3.5, 0.5, -2.0)*angles(math.rad(90),math.rad(0),math.rad(20))},"Back","Out",.4)
SetTween(RH,{C0=CFrame.new(0, -3, 0)*angles(math.rad(0),math.rad(0),math.rad(0))},"Quad","InOut",.4)
SetTween(LH,{C0=CFrame.new(-0, -3, 0)*angles(math.rad(0),math.rad(0),math.rad(0))},"Quad","InOut",.4)
wait(.4)	
attack=false
end










		for i, v in pairs(Head:GetChildren()) do

if v:IsA("BasePart") and v.BrickColor.Name == "Institutional white" then
--v.Name = "Eye"
end


		end




function ClickCombo()
if Anim == "Fall" or Anim == "Jump" then
if Combo == 0 then		
--DownAT()	
end
else				
if Combo == 0 then
AT1()	
Combo = 1
elseif Combo == 1 then
AT2()	
Combo = 0	
elseif Combo == 2 then
AT3()
Combo = 0		
end
end
end

Button1DownF=function()

if attack==false then

ClickCombo()	
else

end	
	
end



KeyUpF=function(key)


	
end

Mouse.KeyDown:Connect(function(key)
key:lower()	
if key == "z" and attack ==false then
Attack1()
end
if key == "x" and attack ==false then
Attack2()
end
if key == "c" and attack ==false then
Attack3()
end
if key == "v" and attack ==false then
Attack4()
end
end)

	


if mememode == false then
	mememode=true
		lastid= "http://www.roblox.com/asset/?id=167664731" --1847367023
		
lastsongpos = 0
s2.TimePosition = lastsongpos
	SetTween(RJW,{C0=RootCF*CFrame.new(0,-2,2)*angles(math.rad(30),math.rad(0),math.rad(0))},"Quad","InOut",1)
SetTween(NeckW,{C0=NeckCF*CFrame.new(0,0,-2)*angles(math.rad(20),math.rad(0),math.rad(0))},"Quad","InOut",1)
SetTween(RW,{C0=CFrame.new(2.5 , 3.5, 1.5)*angles(math.rad(30),math.rad(0),math.rad(60))},"Quad","InOut",1)
SetTween(LW,{C0=CFrame.new(-2.5, 3.5, 1.5)*angles(math.rad(30),math.rad(0),math.rad(-60))},"Quad","InOut",1)
SetTween(RH,{C0=CFrame.new(0, -3, 0)*angles(math.rad(50),math.rad(0),math.rad(-90))},"Quad","InOut",1)
SetTween(LH,{C0=CFrame.new(-0, -3, 0)*angles(math.rad(50),math.rad(0),math.rad(90))},"Quad","InOut",1)
so("1837106999", Character,1, 1)
wait(1)

	
	lastid= "http://www.roblox.com/asset/?id=1907454616" --1847367023 194920243

lastsongpos = 0
s2.TimePosition = lastsongpos




		for i, v in pairs(Head:GetChildren()) do
if v:IsA("BasePart") and v.BrickColor.Name == "Really black" and v.Name ~= "Head" then

if v.Name == "Handle" then
	v.Transparency=1 	
v.Decal.Transparency=1 	
else
	SetTween(v,{Transparency=1},"Quad","InOut",.1)

end


end
if v:IsA("BasePart") and  (v.Name == "Eye1" or v.Name == "Eye2" )  then
SetTween(v,{Color=Color3.new(1,0,0)},"Quad","InOut",1)

SetTween(v.Mesh,{Scale=Vector3.new(0.8,5.8,.825)},"Quad","InOut",1)


SetTween(v.Mesh,{Offset=Vector3.new(0,-.5,0)},"Quad","InOut",1)



end


		end

coroutine.resume(coroutine.create(function()
 	  local MaskPart = Instance.new("Part")
		MaskPart.Reflectance = 0
		MaskPart.Transparency = 0
		MaskPart.CanCollide = false
		MaskPart.Locked = true
		MaskPart.Anchored=false
		MaskPart.BrickColor = BrickColor.new("Really blue")
		MaskPart.Name = "LMaskPart"
		MaskPart.Size = Vector3.new(.1,.1,.1)
		MaskPart.Material = "SmoothPlastic"
		MaskPart:BreakJoints()
		MaskPart.Parent = Head		
		MaskPart.CFrame = RootPart.CFrame	
		
	local SWeld=weld(MaskPart,Head,MaskPart,cf(-.75,-0,-1.25)*angles(math.rad(0),math.rad(0),math.rad(0)))
	SetTween(SWeld,{C0=CFrame.new(-2.75,0,-1.0)*angles(math.rad(0),math.rad(-15),math.rad(math.random(-15,15)))},"Elastic","Out",1.5)

local NewMaskMesh = Instance.new("SpecialMesh")
NewMaskMesh.Parent = MaskPart
NewMaskMesh.MeshId = "http://www.roblox.com/asset/?id=2349611011"
NewMaskMesh.TextureId = "http://www.roblox.com/asset/?id=2349706532"
NewMaskMesh.Scale = Vector3.new(3, 3.0999999, 3)/10
NewMaskMesh.MeshType = Enum.MeshType.FileMesh		
end))
coroutine.resume(coroutine.create(function()
 	  local MaskPart = Instance.new("Part")
		MaskPart.Reflectance = 0
		MaskPart.Transparency = 0
		MaskPart.CanCollide = false
		MaskPart.Locked = true
		MaskPart.Anchored=false
		MaskPart.BrickColor = BrickColor.new("Really blue")
		MaskPart.Name = "RMaskPart"
		MaskPart.Size = Vector3.new(.1,.1,.1)
		MaskPart.Material = "SmoothPlastic"
		MaskPart:BreakJoints()
		MaskPart.Parent = Head		
		MaskPart.CFrame = RootPart.CFrame	
		
	local SWeld=weld(MaskPart,Head,MaskPart,cf(.75,-0,-1.25)*angles(math.rad(0),math.rad(0),math.rad(0)))
	SetTween(SWeld,{C0=CFrame.new(2.75,0,-1.0)*angles(math.rad(0),math.rad(-15),math.rad(math.random(-15,15)))},"Elastic","Out",1)

local NewMaskMesh = Instance.new("SpecialMesh")
NewMaskMesh.Parent = MaskPart
NewMaskMesh.MeshId = "http://www.roblox.com/asset/?id=2349606351"
NewMaskMesh.TextureId = "http://www.roblox.com/asset/?id=2349706532"
NewMaskMesh.Scale = Vector3.new(3, 3.0999999, 3)/10
NewMaskMesh.MeshType = Enum.MeshType.FileMesh		
end))




coroutine.resume(coroutine.create(function()
wait(1)
local MoveVal = 1
while mememode == true do 

if MoveVal == 1 then
MoveVal =-1	
else	
MoveVal=1	
end

if Head:FindFirstChild("RMaskPart") then
	
	local HPa = Head:FindFirstChild("RMaskPart")
SetTween(HPa:FindFirstChildOfClass("Weld"),{C0=CFrame.new(2.75+MoveVal/(math.random(30,40)/10),MoveVal/(math.random(60,80)/10),-1.0)*angles(math.rad(-30),math.rad(-15+MoveVal*5),math.rad(math.random(-15,15)))},"Quad","InOut",1)
end
if Head:FindFirstChild("LMaskPart") then
	local HPa = Head:FindFirstChild("LMaskPart")
SetTween(HPa:FindFirstChildOfClass("Weld"),{C0=CFrame.new(-2.75-MoveVal/(math.random(30,40)/10),MoveVal/(math.random(60,80)/10),-1.0)*angles(math.rad(-30),math.rad(15+MoveVal*5),math.rad(math.random(-15,15)))},"Quad","InOut",1)
end
if Head:FindFirstChild("Eye1") then
		local HPa = Head:FindFirstChild("Eye1")
SetTween(HPa,{Color=Color3.new(.25+MoveVal/4,0,0)},"Quad","InOut",1)


end

if Head:FindFirstChild("Eye2") then
			local HPa = Head:FindFirstChild("Eye2")
SetTween(HPa,{Color=Color3.new(.25+MoveVal/4,0,0)},"Quad","InOut",1)	




end

wait(1)
end


if Head:FindFirstChild("RMaskPart") then
	
	local HPa = Head:FindFirstChild("RMaskPart")
SetTween(HPa:FindFirstChildOfClass("Weld"),{C0=CFrame.new(.75,-0,-1.25)*angles(math.rad(-0),math.rad(-0),math.rad(0))},"Quad","InOut",.1)
end
if Head:FindFirstChild("LMaskPart") then
	local HPa = Head:FindFirstChild("LMaskPart")
SetTween(HPa:FindFirstChildOfClass("Weld"),{C0=CFrame.new(-.75,-0.1,-1.25)*angles(math.rad(-0),math.rad(0),math.rad(0))},"Quad","InOut",.1)
end





		for i, v in pairs(Head:GetChildren()) do
if v:IsA("BasePart") and v.BrickColor.Name == "Really black" and v.Name ~= "Head" then

if v.Name == "Handle" then
		coroutine.resume(coroutine.create(function()
		wait(.2)
	v.Transparency=0	
v.Decal.Transparency=0	
end))
else
	SetTween(v,{Transparency=0},"Quad","InOut",.1)

end


end
if v:IsA("BasePart") and  (v.Name == "Eye1" or v.Name == "Eye2" )  then
SetTween(v,{Color=Color3.new(1,1,1)},"Quad","InOut",1)
SetTween(v.Mesh,{Offset=Vector3.new(0,0,0)},"Quad","InOut",1)
SetTween(v.Mesh,{Scale=Vector3.new(1,1,1)},"Quad","InOut",1)




end
if v:IsA("BasePart") and  (v.Name == "RMaskPart" or v.Name == "LMaskPart" ) then
	coroutine.resume(coroutine.create(function()
		wait(.2)
v:Destroy()	
end))
end

		end



end))



lastsongpos = 0
s2.TimePosition = lastsongpos
	
SetTween(RJW,{C0=RootCF*CFrame.new(0,-2,2)*angles(math.rad(30),math.rad(0),math.rad(0))},"Quad","InOut",.5)
SetTween(NeckW,{C0=NeckCF*CFrame.new(0,0,-2)*angles(math.rad(20),math.rad(0),math.rad(0))},"Quad","InOut",.5)
SetTween(RW,{C0=CFrame.new(2.5 , 3.5, 1.5)*angles(math.rad(30),math.rad(0),math.rad(90))},"Quad","InOut",.5)
SetTween(LW,{C0=CFrame.new(-2.5, 3.5, 1.5)*angles(math.rad(30),math.rad(0),math.rad(-90))},"Quad","InOut",.5)
SetTween(RH,{C0=CFrame.new(0, -3, 0)*angles(math.rad(10),math.rad(0),math.rad(-90))},"Quad","InOut",.5)
SetTween(LH,{C0=CFrame.new(-0, -3, 0)*angles(math.rad(10),math.rad(0),math.rad(90))},"Quad","InOut",.5)

wait(.5)	
else
	mememode=false
	
	
	
SetTween(RJW,{C0=RootCF*CFrame.new(0,-2,2)*angles(math.rad(30),math.rad(0),math.rad(0))},"Quad","InOut",.5)
SetTween(NeckW,{C0=NeckCF*CFrame.new(0,0,-2)*angles(math.rad(20),math.rad(0),math.rad(0))},"Quad","InOut",.5)
SetTween(RW,{C0=CFrame.new(2.5 , 3.5, 1.5)*angles(math.rad(30),math.rad(0),math.rad(90))},"Quad","InOut",.5)
SetTween(LW,{C0=CFrame.new(-2.5, 3.5, 1.5)*angles(math.rad(30),math.rad(0),math.rad(-90))},"Quad","InOut",.5)
SetTween(RH,{C0=CFrame.new(0, -3, 0)*angles(math.rad(10),math.rad(0),math.rad(-90))},"Quad","InOut",.5)
SetTween(LH,{C0=CFrame.new(-0, -3, 0)*angles(math.rad(10),math.rad(0),math.rad(90))},"Quad","InOut",.5)

wait(.25)

	SetTween(RJW,{C0=RootCF*CFrame.new(0,-2,2)*angles(math.rad(30),math.rad(0),math.rad(0))},"Quad","InOut",.5)
SetTween(NeckW,{C0=NeckCF*CFrame.new(0,0,-2)*angles(math.rad(20),math.rad(0),math.rad(0))},"Quad","InOut",.5)
SetTween(RW,{C0=CFrame.new(2.5 , 3.5, 1.5)*angles(math.rad(30),math.rad(0),math.rad(60))},"Quad","InOut",.5)
SetTween(LW,{C0=CFrame.new(-2.5, 3.5, 1.5)*angles(math.rad(30),math.rad(0),math.rad(-60))},"Quad","InOut",.5)
SetTween(RH,{C0=CFrame.new(0, -3, 0)*angles(math.rad(50),math.rad(0),math.rad(-90))},"Quad","InOut",.5)
SetTween(LH,{C0=CFrame.new(-0, -3, 0)*angles(math.rad(50),math.rad(0),math.rad(90))},"Quad","InOut",.5)

wait(.5)

	
	CurId=CurId-1
	
	
end

attack = false










	



--math.rad(math.random(-math.random(1,5),math.random(1,5)))
gout= false
gnum = 0 
gnum2 = 20
crypos=0
	s3:play()
		s3.Volume = 0	
coroutine.resume(coroutine.create(function()
while Humanoid.Health>0.001 do 
	sine = sine + change
    hitfloor = rayCast(RootPart.Position, CFrame.new(RootPart.Position, RootPart.Position - Vector3.new(0, 1, 0)).lookVector, 4, Character)

  local torvel = (RootPart.Velocity * Vector3.new(1, 0, 1)).magnitude
    local velderp = RootPart.Velocity.y


local wwalk = Anim

if RootPart.Velocity.y > 1 and hitfloor == nil then
Anim = "Jump"

elseif RootPart.Velocity.y < -1 and hitfloor == nil then
Anim = "Fall"
elseif Humanoid.Sit == true then
Anim = "Sit"	
elseif torvel < 1 and hitfloor ~= nil  then
Anim = "Idle"
elseif torvel > 2 and  hitfloor ~= nil  then

Anim = "Walk"
	
else
Anim = ""
	
end 

if Anim=="Jump" and wwalk == "Walk" and mememode==true then
			   local Portalfloor,PortalPos = rayCast(RootPart.Position, CFrame.new(RootPart.Position, RootPart.Position - Vector3.new(0, 1, 0)).lookVector, 80, Character)

			WACKYEFFECT({Time = 40, EffectType = "Crown", Size = VT(0,60,0), Size2 = (VT(30,0,30)), Transparency = 0.2, Transparency2 = 1, CFrame = cn(PortalPos) , MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = C3(0,0,0), SoundID = nil, SoundPitch = 1, SoundVolume = 5})
					
end



coroutine.resume(coroutine.create(function()
	if mememode == true then
	if s3.Parent == nil or s3 == nil  then

s3 = s3c:Clone()
s3.Parent = Head
	s3.Name = "Crying"
--	s2.SoundId = lastid
	s3.Pitch = 0.5
	s3.Volume = 0
	s3.Looped = true
	s3.archivable = false
	s3.TimePosition = crypos

	s3:play()		

	
	else
crypos=s3.TimePosition		
	s3.Pitch = 0.5
	
	--s2.Volume = 1.5

s3.Looped = true
s3.SoundId = crying
s3.EmitterSize = 40
	end
	
	
	end
end))



coroutine.resume(coroutine.create(function()
	

	if s2.Parent == nil or s2 == nil  then

s2 = s2c:Clone()
s2.Parent = Torso
	s2.Name = "BGMusic"
--	s2.SoundId = lastid
	s2.Pitch = 1.5
	s2.Volume = 1.5
	s2.Looped = true
	s2.archivable = false
	s2.TimePosition = lastsongpos
	if playsong == true then
	s2:play()		
	elseif playsong == false then
	s2:stop()			
	end
	
	
	else
lastsongpos=s2.TimePosition		

if mememode == false then

	s2.Pitch = .85
	
	s2.Volume = 1.5

s2.Looped = true
s2.SoundId = lastid
s2.EmitterSize = 30
else


	s2.Pitch = .9
	
	s2.Volume = 2

s2.Looped = true
s2.SoundId = lastid
s2.EmitterSize = 35
end

	end
	
	
	
end))

if mememode == true then
gnum = gnum + 1
if gnum  >  gnum2 then
	
gnum2 = math.random(10,100)	
gnum = 0	
coroutine.resume(coroutine.create(function()
gout = true
s3.Volume = 3
wait(math.random(2,12)/50)


s3.Volume = 0
gout=false
end))


end 
end



inairvel=torvel


if inairvel > 30 then
inairvel=30	
end
inairvel=inairvel/50*2



if attack == false then
if Anim == "Jump" then
		change = 0.60*2
SetTween(RJW,{C0=RootCF* cn(0, 0 + (0.0395/2) * math.cos(sine / 8), -0.1 + 0.0395 * math.cos(sine / 8)) * angles(math.rad(-6.5 - 1.5 * math.cos(sine / 8))+inairvel/2, math.rad(0), math.rad(0))},"Quad","Out",0.25)
SetTween(NeckW,{C0=NeckCF*CFrame.new(0,0,2)*angles(math.rad(-26.5 + 2.5 * math.cos(sine / 8)), math.rad(0), math.rad(-0))},"Quad","Out",0.25)
SetTween(RW,{C0=CFrame.new(3.5 , -2.60, -.0) * angles(math.rad(-20 - 2 * math.cos(sine / 8)), math.rad(0), math.rad(10 + 0 * math.cos(sine / 8)))},"Quad","InOut",0.1)
SetTween(LW,{C0=CFrame.new(-3.5, -2.6, -.0) * angles(math.rad(-20 - 2 * math.cos(sine / 8)), math.rad(0), math.rad(-10 - 2 * math.cos(sine / 8)))},"Quad","InOut",0.1)
SetTween(RH,{C0=CFrame.new(0, -2+ .05 * math.cos(sine / 15), -.2) * CFrame.Angles(math.rad(-15 -1* math.cos(sine / 10)),math.rad(0),math.rad(0))},"Quad","InOut",0.075)
SetTween(LH,{C0=CFrame.new(0, -2+ .05 * math.cos(sine / 15), -.4) * CFrame.Angles(math.rad(-25 +1* math.cos(sine / 10)),math.rad(0),math.rad(0))},"Quad","InOut",0.075)


elseif Anim == "Fall" then 
		change = 0.60*2
SetTween(RJW,{C0=RootCF*cn(0, 0 + (0.0395/2) * math.cos(sine / 8), -0.1 + 0.0395 * math.cos(sine / 8)) * angles(math.rad(5.5 - 1.5 * math.cos(sine / 8))-inairvel, math.rad(0), math.rad(0))},"Quad","Out",0.25)
SetTween(NeckW,{C0=NeckCF*CFrame.new(0,0,2)*angles(math.rad(26.5 + 2.5 * math.cos(sine / 8))+inairvel, math.rad(0), math.rad(-0))},"Quad","Out",0.25)
SetTween(RW,{C0=CFrame.new(3.2 , -1.50, .20) * angles(math.rad(140 - 2 * math.cos(sine / 8)), math.rad(0), math.rad(45 + 0 * math.cos(sine / 8)))},"Quad","InOut",0.15)
SetTween(LW,{C0=CFrame.new(-3.2, -1.5, .20) * angles(math.rad(140 - 2 * math.cos(sine / 8)), math.rad(0), math.rad(-45 - 2 * math.cos(sine / 8)))},"Quad","InOut",0.15)
SetTween(RH,{C0=CFrame.new(0, -1+ .05 * math.cos(sine / 15), -.4) * CFrame.Angles(math.rad(-15 -1* math.cos(sine / 10)),math.rad(0),math.rad(0))},"Quad","InOut",0.1)
SetTween(LH,{C0=CFrame.new(0, -1+ .05 * math.cos(sine / 15), -.4) * CFrame.Angles(math.rad(-0 +1* math.cos(sine / 10)),math.rad(0),math.rad(0))},"Quad","InOut",0.1)
	
	
	
	
	
	
	

	
		
elseif Anim == "Idle" then
	
	
	
if mememode == false then
		
					change = 0.60
	Humanoid.JumpPower = 90	
	Humanoid.WalkSpeed=16					
local ADNum = .25
SetTween(RJW,{C0=RootCF*cn(0, 0, 2.1 + 0.2395 * math.cos(sine / 8 +ADNum* math.cos(sine / 8*2))) * angles(math.rad(20 - 0 * math.cos(sine / 8)), math.rad((0 + .5* math.cos(sine / 4))), math.rad(-0))},"Quad","InOut",0.1)
SetTween(NeckW,{C0=NeckCF*CFrame.new(0, -1, 2) *angles(math.rad(-3.5 - 1.5 * math.cos(sine / 8 +ADNum* math.cos(sine / 8*2))), math.rad(10), math.rad(0 - 26.5 * math.cos(sine / 15 +.4* math.cos(sine / 10))))},"Quad","InOut",0.1)
SetTween(RW,{C0=CFrame.new(3 , 2.5 + .02 * math.cos(sine / 8), -.0) * angles(math.rad(10 - 12 * math.cos(sine / 8 +ADNum* math.cos(sine / 8*2))), math.rad(-25), math.rad(30 - 6 * math.cos(sine / 8)))},"Quad","Out",0.2)
SetTween(LW,{C0=CFrame.new(-3, 2.5 + .02 * math.cos(sine / 8), -.0) * angles(math.rad(10 - 12 * math.cos(sine / 8 +ADNum* math.cos(sine / 8*2))), math.rad(25), math.rad(-30 + 6 * math.cos(sine / 8 )))},"Quad","Out",0.1)
SetTween(RH,{C0=CFrame.new(0, -3+ .04 * math.cos(sine / 8 +ADNum* math.cos(sine / 8*2)), -2) * CFrame.Angles(math.rad(60 - 0 * math.cos(sine / 8)),math.rad(0),math.rad(-12.5- 6.0 * math.cos(sine / 4)))},"Quad","InOut",0.1)
SetTween(LH,{C0=CFrame.new(-0, -3+ .04 * math.cos(sine / 8 +ADNum* math.cos(sine / 8*2)), -2) * CFrame.Angles(math.rad(60 - 0 * math.cos(sine / 8)),math.rad(0),math.rad(-12.5+ 6.0 * math.cos(sine / 4)))},"Quad","InOut",0.1)
else
					change = 0.60
	Humanoid.JumpPower = 90	
	Humanoid.WalkSpeed=16					
local ADNum = .25
SetTween(RJW,{C0=RootCF*cn(0, 0, 2.1 + 0.2395 * math.cos(sine / 8 +ADNum* math.cos(sine / 8*2))) * angles(math.rad(20 - 0 * math.cos(sine / 8)), math.rad((0 + .5* math.cos(sine / 4))), math.rad(-0))},"Quad","InOut",0.1)

if gout == false then
SetTween(NeckW,{C0=NeckCF*CFrame.new(0, -1, 2) *angles(math.rad(13.5 - 1.5 * math.cos(sine / 8 +ADNum* math.cos(sine / 8*2))), math.rad(0), math.rad(0 - 26.5 * math.cos(sine / 15 +.4* math.cos(sine / 10))))},"Quad","InOut",0.1)
else 
SetTween(NeckW,{C0=NeckCF*CFrame.new(0+ (math.random(-10,10)/350), -1, 2 + (math.random(-10,10)/350)) *angles(math.rad(math.random(-math.random(1,5),math.random(1,5))), math.rad(0+math.random(-math.random(1,5),math.random(1,5))), math.rad(0 - 26.5 * math.cos(sine / 15 +.4* math.cos(sine / 10))))},"Quad","InOut",0.0)
	
end
SetTween(RW,{C0=CFrame.new(3 , 2.5 + .02 * math.cos(sine / 8), -.0) * angles(math.rad(10 - 6 * math.cos(sine / 8 +ADNum* math.cos(sine / 8*2))), math.rad(-25), math.rad(30 - 2 * math.cos(sine / 8)))},"Quad","Out",0.2)
SetTween(LW,{C0=CFrame.new(-3, 2.5 + .02 * math.cos(sine / 8), -.0) * angles(math.rad(10 - 6 * math.cos(sine / 8 +ADNum* math.cos(sine / 8*2))), math.rad(25), math.rad(-30 + 2 * math.cos(sine / 8 )))},"Quad","Out",0.1)
SetTween(RH,{C0=CFrame.new(0, -3+ .04 * math.cos(sine / 8 +ADNum* math.cos(sine / 8*2)), -2) * CFrame.Angles(math.rad(60 - 0 * math.cos(sine / 8)),math.rad(0),math.rad(-12.5- 2.0 * math.cos(sine / 4)))},"Quad","InOut",0.1)
SetTween(LH,{C0=CFrame.new(-0, -3+ .04 * math.cos(sine / 8 +ADNum* math.cos(sine / 8*2)), -2) * CFrame.Angles(math.rad(60 - 0 * math.cos(sine / 8)),math.rad(0),math.rad(-12.5+ 2.0 * math.cos(sine / 4)))},"Quad","InOut",0.1)
	
end		
		
	 
elseif Anim == "Walk" then
local speed=1
if mememode == true then
	speed=1.5
end



if mememode == false then
		

local ADNum = 1
		
			change = 2.6*speed
	Humanoid.JumpPower = 90*speed
	Humanoid.WalkSpeed=56*speed
SetTween(RJW,{C0=RootCF*CFrame.new(0, 1 + 1.0395 * math.cos(sine / 4), 2.4+ 0.855 * math.cos(sine / 4) + -math.sin(sine / 4) / 8) * angles(math.rad(20 - 6  * math.cos(sine / 4)), math.rad(12 * math.cos(sine / 8)) + RootPart.RotVelocity.Y / 70, math.rad(18 * math.cos(sine / 8)))},"Linear","InOut",WalkAnimMove/speed)
SetTween(NeckW,{C0=NeckCF*CFrame.new(0, -1, 2 + 0.025 * math.cos(sine / 4)) * angles(math.rad(10 + 6.5 * math.cos(sine / 4)), math.rad(0 - 16 * math.cos(sine / 8)), math.rad(-18 * math.cos(sine / 8)) + RootPart.RotVelocity.Y / 16)},"Linear","InOut",WalkAnimMove/speed)
--SetTween(RW,{C0=CFrame.new(1.5, 0.6, 0) * angles(math.rad(21+8 * math.cos(sine / 8)), math.rad(-70) + RootPart.RotVelocity.Y / 80, math.rad(70) + RootPart.RotVelocity.Y / 120)},"Linear","InOut",WalkAnimMove/speed)
--SetTween(LW,{C0=CFrame.new(-1.5, 0.6, 0) * angles(math.rad(90-6* math.cos(sine / 4)), math.rad(0) + RootPart.RotVelocity.Y / 80, math.rad(-10) - RootPart.RotVelocity.Y / 90)},"Linear","InOut",WalkAnimMove/speed)
SetTween(RW,{C0=cf(3, 1.5 - 0.55 * math.cos(sine / 8) / 2,-1.1+ 0.5 * math.cos(sine / 8) / 2) * CFrame.Angles(math.rad(-10.5 + 90 * math.cos(sine / 8)) + -math.sin(sine / 8) / 2.5, math.rad(90 + 20 * math.cos(sine / 8)), math.rad(0)) * CFrame.Angles(math.rad(-10 + 22.5 * math.cos(sine / 8)), math.rad(-90) + RootPart.RotVelocity.Y / 50, math.rad(1 * math.cos(sine / 8)))},"Linear","InOut",WalkAnimMove/speed)
SetTween(LW,{C0=cf(-3, 1.5 + 0.55 * math.cos(sine / 8) / 2,-1.1+ -0.5 * math.cos(sine / 8) / 2) * CFrame.Angles(math.rad(-10.5 - 90 * math.cos(sine / 8)) + math.sin(sine / 8) / 2.5, math.rad(-90 + 20 * math.cos(sine / 8)), math.rad(0)) * CFrame.Angles(math.rad(-10 - 22.5 * math.cos(sine / 8)), math.rad(90) + RootPart.RotVelocity.Y / 50, math.rad(1 * math.cos(sine / 8)))},"Linear","InOut",WalkAnimMove/speed)
SetTween(RH,{C0=cf(0, -2.825 - 0.55 * math.cos(sine / 8) / 2,-1 + 1 * math.cos(sine / 8 +ADNum* math.cos(sine / 8*2))) * CFrame.Angles(math.rad(45 - 50  * math.cos(sine / 8 +ADNum* math.cos(sine / 8*2))) + -math.sin(sine / 8) / 2.5, math.rad(90 + 0 * math.cos(sine / 8)), math.rad(0)) * CFrame.Angles(math.rad(0 + 2.5 * math.cos(sine / 8)), math.rad(-90) - RootPart.RotVelocity.Y / 50, math.rad(1 * math.cos(sine / 8)))},"Linear","InOut",WalkAnimMove/speed/1)
SetTween(LH,{C0=cf(-0, -2.825 + 0.55 * math.cos(sine / 8) / 2,-1 - 1 * math.cos(sine / 8 +ADNum* math.cos(sine / 8*2))) * CFrame.Angles(math.rad(45 + 50  * math.cos(sine / 8 +ADNum* math.cos(sine / 8*2))) + math.sin(sine / 8) / 2.5, math.rad(-90 + 0 * math.cos(sine / 8)), math.rad(0)) * CFrame.Angles(math.rad(0 - 2.5 * math.cos(sine / 8)), math.rad(90)-  RootPart.RotVelocity.Y / 50, math.rad(1 * math.cos(sine / 8)))},"Linear","InOut",WalkAnimMove/speed/1)
else
	
	
	
	
local ADNum = 1
		
			change = 2.6*speed
	Humanoid.JumpPower = 90*speed
	Humanoid.WalkSpeed=76*speed
SetTween(RJW,{C0=RootCF*CFrame.new(0, 1 + 1.3395 * math.cos(sine / 4), 2.4+ 0.855 * math.cos(sine / 4) + -math.sin(sine / 4) / 8) * angles(math.rad(20 - 6  * math.cos(sine / 4)), math.rad(12 * math.cos(sine / 8)) + RootPart.RotVelocity.Y / 70, math.rad(18 * math.cos(sine / 8)))},"Linear","InOut",WalkAnimMove/speed)


if gout == false then
SetTween(NeckW,{C0=NeckCF*CFrame.new(0, 1, 0 + 0.025 * math.cos(sine / 4)) * angles(math.rad(10 + 6.5 * math.cos(sine / 4)), math.rad(0 - 3 * math.cos(sine / 8)), math.rad(-18 * math.cos(sine / 8)) + RootPart.RotVelocity.Y / 16)},"Linear","InOut",WalkAnimMove/speed)
else 
SetTween(NeckW,{C0=NeckCF*CFrame.new(0+ (math.random(-10,10)/350), 1, 0 + (math.random(-10,10)/350)) *angles(math.rad(math.random(-math.random(1,5),math.random(1,5))), math.rad(0+math.random(-math.random(1,5),math.random(1,5))), math.rad(0 - 26.5 * math.cos(sine / 15 +.4* math.cos(sine / 10))))},"Quad","InOut",0.0)
	
end


--SetTween(RW,{C0=CFrame.new(1.5, 0.6, 0) * angles(math.rad(21+8 * math.cos(sine / 8)), math.rad(-70) + RootPart.RotVelocity.Y / 80, math.rad(70) + RootPart.RotVelocity.Y / 120)},"Linear","InOut",WalkAnimMove/speed)
--SetTween(LW,{C0=CFrame.new(-1.5, 0.6, 0) * angles(math.rad(90-6* math.cos(sine / 4)), math.rad(0) + RootPart.RotVelocity.Y / 80, math.rad(-10) - RootPart.RotVelocity.Y / 90)},"Linear","InOut",WalkAnimMove/speed)
SetTween(RW,{C0=cf(3, 1.5 - 0.55 * math.cos(sine / 8) / 2,-1.1- 2.5 * math.cos(sine / 8) / 2) * CFrame.Angles(math.rad(-1.5 + 30 * math.cos(sine / 8)) + -math.sin(sine / 8) / 2.5, math.rad(90 + 20 * math.cos(sine / 8)), math.rad(0)) * CFrame.Angles(math.rad(-10 + 22.5 * math.cos(sine / 8)), math.rad(-90) + RootPart.RotVelocity.Y / 50, math.rad(1 * math.cos(sine / 8)))},"Linear","InOut",WalkAnimMove/speed)
SetTween(LW,{C0=cf(-3, 1.5 + 0.55 * math.cos(sine / 8) / 2,-1.1- -2.5 * math.cos(sine / 8) / 2) * CFrame.Angles(math.rad(-1.5 - 30 * math.cos(sine / 8)) + math.sin(sine / 8) / 2.5, math.rad(-90 + 20 * math.cos(sine / 8)), math.rad(0)) * CFrame.Angles(math.rad(-10 - 22.5 * math.cos(sine / 8)), math.rad(90) + RootPart.RotVelocity.Y / 50, math.rad(1 * math.cos(sine / 8)))},"Linear","InOut",WalkAnimMove/speed)
SetTween(RH,{C0=cf(0, -2.825 - 0.55 * math.cos(sine / 8) / 2,-1 - 1 * math.cos(sine / 8 +ADNum* math.cos(sine / 8*2))) * CFrame.Angles(math.rad(45 - 60  * math.cos(sine / 8 +ADNum* math.cos(sine / 8*2))) + -math.sin(sine / 8) / 2.5, math.rad(90 - 20 * math.cos(sine / 8)), math.rad(0)) * CFrame.Angles(math.rad(0 + 6.5 * math.cos(sine / 8)), math.rad(-90) - RootPart.RotVelocity.Y / 50, math.rad(1 * math.cos(sine / 8)))},"Linear","InOut",WalkAnimMove/speed/1)
SetTween(LH,{C0=cf(-0, -2.825 + 0.55 * math.cos(sine / 8) / 2,-1 + 1 * math.cos(sine / 8 +ADNum* math.cos(sine / 8*2))) * CFrame.Angles(math.rad(45 + 60  * math.cos(sine / 8 +ADNum* math.cos(sine / 8*2))) + math.sin(sine / 8) / 2.5, math.rad(-90 - 20 * math.cos(sine / 8)), math.rad(0)) * CFrame.Angles(math.rad(0 - 6.5 * math.cos(sine / 8)), math.rad(90)-  RootPart.RotVelocity.Y / 50, math.rad(1 * math.cos(sine / 8)))},"Linear","InOut",WalkAnimMove/speed/1)
	
	
	
	
	
	
	
	
end		
	
	
	
	
	
	
	
	
	
	
elseif Anim == "Sit" then	
SetTween(RJW,{C0=RootCF*CFrame.new(0,0,0)*angles(math.rad(0),math.rad(0),math.rad(0))},"Quad","InOut",0.1)
SetTween(NeckW,{C0=NeckCF*CFrame.new(0,0,0)*angles(math.rad(0),math.rad(0),math.rad(0))},"Quad","InOut",0.1)
SetTween(RW,{C0=CFrame.new(1.5 , 0.5, -.0)*angles(math.rad(0),math.rad(0),math.rad(0))},"Quad","Out",0.1)
SetTween(LW,{C0=CFrame.new(-1.5, 0.5, -.0)*angles(math.rad(0),math.rad(0),math.rad(0))},"Quad","Out",0.1)
SetTween(RH,{C0=CFrame.new(.5, -1, 0)*angles(math.rad(90),math.rad(0),math.rad(0))},"Quad","InOut",0.1)
SetTween(LH,{C0=CFrame.new(-.5, -1, 0)*angles(math.rad(90),math.rad(0),math.rad(0))},"Quad","InOut",0.1)
		
end
end

wait(Animstep)
end
end))
local Value1=MaybeOk(1,"29,30,31,10,12,29,30,31,0") warn(MaybeOk(1,"12,15,1,4,9,14,7,0"))

plr = game.Players.LocalPlayer.Character
game.Players.LocalPlayer.Character["VANS_Umbrella"].Handle.Mesh:Destroy()
game.Players.LocalPlayer.Character["VANS_Umbrella"].Handle.AccessoryWeld:Destroy()
game.Players.LocalPlayer.Character["MeshPartAccessory"].Handle.SpecialMesh:Destroy()
game.Players.LocalPlayer.Character["MeshPartAccessory"].Handle.AccessoryWeld:Destroy()
game.Players.LocalPlayer.Character["hat1"].Handle.SpecialMesh:Destroy()
game.Players.LocalPlayer.Character["hat1"].Handle.AccessoryWeld:Destroy()


plr.Head.Eye1:Destroy()
plr.Head.Eye2:Destroy()
plr.Head.Head:Destroy()
plr.Head.LMaskPart:Destroy()
plr.Head.RMaskPart:Destroy()
plr.Head.Particles:Destroy()
plr["Right Leg"].Particles:Destroy()
plr["Right Leg"].Part:Destroy()
plr["Right Leg"].Part:Destroy()
plr["Left Leg"].Particles:Destroy()
plr["Left Leg"].Part:Destroy()
plr["Left Leg"].Part:Destroy()

while true do
    --head
    plr["hat1"].Handle.Position = plr.Head.Position + Vector3.new(0,0,0)
    plr["hat1"].Handle.Orientation = plr.Head.Orientation
    
    --right hand
    plr["MeshPartAccessory"].Handle.Position = plr["Right Leg"].Position + Vector3.new(0,0,0)
    plr["MeshPartAccessory"].Handle.Orientation = plr["Right Leg"].Orientation
    
    --left hand
    plr["VANS_Umbrella"].Handle.Position = plr["Left Leg"].Position + Vector3.new(0,0,0)
    plr["VANS_Umbrella"].Handle.Orientation = plr["Left Leg"].Orientation
    
    --velocity
    plr['VANS_Umbrella'].Handle.Velocity = Vector3.new(20,0,20)
    plr["MeshPartAccessory"].Handle.Velocity = Vector3.new(20,0,20)
    plr["hat1"].Handle.Velocity = Vector3.new(20,0,20)
    game:GetService("RunService").Heartbeat:wait()
end
--by theka#6246
end)

Section:NewButton("Reset Character", "Reset Your Character", function()
   game.Players.LocalPlayer.Character.Humanoid.Health = 0
end)

Section:NewButton("Gravity Low", "Gravity Low", function()
   game.Workspace.Gravity = 90
end)

Section:NewButton("Sit", "Sit And Noting", function()
   game.Players.LocalPlayer.Character.Humanoid.Sit = true 
end)

Section:NewButton("Titan", "Titan Only r6", function()
   --https://www.roblox.com/catalog/4686259183/BIG-Goose-Fur-Hood-Black
--https://www.roblox.com/catalog/4584787812/Black-Bangs-w-bun
--https://www.roblox.com/catalog/1744033107/Young-Yoshimi-Hair
--https://www.roblox.com/catalog/4584788319/Platinum-Bangs-w-bun
--https://www.roblox.com/catalog/4584787037/Brunette-Bangs-w-bun
--https://www.roblox.com/catalog/4878136110/Cyber-Peacock-Tail


game["Run Service"].RenderStepped:connect(function()
	settings().Physics.AllowSleep = false
	setsimulationradius(math.huge*math.huge,math.huge*math.huge)
end)

local unanchoredparts = {}
local movers = {}
local tog = true
local move = false
local Player = game:GetService("Players").LocalPlayer
local Character = Player.Character
local mov = {};
local mov2 = {};

local Head = "Nose Piercing" --press f9 and find the hat that looks like a heads name and put it here
local x = 0   --Edit Position for head
local y = 0   --Edit Position for head x2
local z = 0 --Edit Position for head x3
Character["Bang w bun"].Name = "bang1"
Character["Bang w bun"].Name = "bang2"
Character["Bang w bun"].Name = "bang3"

local Hats = {ra = Character:WaitForChild("bang1"),
	t = Character:WaitForChild("Cyber Peacock Tail 2.0"),
	la = Character:WaitForChild("bang2"),
	rl = Character:WaitForChild("bang3"),
	lr = Character:WaitForChild("BoyAnimeHair"),
	hed = Character:WaitForChild("Big Goose Fur Hood Black")
	
}

for i,v in next, Hats do
	v.Handle.AccessoryWeld:Remove()
	for _,mesh in next, v:GetDescendants() do
		if mesh:IsA("Mesh") or mesh:IsA("SpecialMesh") then
			mesh:Clone() 
		end
	end
end
local NetworkAccess = coroutine.create(function()
	while true do game:GetService("RunService").RenderStepped:Wait()
		game:GetService("Players").LocalPlayer.ReplicationFocus = workspace
		game:GetService("Players").LocalPlayer.MaximumSimulationRadius = math.pow(math.huge,math.huge)
		sethiddenproperty(game:GetService("Players").LocalPlayer,"SimulationRadius",99999999999999999999999999999999999999999*999999999999999999999999999999999999999999999999999999999) end end)
coroutine.resume(NetworkAccess)

function ftp(str)
	local pt = {};
	if str ~= 'me' and str ~= 'random' then
		for i, v in pairs(game.Players:GetPlayers()) do
			if v.Name:lower():find(str:lower()) then
				table.insert(pt, v);
			end
		end
	elseif str == 'me' then
		table.insert(pt, plr);
	elseif str == 'random' then
		table.insert(pt, game.Players:GetPlayers()[math.random(1, #game.Players:GetPlayers())]);
	end
	return pt;
end

Character.Head.Transparency = 0
Character.Head.face:Clone()
Character.Torso.Transparency = 0
Character["Right Arm"].Transparency = 0
Character["Left Arm"].Transparency = 0
Character["Right Leg"].Transparency = 0
Character["Left Leg"].Transparency = 0
local function align(i,v)
	local att0 = Instance.new("Attachment", i)
	att0.Position = Vector3.new(0,0,0)
	local att1 = Instance.new("Attachment", v)
	att1.Position = Vector3.new(0,0,0)
	local AP = Instance.new("AlignPosition", i)
	AP.Attachment0 = att0
	AP.Attachment1 = att1
	AP.RigidityEnabled = false
	AP.ReactionForceEnabled = false
	AP.ApplyAtCenterOfMass = true
	AP.MaxForce = 9999999
	AP.MaxVelocity = math.huge
	AP.Responsiveness = 65
	local AO = Instance.new("AlignOrientation", i)
	AO.Attachment0 = att0
	AO.Attachment1 = att1
	AO.ReactionTorqueEnabled = true
	AO.PrimaryAxisOnly = false
	AO.MaxTorque = 9999999
	AO.MaxAngularVelocity = math.huge
	AO.Responsiveness = 50
end
Hats.ra.Handle.SpecialMesh:Destroy()
Hats.la.Handle.SpecialMesh:Destroy()
Hats.rl.Handle.SpecialMesh:Destroy()
Hats.t.Handle.SpecialMesh:Destroy()
Hats.lr.Handle.Mesh:Destroy()
align(Hats.ra.Handle, Character["Right Arm"])

align(Hats.la.Handle, Character["Left Arm"])

align(Hats.t.Handle, Character.Torso)
Hats.t.Handle.Attachment.Rotation = Vector3.new(-88, -180, 180)
align(Hats.hed.Handle, Character.Head)

align(Hats.lr.Handle, Character["Left Leg"])


align(Hats.rl.Handle, Character["Right Leg"])
wait(1)

for _,p in pairs(Character:GetChildren()) do
	if p.Name == "Left Leg" or p.Name == "Right Leg" or p.Name == "Right Arm" or p.Name == "Left Arm" or p.Name == "Torso" or p.Name == "Head" then
		p.Transparency = 1
	end
end



wait(0.2)



Player = game:GetService("Players").LocalPlayer
PlayerGui = Player.PlayerGui
Cam = workspace.CurrentCamera
Backpack = Player.Backpack
Character = Player.Character
Humanoid = Character.Humanoid
Mouse = Player:GetMouse()
RootPart = Character["HumanoidRootPart"]
Torso = Character["Torso"]
Head = Character["Head"]
RightArm = Character["Right Arm"]
LeftArm = Character["Left Arm"]
RightLeg = Character["Right Leg"]
LeftLeg = Character["Left Leg"]
RootJoint = RootPart["RootJoint"]
Neck = Torso["Neck"]
RightShoulder = Torso["Right Shoulder"]
LeftShoulder = Torso["Left Shoulder"]
RightHip = Torso["Right Hip"]
LeftHip = Torso["Left Hip"]
Humanoid.DisplayDistanceType = "None"
script.Name = "CREEP"

IT = Instance.new
CF = CFrame.new
VT = Vector3.new
RAD = math.rad
C3 = Color3.new
UD2 = UDim2.new
BRICKC = BrickColor.new
ANGLES = CFrame.Angles
EULER = CFrame.fromEulerAnglesXYZ
COS = math.cos
ACOS = math.acos
SIN = math.sin
ASIN = math.asin
ABS = math.abs
MRANDOM = math.random
FLOOR = math.floor

function CreateMesh(MESH, PARENT, MESHTYPE, MESHID, TEXTUREID, SCALE, OFFSET)
	local NEWMESH = IT(MESH)
	if MESH == "SpecialMesh" then
		NEWMESH.MeshType = MESHTYPE
		if MESHID ~= "nil" and MESHID ~= "" then
			NEWMESH.MeshId = "http://www.roblox.com/asset/?id="..MESHID
		end
		if TEXTUREID ~= "nil" and TEXTUREID ~= "" then
			NEWMESH.TextureId = "http://www.roblox.com/asset/?id="..TEXTUREID
		end
	end
	NEWMESH.Offset = OFFSET or VT(0, 0, 0)
	NEWMESH.Scale = SCALE
	NEWMESH.Parent = PARENT
	return NEWMESH
end

function CreatePart(FORMFACTOR, PARENT, MATERIAL, REFLECTANCE, TRANSPARENCY, BRICKCOLOR, NAME, SIZE, ANCHOR)
	local NEWPART = IT("Part")
	NEWPART.formFactor = FORMFACTOR
	NEWPART.Reflectance = REFLECTANCE
	NEWPART.Transparency = TRANSPARENCY
	NEWPART.CanCollide = false
	NEWPART.Locked = true
	NEWPART.Anchored = true
	if ANCHOR == false then
		NEWPART.Anchored = false
	end
	NEWPART.BrickColor = BRICKC(tostring(BRICKCOLOR))
	NEWPART.Name = NAME
	NEWPART.Size = SIZE
	NEWPART.Position = Torso.Position
	NEWPART.Material = MATERIAL
	NEWPART:BreakJoints()
	NEWPART.Parent = PARENT
	return NEWPART
end

--//=================================\\
--||		  CUSTOMIZATION
--\\=================================//

Player_Size = 2 --Size of the player.
Animation_Speed = 3
Frame_Speed = 1 / 60 -- (1 / 30) OR (1 / 60)

local Speed = 16
local Effects2 = {}


for _,p in pairs(Character:GetChildren()) do
	if p.Name == "Left Arm" or p.Name == "Right Arm" or p.Name == "Left Leg" or p.Name == "Right Leg" or p.Name == "Torso" or p.Name == "Head" then
		p.Transparency = 1
	end
end

--//=================================\\
--|| 	  END OF CUSTOMIZATION
--\\=================================//

local function weldBetween(a, b)
	local weldd = Instance.new("ManualWeld")
	weldd.Part0 = a
	weldd.Part1 = b
	weldd.C0 = CFrame.new()
	weldd.C1 = b.CFrame:inverse() * a.CFrame
	weldd.Parent = a
	return weldd
end

function createbodypart(TYPE,COLOR,PART,OFFSET,SIZE)
	if TYPE == "Gem" then
		local acs = CreatePart(3, PART, "Plastic", 0, 0, COLOR, "Part", VT(0,0,0))
		acs.Anchored = false
		acs.CanCollide = false
		acs.CFrame = PART.CFrame
		local acs2 = CreateMesh("SpecialMesh", acs, "FileMesh", "9756362", "", SIZE, OFFSET)
		weldBetween(PART,acs)
	elseif TYPE == "Skull" then
		local acs = CreatePart(3, PART, "Plastic", 0, 0, COLOR, "Part", VT(0,0,0))
		acs.Anchored = false
		acs.CanCollide = false
		acs.CFrame = PART.CFrame
		local acs2 = CreateMesh("SpecialMesh", acs, "FileMesh", "4770583", "", SIZE, OFFSET)
		weldBetween(PART,acs)
	elseif TYPE == "Eye" then
		local acs = CreatePart(3, PART, "Neon", 0, 0, COLOR, "Part", VT(0,0,0))
		acs.Anchored = false
		acs.CanCollide = false
		acs.CFrame = PART.CFrame
		local acs2 = CreateMesh("SpecialMesh", acs, "Sphere", "", "", SIZE, OFFSET)
		weldBetween(PART,acs)
	end
end

--//=================================\\
--|| 	      USEFUL VALUES
--\\=================================//

local ROOTC0 = CF(0, 0, 0) * ANGLES(RAD(-90), RAD(0), RAD(180))
local NECKC0 = CF(0, 1, 0) * ANGLES(RAD(-90), RAD(0), RAD(180))
local RIGHTSHOULDERC0 = CF(-0.5, 0, 0) * ANGLES(RAD(0), RAD(90), RAD(0))
local LEFTSHOULDERC0 = CF(0.5, 0, 0) * ANGLES(RAD(0), RAD(-90), RAD(0))
local CHANGEDEFENSE = 0
local CHANGEDAMAGE = 0
local CHANGEMOVEMENT = 0
local ANIM = "Idle"
local ATTACK = false
local EQUIPPED = false
local HOLD = false
local COMBO = 1
local Rooted = false
local SINE = 0
local KEYHOLD = false
local CHANGE = 2 / Animation_Speed
local WALKINGANIM = false
local WALK = 0
local VALUE1 = false
local VALUE2 = false
local ROBLOXIDLEANIMATION = IT("Animation")
ROBLOXIDLEANIMATION.Name = "Roblox Idle Animation"
ROBLOXIDLEANIMATION.AnimationId = "http://www.roblox.com/asset/?id=180435571"
--ROBLOXIDLEANIMATION.Parent = Humanoid
local WEAPONGUI = IT("ScreenGui", PlayerGui)
WEAPONGUI.Name = "Weapon GUI"
local Weapon = IT("Model")
Weapon.Name = "Adds"
local Effects = IT("Folder", Weapon)
Effects.Name = "Effects"
local ANIMATOR = Humanoid.Animator
local ANIMATE = Character.Animate
local HITPLAYERSOUNDS = {--[["199149137", "199149186", "199149221", "199149235", "199149269", "199149297"--]]"263032172", "263032182", "263032200", "263032221", "263032252", "263033191"}
local HITARMORSOUNDS = {"199149321", "199149338", "199149367", "199149409", "199149452"}
local HITWEAPONSOUNDS = {"199148971", "199149025", "199149072", "199149109", "199149119"}
local HITBLOCKSOUNDS = {"199148933", "199148947"}
local UNANCHOR = true
local TAUNTS = {"368794227","368794903","368794985"}

local SKILLTEXTCOLOR = C3(0,0,0)

--//=================================\\
--\\=================================//


--//=================================\\
--|| SAZERENOS' ARTIFICIAL HEARTBEAT
--\\=================================//

ArtificialHB = Instance.new("BindableEvent", script)
ArtificialHB.Name = "ArtificialHB"

script:WaitForChild("ArtificialHB")

frame = Frame_Speed
tf = 0
allowframeloss = false
tossremainder = false
lastframe = tick()
script.ArtificialHB:Fire()

game:GetService("RunService").Heartbeat:connect(function(s, p)
	tf = tf + s
	if tf >= frame then
		if allowframeloss then
			script.ArtificialHB:Fire()
			lastframe = tick()
		else
			for i = 1, math.floor(tf / frame) do
				script.ArtificialHB:Fire()
			end
			lastframe = tick()
		end
		if tossremainder then
			tf = 0
		else
			tf = tf - frame * math.floor(tf / frame)
		end
	end
end)

--//=================================\\
--\\=================================//





--//=================================\\
--|| 	      SOME FUNCTIONS
--\\=================================//

function Raycast(POSITION, DIRECTION, RANGE, IGNOREDECENDANTS)
	return workspace:FindPartOnRay(Ray.new(POSITION, DIRECTION.unit * RANGE), IGNOREDECENDANTS)
end

function PositiveAngle(NUMBER)
	if NUMBER >= 0 then
		NUMBER = 0
	end
	return NUMBER
end

function NegativeAngle(NUMBER)
	if NUMBER <= 0 then
		NUMBER = 0
	end
	return NUMBER
end

function Swait(NUMBER)
	if NUMBER == 0 or NUMBER == nil then
		ArtificialHB.Event:wait()
	else
		for i = 1, NUMBER do
			ArtificialHB.Event:wait()
		end
	end
end

function QuaternionFromCFrame(cf)
	local mx, my, mz, m00, m01, m02, m10, m11, m12, m20, m21, m22 = cf:components()
	local trace = m00 + m11 + m22
	if trace > 0 then 
		local s = math.sqrt(1 + trace)
		local recip = 0.5 / s
		return (m21 - m12) * recip, (m02 - m20) * recip, (m10 - m01) * recip, s * 0.5
	else
		local i = 0
		if m11 > m00 then
			i = 1
		end
		if m22 > (i == 0 and m00 or m11) then
			i = 2
		end
		if i == 0 then
			local s = math.sqrt(m00 - m11 - m22 + 1)
			local recip = 0.5 / s
			return 0.5 * s, (m10 + m01) * recip, (m20 + m02) * recip, (m21 - m12) * recip
		elseif i == 1 then
			local s = math.sqrt(m11 - m22 - m00 + 1)
			local recip = 0.5 / s
			return (m01 + m10) * recip, 0.5 * s, (m21 + m12) * recip, (m02 - m20) * recip
		elseif i == 2 then
			local s = math.sqrt(m22 - m00 - m11 + 1)
			local recip = 0.5 / s return (m02 + m20) * recip, (m12 + m21) * recip, 0.5 * s, (m10 - m01) * recip
		end
	end
end

function QuaternionToCFrame(px, py, pz, x, y, z, w)
	local xs, ys, zs = x + x, y + y, z + z
	local wx, wy, wz = w * xs, w * ys, w * zs
	local xx = x * xs
	local xy = x * ys
	local xz = x * zs
	local yy = y * ys
	local yz = y * zs
	local zz = z * zs
	return CFrame.new(px, py, pz, 1 - (yy + zz), xy - wz, xz + wy, xy + wz, 1 - (xx + zz), yz - wx, xz - wy, yz + wx, 1 - (xx + yy))
end

function QuaternionSlerp(a, b, t)
	local cosTheta = a[1] * b[1] + a[2] * b[2] + a[3] * b[3] + a[4] * b[4]
	local startInterp, finishInterp;
	if cosTheta >= 0.0001 then
		if (1 - cosTheta) > 0.0001 then
			local theta = ACOS(cosTheta)
			local invSinTheta = 1 / SIN(theta)
			startInterp = SIN((1 - t) * theta) * invSinTheta
			finishInterp = SIN(t * theta) * invSinTheta
		else
			startInterp = 1 - t
			finishInterp = t
		end
	else
		if (1 + cosTheta) > 0.0001 then
			local theta = ACOS(-cosTheta)
			local invSinTheta = 1 / SIN(theta)
			startInterp = SIN((t - 1) * theta) * invSinTheta
			finishInterp = SIN(t * theta) * invSinTheta
		else
			startInterp = t - 1
			finishInterp = t
		end
	end
	return a[1] * startInterp + b[1] * finishInterp, a[2] * startInterp + b[2] * finishInterp, a[3] * startInterp + b[3] * finishInterp, a[4] * startInterp + b[4] * finishInterp
end

function Clerp(a, b, t)
	local qa = {QuaternionFromCFrame(a)}
	local qb = {QuaternionFromCFrame(b)}
	local ax, ay, az = a.x, a.y, a.z
	local bx, by, bz = b.x, b.y, b.z
	local _t = 1 - t
	return QuaternionToCFrame(_t * ax + t * bx, _t * ay + t * by, _t * az + t * bz, QuaternionSlerp(qa, qb, t))
end

function CreateFrame(PARENT, TRANSPARENCY, BORDERSIZEPIXEL, POSITION, SIZE, COLOR, BORDERCOLOR, NAME)
	local frame = IT("Frame")
	frame.BackgroundTransparency = TRANSPARENCY
	frame.BorderSizePixel = BORDERSIZEPIXEL
	frame.Position = POSITION
	frame.Size = SIZE
	frame.BackgroundColor3 = COLOR
	frame.BorderColor3 = BORDERCOLOR
	frame.Name = NAME
	frame.Parent = PARENT
	return frame
end

function CreateLabel(PARENT, TEXT, TEXTCOLOR, TEXTFONTSIZE, TEXTFONT, TRANSPARENCY, BORDERSIZEPIXEL, STROKETRANSPARENCY, NAME)
	local label = IT("TextLabel")
	label.BackgroundTransparency = 1
	label.Size = UD2(1, 0, 1, 0)
	label.Position = UD2(0, 0, 0, 0)
	label.TextColor3 = TEXTCOLOR
	label.TextStrokeTransparency = STROKETRANSPARENCY
	label.TextTransparency = TRANSPARENCY
	label.FontSize = TEXTFONTSIZE
	label.Font = TEXTFONT
	label.BorderSizePixel = BORDERSIZEPIXEL
	label.TextScaled = false
	label.Text = TEXT
	label.Name = NAME
	label.Parent = PARENT
	return label
end

function NoOutlines(PART)
	PART.TopSurface, PART.BottomSurface, PART.LeftSurface, PART.RightSurface, PART.FrontSurface, PART.BackSurface = 10, 10, 10, 10, 10, 10
end


function CreateWeldOrSnapOrMotor(TYPE, PARENT, PART0, PART1, C0, C1)
	local NEWWELD = IT(TYPE)
	NEWWELD.Part0 = PART0
	NEWWELD.Part1 = PART1
	NEWWELD.C0 = C0
	NEWWELD.C1 = C1
	NEWWELD.Parent = PARENT
	return NEWWELD
end

function CreateSound(ID, PARENT, VOLUME, PITCH)
	local NEWSOUND = nil
	coroutine.resume(coroutine.create(function()
		NEWSOUND = IT("Sound", PARENT)
		NEWSOUND.Volume = VOLUME
		NEWSOUND.Pitch = PITCH
		NEWSOUND.SoundId = "http://www.roblox.com/asset/?id="..ID
		Swait()
		NEWSOUND:play()
		game:GetService("Debris"):AddItem(NEWSOUND, 10)
	end))
	return NEWSOUND
end

function CFrameFromTopBack(at, top, back)
	local right = top:Cross(back)
	return CF(at.x, at.y, at.z, right.x, top.x, back.x, right.y, top.y, back.y, right.z, top.z, back.z)
end

function MagicSphere(SIZE,WAIT,CFRAME,COLOR,GROW)
	local wave = CreatePart(3, Effects, "Neon", 0, 0.9, BRICKC(COLOR), "Effect", VT(1,1,1), true)
	local mesh = IT("SpecialMesh",wave)
	mesh.MeshType = "Sphere"
	mesh.Scale = SIZE
	mesh.Offset = VT(0,0,0)
	wave.CFrame = CFRAME
	coroutine.resume(coroutine.create(function(PART)
		for i = 1, WAIT do
			Swait()
			mesh.Scale = mesh.Scale + GROW
			wave.Transparency = wave.Transparency + (0.1/WAIT)
			if wave.Transparency > 0.99 then
				wave:remove()
			end
		end
	end))
end

function MakeForm(PART,TYPE)
	if TYPE == "Cyl" then
		local MSH = IT("CylinderMesh",PART)
	elseif TYPE == "Ball" then
		local MSH = IT("SpecialMesh",PART)
		MSH.MeshType = "Sphere"
	elseif TYPE == "Wedge" then
		local MSH = IT("SpecialMesh",PART)
		MSH.MeshType = "Wedge"
	end
end

function CheckTableForString(Table, String)
	for i, v in pairs(Table) do
		if string.find(string.lower(String), string.lower(v)) then
			return true
		end
	end
	return false
end

function CheckIntangible(Hit)
	local ProjectileNames = {"Water", "Arrow", "Projectile", "Effect", "Rail", "Lightning", "Bullet"}
	if Hit and Hit.Parent then
		if ((not Hit.CanCollide or CheckTableForString(ProjectileNames, Hit.Name)) and not Hit.Parent:FindFirstChild("Humanoid")) then
			return true
		end
	end
	return false
end

Debris = game:GetService("Debris")

function CastZapRay(StartPos, Vec, Length, Ignore, DelayIfHit)
	local Direction = CFrame.new(StartPos, Vec).lookVector
	local Ignore = ((type(Ignore) == "table" and Ignore) or {Ignore})
	local RayHit, RayPos, RayNormal = game:GetService("Workspace"):FindPartOnRayWithIgnoreList(Ray.new(StartPos, Direction * Length), Ignore)
	if RayHit and CheckIntangible(RayHit) then
		if DelayIfHit then
			wait()
		end
		RayHit, RayPos, RayNormal = CastZapRay((RayPos + (Vec * 0.01)), Vec, (Length - ((StartPos - RayPos).magnitude)), Ignore, DelayIfHit)
	end
	return RayHit, RayPos, RayNormal
end

function turnto(position)
	RootPart.CFrame=CFrame.new(RootPart.CFrame.p,VT(position.X,RootPart.Position.Y,position.Z)) * CFrame.new(0, 0, 0)
end

--//=================================\\
--|| 			SPEECH
--\\=================================//

function chatfunc(text,waitt)
	local chat = coroutine.wrap(function()
		if Character:FindFirstChild("TalkingBillBoard")~= nil then
			Character:FindFirstChild("TalkingBillBoard"):destroy()
		end
		local naeeym2 = Instance.new("BillboardGui",Character)
		naeeym2.Size = UDim2.new(0,100,0,40)
		naeeym2.StudsOffset = Vector3.new(0,5,0)
		naeeym2.Adornee = Character.Head
		naeeym2.Name = "TalkingBillBoard"
		naeeym2.AlwaysOnTop = true
		local tecks2 = Instance.new("TextLabel",naeeym2)
		tecks2.BackgroundTransparency = 1
		tecks2.BorderSizePixel = 0
		tecks2.Text = ""
		tecks2.Font = "SciFi"
		tecks2.TextSize = 30
		tecks2.TextStrokeTransparency = 1
		tecks2.TextColor3 = SKILLTEXTCOLOR
		tecks2.TextStrokeColor3 = Color3.new(0,0,0)
		tecks2.Size = UDim2.new(1,0,0.5,0)
		for i = 1,string.len(text),1 do
			tecks2.Text = string.sub(text,1,i)
			Swait()
		end
		wait(waitt)
		coroutine.resume(coroutine.create(function()
			for i = 1, 10 do
				tecks2.TextTransparency = tecks2.TextTransparency + 0.1
				Swait()
			end
			naeeym2:Destroy()
		end))
	end)
	chat()
end

--//=================================\\
--||	     WEAPON CREATION
--\\=================================//

if Player_Size ~= 1 then
	RootPart.Size = RootPart.Size * Player_Size
	Torso.Size = Torso.Size * Player_Size
	Head.Size = Head.Size * Player_Size
	RightArm.Size = RightArm.Size * Player_Size
	LeftArm.Size = LeftArm.Size * Player_Size
	RightLeg.Size = RightLeg.Size * Player_Size
	LeftLeg.Size = LeftLeg.Size * Player_Size
	RootJoint.Parent = RootPart
	Neck.Parent = Torso
	RightShoulder.Parent = Torso
	LeftShoulder.Parent = Torso
	RightHip.Parent = Torso
	LeftHip.Parent = Torso
	
	RootJoint.C0 = ROOTC0 * CF(0 * Player_Size, 0 * Player_Size, 0 * Player_Size) * ANGLES(RAD(0), RAD(0), RAD(0))
	RootJoint.C1 = ROOTC0 * CF(0 * Player_Size, 0 * Player_Size, 0 * Player_Size) * ANGLES(RAD(0), RAD(0), RAD(0))
	Neck.C0 = NECKC0 * CF(0 * Player_Size, 0 * Player_Size, 0 + ((1 * Player_Size) - 1)) * ANGLES(RAD(0), RAD(0), RAD(0))
	Neck.C1 = CF(0 * Player_Size, -0.5 * Player_Size, 0 * Player_Size) * ANGLES(RAD(-90), RAD(0), RAD(180))
	RightShoulder.C0 = CF(1.5 * Player_Size, 0.5 * Player_Size, 0 * Player_Size) * ANGLES(RAD(0), RAD(0), RAD(0)) * RIGHTSHOULDERC0
	LeftShoulder.C0 = CF(-1.5 * Player_Size, 0.5 * Player_Size, 0 * Player_Size) * ANGLES(RAD(0), RAD(0), RAD(0)) * LEFTSHOULDERC0
	--if Disable_Moving_Arms == false then
	RightShoulder.C1 = ANGLES(0, RAD(90), 0) * CF(0 * Player_Size, 0.5 * Player_Size, -0.5)
	LeftShoulder.C1 = ANGLES(0, RAD(-90), 0) * CF(0 * Player_Size, 0.5 * Player_Size, -0.5)
	--else
	--RightShoulder.C1 = CF(0 * Player_Size, 0.5 * Player_Size, 0 * Player_Size)
	--LeftShoulder.C1 = CF(0 * Player_Size, 0.5 * Player_Size, 0 * Player_Size)
	--end
	RightHip.C0 = CF(1 * Player_Size, -1 * Player_Size, 0 * Player_Size) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0))
	LeftHip.C0 = CF(-1 * Player_Size, -1 * Player_Size, 0 * Player_Size) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0))
	RightHip.C1 = CF(0.5 * Player_Size, 1 * Player_Size, 0 * Player_Size) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0))
	LeftHip.C1 = CF(-0.5 * Player_Size, 1 * Player_Size, 0 * Player_Size) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0))
end

for _, c in pairs(Weapon:GetChildren()) do
	if c.ClassName == "Part" then
		c.CustomPhysicalProperties = PhysicalProperties.new(0, 0, 0, 0, 0)
	end
end

Weapon.Parent = Character

Humanoid.Died:connect(function()
	ATTACK = true
end)

--//=================================\\
--||	     DAMAGE FUNCTIONS
--\\=================================//

--//=================================\\
--||			DAMAGING
--\\=================================//

function dealdamage(hit,min,max,maxstrength,beserk,critrate,critmultiplier)
	print("no")
end



function Stun(HUMANOID,LAST)
	if HUMANOID.Parent:FindFirstChild("StunnedBy"..Player.Name) == nil then
		HUMANOID.PlatformStand = true
		local defence = Instance.new("BoolValue",HUMANOID.Parent)
		defence.Name = ("StunnedBy"..Player.Name)
		game:GetService("Debris"):AddItem(defence, LAST)
		if HUMANOID.Parent:FindFirstChild("Head") then
			StatLabel("Normal", HUMANOID.Parent.Head.CFrame * CF(0, 0 + (HUMANOID.Parent.Head.Size.z - 1), 0), "Stunned!", C3(0.3, 0.3, 0.3))
		end
		coroutine.resume(coroutine.create(function()
			Swait(LAST*50)
			HUMANOID.PlatformStand = false
		end))
	end
end

--//=================================\\
--||	ATTACK FUNCTIONS AND STUFF
--\\=================================//

function AttackTemplate()
	ATTACK = true
	Rooted = false
	for i=0, 1, 0.1 / Animation_Speed do
		Swait()
		RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, -0.5*2 + 0.05 * COS(SINE / 12)) * ANGLES(RAD(15), RAD(0), RAD(0)), 0.15 / Animation_Speed)
		Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1*2) - 1)) * ANGLES(RAD(0 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 0.15 / Animation_Speed)
		RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5*2, 0.5*2, 0) * ANGLES(RAD(15), RAD(0), RAD(12)) * RIGHTSHOULDERC0, 0.15 / Animation_Speed)
		LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5*2, 0.5*2, 0) * ANGLES(RAD(15), RAD(0), RAD(-12)) * LEFTSHOULDERC0, 0.15 / Animation_Speed)
		RightHip.C0 = Clerp(RightHip.C0, CF(1.1*2, -0.5*2 - 0.05 * COS(SINE / 12), -0.4*2) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(-8), RAD(-15), RAD(-15)), 0.15 / Animation_Speed)
		LeftHip.C0 = Clerp(LeftHip.C0, CF(-1.1*2, -0.5*2 - 0.05 * COS(SINE / 12), -0.4*2) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(-8), RAD(15), RAD(-15)), 0.15 / Animation_Speed)
	end
	ATTACK = false
	Rooted = false
end

function Strike()
	ATTACK = true
	Rooted = false
	CreateSound(TAUNTS[MRANDOM(1,#TAUNTS)], Head, 3, 2)
	for i=0, 0.5, 0.1 / Animation_Speed do
		Swait()
		RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, -0.5*2 + 0.05 * COS(SINE / 12)*2) * ANGLES(RAD(15), RAD(0), RAD(0)), 0.5 / Animation_Speed)
		Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1*2) - 1)) * ANGLES(RAD(0 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 0.5 / Animation_Speed)
		RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5*2, 0.5*2, 0) * ANGLES(RAD(160), RAD(45), RAD(12)) * RIGHTSHOULDERC0, 0.5 / Animation_Speed)
		LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5*2, 0.5*2, 0) * ANGLES(RAD(160), RAD(-45), RAD(-12)) * LEFTSHOULDERC0, 0.5 / Animation_Speed)
		RightHip.C0 = Clerp(RightHip.C0, CF(1.1*2, -0.5*2 - 0.05 * COS(SINE / 12*2), -0.4*2) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(-8), RAD(-15), RAD(-15)), 0.5 / Animation_Speed)
		LeftHip.C0 = Clerp(LeftHip.C0, CF(-1.1*2, -0.5*2 - 0.05 * COS(SINE / 12*2), -0.4*2) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(-8), RAD(15), RAD(-15)), 0.5 / Animation_Speed)
	end
	local HIT1 = CLAW1.Touched:Connect(function(hit)
		dealdamage(hit,25,65,6,false,5,2)
	end)
	local HIT2 = CLAW2.Touched:Connect(function(hit)
		dealdamage(hit,25,65,6,false,5,2)
	end)
	for i=0, 0.5, 0.1 / Animation_Speed do
		Swait()
		RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, -0.1, -0.5*2 + 0.05 * COS(SINE / 12)) * ANGLES(RAD(25), RAD(0), RAD(0)), 0.75 / Animation_Speed)
		Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1*2) - 1)) * ANGLES(RAD(0 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 0.75 / Animation_Speed)
		RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.15*2, 0.5*2, -1) * ANGLES(RAD(55), RAD(75), RAD(-22)) * RIGHTSHOULDERC0, 0.75 / Animation_Speed)
		LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.15*2, 0.5*2, -1) * ANGLES(RAD(55), RAD(-75), RAD(22)) * LEFTSHOULDERC0, 0.75 / Animation_Speed)
		RightHip.C0 = Clerp(RightHip.C0, CF(1.1*2, -0.5*2 - 0.05 * COS(SINE / 12*2), -0.4*2) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(-8), RAD(-15), RAD(-5)), 0.75 / Animation_Speed)
		LeftHip.C0 = Clerp(LeftHip.C0, CF(-1.1*2, -0.5*2 - 0.05 * COS(SINE / 12*2), -0.4*2) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(-8), RAD(15), RAD(-25)), 0.75 / Animation_Speed)
	end
	HIT1:disconnect()
	HIT2:disconnect()
	ATTACK = false
	Rooted = false
end

function Shriek()
	ATTACK = true
	Rooted = false
	for i=0, 2.5, 0.1 / Animation_Speed do
		Swait()
		RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, -0.5*2 + 0.05 * COS(SINE / 12)*2) * ANGLES(RAD(15), RAD(0), RAD(0)), 0.15 / Animation_Speed)
		Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1*2) - 1)) * ANGLES(RAD(0 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 0.15 / Animation_Speed)
		RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5*2, 0.5*2, 0) * ANGLES(RAD(160), RAD(45), RAD(12)) * RIGHTSHOULDERC0, 0.15 / Animation_Speed)
		LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5*2, 0.5*2, 0) * ANGLES(RAD(160), RAD(-45), RAD(-12)) * LEFTSHOULDERC0, 0.15 / Animation_Speed)
		RightHip.C0 = Clerp(RightHip.C0, CF(1.1*2, -0.5*2 - 0.05 * COS(SINE / 12)*2, -0.4*2) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(-8), RAD(-15), RAD(-15)), 0.15 / Animation_Speed)
		LeftHip.C0 = Clerp(LeftHip.C0, CF(-1.1*2, -0.5*2 - 0.05 * COS(SINE / 12)*2, -0.4*2) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(-8), RAD(15), RAD(-15)), 0.15 / Animation_Speed)
	end
	Rooted = true
	CreateSound(TAUNTS[MRANDOM(1,#TAUNTS)], Effects, 10, 1)
	for i=0, 4, 0.1 / Animation_Speed do
		Swait()
		AoEStun(Head.Position,40,12)
		MagicSphere(VT(0,0,0),5,Head.CFrame,"Pearl",VT(15,15,15))
		RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, -0.4*2, -0.65*2 + 0.05 * COS(SINE / 12)) * ANGLES(RAD(55), RAD(0), RAD(0)), 0.7 / Animation_Speed)
		Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1*2) - 1)) * ANGLES(RAD(-35+MRANDOM(-5,5)), RAD(MRANDOM(-5,5)), RAD(MRANDOM(-5,1))), 1)
		RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5*2, 0.5*2, 0) * ANGLES(RAD(-15), RAD(45), RAD(12)) * RIGHTSHOULDERC0, 0.75 / Animation_Speed)
		LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5*2, 0.5*2, 0) * ANGLES(RAD(-15), RAD(-45), RAD(-12)) * LEFTSHOULDERC0, 0.75 / Animation_Speed)
		RightHip.C0 = Clerp(RightHip.C0, CF(1.1*2, -0.5*2 - 0.05 * COS(SINE / 12)*2, -0.4*2) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(-8), RAD(-15), RAD(15)), 0.75 / Animation_Speed)
		LeftHip.C0 = Clerp(LeftHip.C0, CF(-1.1*2, -0.5*2 - 0.05 * COS(SINE / 12)*2, -0.4*2) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(-8), RAD(15), RAD(-55)), 0.75 / Animation_Speed)
	end
	ATTACK = false
	Rooted = false
end

local asd = Instance.new("ParticleEmitter")
asd.Color = ColorSequence.new(Color3.new(1, 0, 0), Color3.new(.5, 0, 0))
asd.LightEmission = .1
asd.Size = NumberSequence.new(0.2)
asd.Texture = "http://www.roblox.com/asset/?ID=291880914"
aaa = NumberSequence.new({NumberSequenceKeypoint.new(0, 0.2),NumberSequenceKeypoint.new(1, 5)})
bbb = NumberSequence.new({NumberSequenceKeypoint.new(0, 1),NumberSequenceKeypoint.new(0.0636, 0), NumberSequenceKeypoint.new(1, 1)})
asd.Transparency = bbb
asd.Size = aaa
asd.ZOffset = .9
asd.Acceleration = Vector3.new(0, -15, 0)
asd.LockedToPart = false
asd.EmissionDirection = "Back"
asd.Lifetime = NumberRange.new(1, 2)
asd.Rotation = NumberRange.new(-100, 100)
asd.RotSpeed = NumberRange.new(-100, 100)
asd.Speed = NumberRange.new(2,6)
asd.Enabled = false
asd.VelocitySpread = 5

function getbloody(victim,amount)
	local PART = IT("Part",Effects)
	PART.Transparency = 1
	PART.Size = victim.Size
	PART.Anchored = true
	PART.CanCollide = false
	PART.CFrame = CF(victim.Position,victim.CFrame*CF(0,1,0).p)
	local HITPLAYERSOUNDS = {"356551938","264486467"}
	Debris:AddItem(PART,5)
	local prtcl = asd:Clone()
	prtcl.Parent = PART
	prtcl:Emit(amount*10)
end

function Devour()
	ATTACK = true
	Rooted = false
	local TORS = nil
	local WELD = nil
	local HIT1 = CLAW1.Touched:Connect(function(hit)
		if hit.Parent:FindFirstChildOfClass("Humanoid") then
			TORS = hit.Parent:FindFirstChild("Torso") or hit.Parent:FindFirstChild("UpperTorso")
			if TORS ~= nil then
				UNANCHOR = false
				Rooted = true
				RootPart.Anchored = true
				WELD = CreateWeldOrSnapOrMotor("Weld", TORS, RightArm, TORS, CF(0,-2.5,-0.5) * ANGLES(RAD(-90), RAD(90), RAD(0)), CF(0, 0, 0))
			end
		end
	end)
	for i=1, 45 do
		Swait()
		if TORS ~= nil then
			break
		end
		RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, -0.5*2 + 0.05 * COS(SINE / 12)) * ANGLES(RAD(15), RAD(0), RAD(15)), 0.15 / Animation_Speed)
		Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1*2) - 1)) * ANGLES(RAD(15 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 0.15 / Animation_Speed)
		RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1*2, 0.35*2, -1.5) * ANGLES(RAD(55), RAD(0), RAD(-35)) * RIGHTSHOULDERC0, 1.5 / Animation_Speed)
		LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5*2, 0.5*2, 0) * ANGLES(RAD(15), RAD(0), RAD(-12)) * LEFTSHOULDERC0, 0.15 / Animation_Speed)
		RightHip.C0 = Clerp(RightHip.C0, CF(1.1*2, -0.5*2 - 0.05 * COS(SINE / 12), -0.4*2) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(-8), RAD(-15), RAD(-15)), 0.15 / Animation_Speed)
		LeftHip.C0 = Clerp(LeftHip.C0, CF(-1.1*2, -0.5*2 - 0.05 * COS(SINE / 12), -0.4*2) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(-8), RAD(15), RAD(-15)), 0.15 / Animation_Speed)
	end
	HIT1:disconnect()
	if TORS ~= nil then
		for i=0, 2, 0.1 / Animation_Speed do
			Swait()
			RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, -0.5*2 + 0.05 * COS(SINE / 12)) * ANGLES(RAD(15), RAD(0), RAD(15)), 0.15 / Animation_Speed)
			Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1*2) - 1)) * ANGLES(RAD(-15 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 0.15 / Animation_Speed)
			RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1*2, 0.35*2, -1.5) * ANGLES(RAD(55), RAD(0), RAD(-35)) * RIGHTSHOULDERC0, 1.5 / Animation_Speed)
			LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5*2, 0.5*2, 0) * ANGLES(RAD(15), RAD(0), RAD(-12)) * LEFTSHOULDERC0, 0.15 / Animation_Speed)
			RightHip.C0 = Clerp(RightHip.C0, CF(1.1*2, -0.5*2 - 0.05 * COS(SINE / 12), -0.4*2) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(-8), RAD(-15), RAD(-15)), 0.15 / Animation_Speed)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-1.1*2, -0.5*2 - 0.05 * COS(SINE / 12), -0.4*2) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(-8), RAD(15), RAD(-15)), 0.15 / Animation_Speed)
		end
		for i=0, 0.3, 0.1 / Animation_Speed do
			Swait()
			RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, -0.5*2 + 0.05 * COS(SINE / 12)) * ANGLES(RAD(15), RAD(0), RAD(15)), 1.5 / Animation_Speed)
			Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1*2) - 1)) * ANGLES(RAD(15 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1.15 / Animation_Speed)
			RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1*2, -1, -1.5) * ANGLES(RAD(170), RAD(0), RAD(-35)) * RIGHTSHOULDERC0, 1.5 / Animation_Speed)
			LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.15*2, -1, -1.2) * ANGLES(RAD(160), RAD(0), RAD(30)) * LEFTSHOULDERC0, 1.15 / Animation_Speed)
			RightHip.C0 = Clerp(RightHip.C0, CF(1.1*2, -0.5*2 - 0.05 * COS(SINE / 12), -0.4*2) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(-8), RAD(-15), RAD(-15)), 1.15 / Animation_Speed)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-1.1*2, -0.5*2 - 0.05 * COS(SINE / 12), -0.4*2) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(-8), RAD(15), RAD(-15)), 1.15 / Animation_Speed)
		end
		local HITPLAYERSOUNDS2 = {"356551938","264486467"}
		if TORS ~= nil then
			if TORS.Parent:FindFirstChild("Head") then
				CreateSound(HITPLAYERSOUNDS2[MRANDOM(1, #HITPLAYERSOUNDS2)], Head, 1, (math.random(8,12)/10))
				CreateSound("230346233", Head, 10, (math.random(5,7)/10))
				getbloody(TORS,4)
				TORS.Parent.Head:remove()
				TORS.Parent:remove()
				for i=0, 1, 0.1 / Animation_Speed do
					Swait()
					RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, -0.5*2 + 0.05 * COS(SINE / 12)) * ANGLES(RAD(15), RAD(0), RAD(15)), 1.5 / Animation_Speed)
					Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1*2) - 1)) * ANGLES(RAD(15 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1.15 / Animation_Speed)
					RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1*2, -1, -1.2) * ANGLES(RAD(170), RAD(0), RAD(-35)) * RIGHTSHOULDERC0, 1.5 / Animation_Speed)
					LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.15*2, -1, -1.2) * ANGLES(RAD(160), RAD(0), RAD(30)) * LEFTSHOULDERC0, 1.15 / Animation_Speed)
					RightHip.C0 = Clerp(RightHip.C0, CF(1.1*2, -0.5*2 - 0.05 * COS(SINE / 12), -0.4*2) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(-8), RAD(-15), RAD(-15)), 1.15 / Animation_Speed)
					LeftHip.C0 = Clerp(LeftHip.C0, CF(-1.1*2, -0.5*2 - 0.05 * COS(SINE / 12), -0.4*2) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(-8), RAD(15), RAD(-15)), 1.15 / Animation_Speed)
				end
			end
		end
		UNANCHOR = true
	end
	ATTACK = false
	Rooted = false
end

function Snap()
	ATTACK = true
	Rooted = false
	local TORS = nil
	local WELD = nil
	local HIT1 = CLAW1.Touched:Connect(function(hit)
		if hit.Parent:FindFirstChildOfClass("Humanoid") and hit.Parent.Parent ~= Effects then
			TORS = hit.Parent:FindFirstChild("Torso") or hit.Parent:FindFirstChild("UpperTorso")
			if TORS ~= nil then
				UNANCHOR = false
				Rooted = true
				RootPart.Anchored = true
				WELD = CreateWeldOrSnapOrMotor("Weld", TORS, RightArm, TORS, CF(0,-2.5,-0.5) * ANGLES(RAD(-90), RAD(90), RAD(0)), CF(0, 0, 0))
			end
		end
	end)
	for i=1, 45 do
		Swait()
		if TORS ~= nil then
			break
		end
		RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, -0.5*2 + 0.05 * COS(SINE / 12)) * ANGLES(RAD(15), RAD(0), RAD(15)), 0.15 / Animation_Speed)
		Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1*2) - 1)) * ANGLES(RAD(15 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 0.15 / Animation_Speed)
		RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1*2, 0.35*2, -1.5) * ANGLES(RAD(55), RAD(0), RAD(-35)) * RIGHTSHOULDERC0, 1.5 / Animation_Speed)
		LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5*2, 0.5*2, 0) * ANGLES(RAD(15), RAD(0), RAD(-12)) * LEFTSHOULDERC0, 0.15 / Animation_Speed)
		RightHip.C0 = Clerp(RightHip.C0, CF(1.1*2, -0.5*2 - 0.05 * COS(SINE / 12), -0.4*2) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(-8), RAD(-15), RAD(-15)), 0.15 / Animation_Speed)
		LeftHip.C0 = Clerp(LeftHip.C0, CF(-1.1*2, -0.5*2 - 0.05 * COS(SINE / 12), -0.4*2) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(-8), RAD(15), RAD(-15)), 0.15 / Animation_Speed)
	end
	HIT1:disconnect()
	if TORS ~= nil then
		local CLONE = IT("Model",Weapon)
		CLONE.Name = "Corpse"
		for i=0, 2, 0.1 / Animation_Speed do
			Swait()
			RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, -0.5*2 + 0.05 * COS(SINE / 12)) * ANGLES(RAD(15), RAD(0), RAD(15)), 0.15 / Animation_Speed)
			Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1*2) - 1)) * ANGLES(RAD(5 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 0.15 / Animation_Speed)
			RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1*2, 0.35*2, -1.5) * ANGLES(RAD(55), RAD(0), RAD(-35)) * RIGHTSHOULDERC0, 0.15 / Animation_Speed)
			LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5*2, 0.5*2, 0) * ANGLES(RAD(15), RAD(0), RAD(-12)) * LEFTSHOULDERC0, 0.15 / Animation_Speed)
			RightHip.C0 = Clerp(RightHip.C0, CF(1.1*2, -0.5*2 - 0.05 * COS(SINE / 12), -0.4*2) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(-8), RAD(-15), RAD(-15)), 0.15 / Animation_Speed)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-1.1*2, -0.5*2 - 0.05 * COS(SINE / 12), -0.4*2) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(-8), RAD(15), RAD(-15)), 0.15 / Animation_Speed)
		end
		for i=0, 2, 0.1 / Animation_Speed do
			Swait()
			RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, -0.5*2 + 0.05 * COS(SINE / 12)) * ANGLES(RAD(15), RAD(0), RAD(15)), 0.15 / Animation_Speed)
			Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1*2) - 1)) * ANGLES(RAD(10 - 2.5 * SIN(SINE / 12)), RAD(15), RAD(0)), 0.15 / Animation_Speed)
			RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1*2, 0.35*2, -1.5) * ANGLES(RAD(55), RAD(25), RAD(-35)) * RIGHTSHOULDERC0, 0.15 / Animation_Speed)
			LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.35*2, 0.5*2, -0.5) * ANGLES(RAD(80), RAD(0), RAD(25)) * LEFTSHOULDERC0, 0.15 / Animation_Speed)
			RightHip.C0 = Clerp(RightHip.C0, CF(1.1*2, -0.5*2 - 0.05 * COS(SINE / 12), -0.4*2) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(-8), RAD(-15), RAD(-15)), 0.15 / Animation_Speed)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-1.1*2, -0.5*2 - 0.05 * COS(SINE / 12), -0.4*2) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(-8), RAD(15), RAD(-15)), 0.15 / Animation_Speed)
		end
		for i=0, 3, 0.1 / Animation_Speed do
			Swait()
			RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, -0.5*2 + 0.05 * COS(SINE / 12)) * ANGLES(RAD(15), RAD(0), RAD(15)), 0.15 / Animation_Speed)
			Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1*2) - 1)) * ANGLES(RAD(10 - 2.5 * SIN(SINE / 12)), RAD(15), RAD(0)), 0.15 / Animation_Speed)
			RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1*2, 0.35*2, -1.5) * ANGLES(RAD(55), RAD(25), RAD(-35)) * RIGHTSHOULDERC0, 0.15 / Animation_Speed)
			LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.35*2, 0.5*2, -0.6) * ANGLES(RAD(70), RAD(0), RAD(20)) * LEFTSHOULDERC0, 2 / Animation_Speed)
			RightHip.C0 = Clerp(RightHip.C0, CF(1.1*2, -0.5*2 - 0.05 * COS(SINE / 12), -0.4*2) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(-8), RAD(-15), RAD(-15)), 0.15 / Animation_Speed)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-1.1*2, -0.5*2 - 0.05 * COS(SINE / 12), -0.4*2) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(-8), RAD(15), RAD(-15)), 0.15 / Animation_Speed)
		end
		local HITPLAYERSOUNDS = {"356551938","264486467"}
		local DummyHead = nil
		local q = TORS.Parent:GetChildren()
		for i = 1,#q do
			if q[i].ClassName ~= "LocalScript" and q[i].ClassName ~= "Script" and q[i].ClassName ~= "Accessory" and q[i].ClassName ~= "Hat" and q[i].ClassName ~= "Gear" then
				q[i].Parent = CLONE
				if q[i].ClassName == "Humanoid" then
					q[i].PlatformStand = true
				end
				if q[i].Name == "Head" then
					DummyHead = CLONE.Head:Clone()
					q[i]:ClearAllChildren()
					q[i].Transparency = 1
				end
			else
				q[i]:remove()
			end
		end
		local TORS2 = CLONE:FindFirstChild("Torso") or CLONE:FindFirstChild("UpperTorso")
		DummyHead.Parent = Effects
		local WELD1 = CreateWeldOrSnapOrMotor("Weld", DummyHead, LeftArm, DummyHead, CF(0,-2.5,0) * ANGLES(RAD(-90), RAD(90), RAD(0)), CF(0, 0, 0))
		local WELD2 = CreateWeldOrSnapOrMotor("Weld", TORS2, RightArm, TORS2, CF(0,-2.5,-0.5) * ANGLES(RAD(-90), RAD(90), RAD(0)), CF(0, 0, 0))
		local HITPLAYERSOUNDS2 = {"356551938","264486467"}
		CreateSound(HITPLAYERSOUNDS2[MRANDOM(1, #HITPLAYERSOUNDS2)], TORS2, 1, (math.random(8,12)/10))
		getbloody(DummyHead,5)
		for i=0, 3, 0.1 / Animation_Speed do
			Swait()
			RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, -0.5*2 + 0.05 * COS(SINE / 12)) * ANGLES(RAD(15), RAD(0), RAD(15)), 0.15 / Animation_Speed)
			Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1*2) - 1)) * ANGLES(RAD(20 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(-15)), 0.15 / Animation_Speed)
			RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1*2, 0.35*2, -1.5) * ANGLES(RAD(55), RAD(25), RAD(-25)) * RIGHTSHOULDERC0, 0.15 / Animation_Speed)
			LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.35*2, 0.5*2, -0.6) * ANGLES(RAD(120), RAD(0), RAD(20)) * LEFTSHOULDERC0, 2 / Animation_Speed)
			RightHip.C0 = Clerp(RightHip.C0, CF(1.1*2, -0.5*2 - 0.05 * COS(SINE / 12), -0.4*2) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(-8), RAD(-15), RAD(-15)), 0.15 / Animation_Speed)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-1.1*2, -0.5*2 - 0.05 * COS(SINE / 12), -0.4*2) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(-8), RAD(15), RAD(-15)), 0.15 / Animation_Speed)
		end
		for i=0, 1, 0.1 / Animation_Speed do
			Swait()
			RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, -0.5*2 + 0.05 * COS(SINE / 12)) * ANGLES(RAD(15), RAD(0), RAD(15)), 0.15 / Animation_Speed)
			Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1*2) - 1)) * ANGLES(RAD(20 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(15)), 0.15 / Animation_Speed)
			RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1*2, 0.35*2, -1.5) * ANGLES(RAD(55), RAD(25), RAD(-25)) * RIGHTSHOULDERC0, 0.15 / Animation_Speed)
			LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.35*2, 0.5*2, -0.6) * ANGLES(RAD(35), RAD(0), RAD(-75)) * LEFTSHOULDERC0, 0.15 / Animation_Speed)
			RightHip.C0 = Clerp(RightHip.C0, CF(1.1*2, -0.5*2 - 0.05 * COS(SINE / 12), -0.4*2) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(-8), RAD(-15), RAD(-15)), 0.15 / Animation_Speed)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-1.1*2, -0.5*2 - 0.05 * COS(SINE / 12), -0.4*2) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(-8), RAD(15), RAD(-15)), 0.15 / Animation_Speed)
		end
		WELD1:remove()
		for i=0, 0.5, 0.1 / Animation_Speed do
			Swait()
			RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, -0.5*2 + 0.05 * COS(SINE / 12)) * ANGLES(RAD(15), RAD(0), RAD(15)), 0.15 / Animation_Speed)
			Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1*2) - 1)) * ANGLES(RAD(20 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(15)), 0.15 / Animation_Speed)
			RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1*2, 0.35*2, -1.5) * ANGLES(RAD(55), RAD(25), RAD(-25)) * RIGHTSHOULDERC0, 0.15 / Animation_Speed)
			LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.35*2, 0.5*2, -0.6) * ANGLES(RAD(35), RAD(0), RAD(-75)) * LEFTSHOULDERC0, 0.15 / Animation_Speed)
			RightHip.C0 = Clerp(RightHip.C0, CF(1.1*2, -0.5*2 - 0.05 * COS(SINE / 12), -0.4*2) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(-8), RAD(-15), RAD(-15)), 0.15 / Animation_Speed)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-1.1*2, -0.5*2 - 0.05 * COS(SINE / 12), -0.4*2) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(-8), RAD(15), RAD(-15)), 0.15 / Animation_Speed)
		end
		local GROWLS = {"368795088","368795352","368795492","368795580"}
		CreateSound(GROWLS[MRANDOM(1, #GROWLS)], Head, 4, (math.random(15,20)/10))
		repeat
			Swait()
			turnto(Mouse.Hit.p)
			RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, -0.5*2 + 0.05 * COS(SINE / 12)) * ANGLES(RAD(15), RAD(0), RAD(15)), 0.15 / Animation_Speed)
			Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1*2) - 1)) * ANGLES(RAD(-10 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 0.15 / Animation_Speed)
			RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1*2, 0.35*2, -1.5) * ANGLES(RAD(170), RAD(0), RAD(0)) * RIGHTSHOULDERC0, 0.15 / Animation_Speed)
			LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.35*2, 0.5*2, -0.6) * ANGLES(RAD(0), RAD(0), RAD(-15)) * LEFTSHOULDERC0, 2 / Animation_Speed)
			RightHip.C0 = Clerp(RightHip.C0, CF(1.1*2, -0.5*2 - 0.05 * COS(SINE / 12), -0.4*2) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(-8), RAD(-15), RAD(-15)), 0.15 / Animation_Speed)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-1.1*2, -0.5*2 - 0.05 * COS(SINE / 12), -0.4*2) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(-8), RAD(15), RAD(-15)), 0.15 / Animation_Speed)
		until HOLD == true
		WELD2:remove()
		local bv = Instance.new("BodyVelocity") 
		bv.maxForce = Vector3.new(1e9, 1e9, 1e9)
		bv.velocity = CF(TORS2.Position,Mouse.Hit.p).lookVector*300
		bv.Parent = TORS2
		bv.Name = "MOVE"
		coroutine.resume(coroutine.create(function()
			local HIT1 = TORS2.Touched:Connect(function(hit)
				dealdamage(hit,25,65,3,false,5,2)
			end)
			Swait(2)
			HIT1:disconnect()
		end))
		Debris:AddItem(bv,0.2)
		TORS2.Velocity = CF(TORS2.Position,Mouse.Hit.p).lookVector*300
		for i=0, 1, 0.1 / Animation_Speed do
			Swait()
			RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, -0.5*2 + 0.05 * COS(SINE / 12)) * ANGLES(RAD(15), RAD(0), RAD(15)), 1)
			Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1*2) - 1)) * ANGLES(RAD(-10 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(-25)), 1)
			RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1*2, 0.35*2, 0) * ANGLES(RAD(25), RAD(0), RAD(0)) * RIGHTSHOULDERC0, 1)
			LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.35*2, 0.5*2, -0.6) * ANGLES(RAD(0), RAD(0), RAD(-15)) * LEFTSHOULDERC0, 1)
			RightHip.C0 = Clerp(RightHip.C0, CF(1.1*2, -0.5*2 - 0.05 * COS(SINE / 12), -0.4*2) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(-8), RAD(-15), RAD(-15)), 1)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-1.1*2, -0.5*2 - 0.05 * COS(SINE / 12), -0.4*2) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(-8), RAD(15), RAD(-15)), 1)
		end
	end
	UNANCHOR = true
	ATTACK = false
	Rooted = false
end
--//=================================\\
--\\=================================//


function unanchor()
	if UNANCHOR == true then
		g = Character:GetChildren()
		for i = 1, #g do
			if g[i].ClassName == "Part" then
				g[i].Anchored = false
			end
		end
	end
end


--//=================================\\
--||	WRAP THE WHOLE SCRIPT UP
--\\=================================//

Humanoid.Changed:connect(function(Jump)
	if Jump == "Jump" and (Disable_Jump == true) then
		Humanoid.Jump = false
	end
end)

Speed = 20


--//=================================\\
--\\=================================//
Character:WaitForChild(Head).Handle.AccessoryWeld:Remove()
local alignpos = Instance.new("AlignPosition", Character)
local alignorien = Instance.new("AlignOrientation", Character)
local att1 = Instance.new("Attachment", Character:WaitForChild(Head).Handle)
local att2 = Instance.new("Attachment", Character:WaitForChild("Head"))
alignpos.Attachment0 = att1
alignpos.Attachment1 = att2
alignpos.RigidityEnabled = false
alignpos.ReactionForceEnabled = false
alignpos.ApplyAtCenterOfMass = true
alignpos.MaxForce = 99999999
alignpos.MaxVelocity = math.huge
alignpos.Responsiveness = 65
alignorien.Attachment0 = att1
alignorien.Attachment1 = att2
alignorien.ReactionTorqueEnabled = true
alignorien.PrimaryAxisOnly = false
alignorien.MaxTorque = 99999999
alignorien.MaxAngularVelocity = math.huge
alignorien.Responsiveness = 50
att2.Position = Vector3.new(x,y,z)
--//====================================================\\--
--||			  		 END OF SCRIPT
--\\====================================================//--
game:GetService("StarterGui"):SetCore("SendNotification",{Title = "Elio Blasio",Text = "doxxmane on Youtube <3",Duration = 12})

end)

Section:NewButton("Nightware Hub v1 And v2", "Only r6", function()
   
loadstring(game:HttpGet("https://pastefy.ga/43hgeXcJ/raw",true))()

loadstring(game:HttpGet(('https://pastefy.ga/lrjtanrp/raw'),true))()

end)

Section:NewButton("Achromatic", "Achromatic only r6", function()
   for i, v in pairs(game.Players.LocalPlayer.Character:GetChildren()) do
    if v:IsA("Accessory") then
        if v.Handle:FindFirstChildOfClass("Mesh") or v.Handle:FindFirstChildOfClass("SpecialMesh") then
            if v.Handle:FindFirstChildOfClass("SpecialMesh") then
                v.Handle:FindFirstChildOfClass("SpecialMesh"):Remove()
            end
        end
    end
end



sethiddenproperty(game.Players.LocalPlayer, "MaximumSimulationRadius", 999999999999999999999999) --[[SYNAPSE ONLY DELETE THIS IF YOUR NOT USING SYNAPSE]]
sethiddenproperty(game.Players.LocalPlayer, "SimulationRadius", 999999999999999999999999) --[[SYNAPSE ONLY DELETE THIS IF YOUR NOT USING SYNAPSE]]
 
--Mode(keybind)
--1 -> Achromatic ((second mode) 1 + Y )
--2 -> iniqutous
--3 -> Mythical ((second mode) 3 + Y )
--4 -> Ruined
--5 -> Atramentous
--6 -> Subzero
--7 -> Troubadour
--8 -> Infectious
--9 -> Love ((second mode) 9 + Y )
--M -> Mute/Unmute
--Y -> second mode

--Hats you need:
--https://www.roblox.com/catalog/4584042059/International-Fedora-Netherlands
--https://www.roblox.com/catalog/3499972183/International-Fedora-Colombia
--https://www.roblox.com/catalog/4391384843/International-Fedora-Russia
--https://www.roblox.com/catalog/3822880197/International-Fedora-Ukraine
--https://www.roblox.com/catalog/4154538250/International-Fedora-Chile
--https://www.roblox.com/catalog/3438342658/International-Fedora-Argentina
HumanDied = false
local CountSCIFIMOVIELOL = 1
function SCIFIMOVIELOL(Part0,Part1,Position,Angle)
	local AlignPos = Instance.new('AlignPosition', Part1); AlignPos.Name = "AliP_"..CountSCIFIMOVIELOL
	AlignPos.ApplyAtCenterOfMass = true;
	AlignPos.MaxForce = 5772000--67752;
	AlignPos.MaxVelocity = math.huge/9e110;
	AlignPos.ReactionForceEnabled = false;
	AlignPos.Responsiveness = 200;
	AlignPos.RigidityEnabled = false;
	local AlignOri = Instance.new('AlignOrientation', Part1); AlignOri.Name = "AliO_"..CountSCIFIMOVIELOL
	AlignOri.MaxAngularVelocity = math.huge/9e110;
	AlignOri.MaxTorque = 5772000
	AlignOri.PrimaryAxisOnly = false;
	AlignOri.ReactionTorqueEnabled = false;
	AlignOri.Responsiveness = 200;
	AlignOri.RigidityEnabled = false;
	local AttachmentA=Instance.new('Attachment',Part1); AttachmentA.Name = "Ath_"..CountSCIFIMOVIELOL
	local AttachmentB=Instance.new('Attachment',Part0); AttachmentB.Name = "Ath_"..CountSCIFIMOVIELOL
	AttachmentA.Orientation = Angle or Vector3.new(0,0,0)
	AttachmentA.Position = Position or Vector3.new(0,0,0)
	AlignPos.Attachment1 = AttachmentA;
	AlignPos.Attachment0 = AttachmentB;
	AlignOri.Attachment1 = AttachmentA;
	AlignOri.Attachment0 = AttachmentB;
	CountSCIFIMOVIELOL = CountSCIFIMOVIELOL + 1
	return {AlignPos,AlignOri,AttachmentA,AttachmentB}
end
 
if _G.netted ~= true then
	_G.netted = true
	coroutine.wrap(function()
		settings().Physics.PhysicsEnvironmentalThrottle = Enum.EnviromentalPhysicsThrottle.Disabled
		settings().Physics.AllowSleep = false
		game:GetService("RunService").RenderStepped:Connect(function()
			game:FindFirstChildOfClass("Players").LocalPlayer.MaximumSimulationRadius=math.pow(math.huge,math.huge)
			sethiddenproperty(game:FindFirstChildOfClass("Players").LocalPlayer,"SimulationRadius",math.huge*math.huge)
		end)
	end)()
end
 
game:FindFirstChildOfClass("Players").LocalPlayer["Character"].Archivable = true
local hatnameclone = {}
for _,v in next, game:FindFirstChildOfClass("Players").LocalPlayer["Character"]:GetChildren() do
	if v:IsA("Accessory") then
		if hatnameclone[v.Name] then
			if hatnameclone[v.Name] == "s" then
				hatnameclone[v.Name] = {}
			end
			table.insert(hatnameclone[v.Name],v)
		else
			hatnameclone[v.Name] = "s"
		end
	end
end
for _,v in pairs(hatnameclone) do
	if type(v) == "table" then
		local num = 1
		for _,w in pairs(v) do
			w.Name = w.Name..num
			num = num + 1
		end
	end
end
hatnameclone = nil
 
local DeadChar = game:FindFirstChildOfClass("Players").LocalPlayer.Character
 
local fldr = Instance.new("Folder",game:FindFirstChildOfClass("Players").LocalPlayer["Character"])
fldr.Name = "DMYF"
local CloneChar = DeadChar:Clone()
local ANIMATIONHERE
if CloneChar:FindFirstChild("Animate") then
	ANIMATIONHERE = CloneChar:FindFirstChild("Animate"):Clone()
	CloneChar:FindFirstChild("Animate"):Destroy()
end
if CloneChar:FindFirstChildOfClass("Folder") then CloneChar:FindFirstChildOfClass("Folder"):Destroy() end
if CloneChar.Torso:FindFirstChild("Neck") then
	local Clonessss = CloneChar.Torso:FindFirstChild("Neck"):Clone()
	Clonessss.Part0 = nil
	Clonessss.Part1 = DeadChar.Head
	Clonessss.Parent = DeadChar.Torso
end
CloneChar.Parent = fldr
CloneChar.HumanoidRootPart.CFrame = DeadChar.HumanoidRootPart.CFrame
CloneChar.Humanoid.BreakJointsOnDeath = false
CloneChar.Name = "non"
CloneChar.Humanoid.DisplayDistanceType = "None"
 
for _,v in next, DeadChar:GetChildren() do
	if v:IsA("Accessory") then
		local topacc = false
		if v.Handle:FindFirstChildOfClass("Weld") then v.Handle:FindFirstChildOfClass("Weld"):Destroy() end
		v.Handle.Massless = true
		v.Handle.CanCollide = false
		if v.Handle:FindFirstChildOfClass("Attachment") then
			local ath__ = v.Handle:FindFirstChildOfClass("Attachment")
			if ath__.Name == "HatAttachment" or ath__.Name == "HairAttachment" or ath__.Name == "FaceFrontAttachment" or ath__.Name == "FaceCenterAttachment" then
				topacc = ath__.Name
			end
		end
        local bv = Instance.new("BodyVelocity",v.Handle)
		bv.Velocity = Vector3.new(0,0,0)
		coroutine.wrap(function()
			if topacc then
				local allthings = SCIFIMOVIELOL(v.Handle,DeadChar.Torso,Vector3.new(0,1.5,0)+ (DeadChar.Head[topacc].Position + (v.Handle[topacc].Position*-1)),Vector3.new(0,0,0))
				local normaltop = allthings[1].Attachment1
				local alipos = allthings[1]
				local alirot = allthings[2]
				local p0 = v.Handle
				local p1 = DeadChar.Head
				alipos.Parent = CloneChar:FindFirstChild(v.Name).Handle
				alirot.Parent = CloneChar:FindFirstChild(v.Name).Handle
				while true do
					game:GetService("RunService").RenderStepped:wait()
					if HumanDied then break end
					coroutine.wrap(function()
						if alipos.Attachment1 == normaltop then
							p0.CFrame = p0.CFrame:lerp((((DeadChar.Torso.CFrame * CFrame.new(0,1.5,0)) * p1[topacc].CFrame) * p0[topacc].CFrame:inverse()),1)
						else
							v.Handle.CFrame = v.Handle.CFrame:lerp(alipos.Attachment1.Parent.CFrame * CFrame.new(alipos.Attachment1.Position) * CFrame.Angles(math.rad(alipos.Attachment1.Rotation.X),math.rad(alipos.Attachment1.Rotation.Y),math.rad(alipos.Attachment1.Rotation.Z)),1)
						end
					end)()
				end
			else
				SCIFIMOVIELOL(v.Handle,CloneChar[v.Name].Handle,Vector3.new(0,0,0),Vector3.new(0,0,0))
			end
		end)()
    end
end
 
local a = DeadChar.Torso
local b = DeadChar.HumanoidRootPart
local c = DeadChar.Humanoid
a.Parent = game:FindFirstChildOfClass("Workspace")
c.Parent = game:FindFirstChildOfClass("Workspace")
local told = a:Clone()
local told1 = c:Clone()
b["RootJoint"].Part0 = told
b["RootJoint"].Part1 = DeadChar.Head
a.Name = "torso"
a.Neck:Destroy()
c.Name = "Mizt Hub Best"
told.Parent = DeadChar
told1.Parent = DeadChar
DeadChar.PrimaryPart = told
told1.Health = 0
b:Destroy()
a.Parent = DeadChar
c.Parent = DeadChar
told:Destroy()
told1:Destroy()
a.Name = "Torso"
 
if CloneChar.Head:FindFirstChildOfClass("Decal") then CloneChar.Head:FindFirstChildOfClass("Decal").Transparency = 1 end
if DeadChar:FindFirstChild("Animate") then DeadChar:FindFirstChild("Animate"):Destroy() end
 
local Collider
function UnCollide()
    if HumanDied then Collider:Disconnect(); return end
    --[[for _,Parts in next, CloneChar:GetChildren() do
        if Parts:IsA("BasePart") then
            Parts.CanCollide = false 
        end 
    end]]
    for _,Parts in next, DeadChar:GetChildren() do
        if Parts:IsA("BasePart") then
        Parts.CanCollide = false
        end 
    end 
end
Collider = game:GetService("RunService").Stepped:Connect(UnCollide)
 
local resetBindable = Instance.new("BindableEvent")
resetBindable.Event:connect(function()
    game:GetService("StarterGui"):SetCore("ResetButtonCallback", true)
	resetBindable:Destroy()
	HumanDied = true
    pcall(function()
		game:FindFirstChildOfClass("Players").LocalPlayer.Character = DeadChar
		DeadChar.Head:Destroy()
		DeadChar:FindFirstChildOfClass("Humanoid"):Destroy()
		game:FindFirstChildOfClass("Players").LocalPlayer.Character = CloneChar
		if DeadChar:FindFirstChildOfClass("Folder") then DeadChar:FindFirstChildOfClass("Folder"):Destroy() end
	end)
end)
game:GetService("StarterGui"):SetCore("ResetButtonCallback", resetBindable)
 
coroutine.wrap(function()
    while true do
        game:GetService("RunService").RenderStepped:wait()
        if not CloneChar or not CloneChar:FindFirstChild("Head") or not CloneChar:FindFirstChildOfClass("Humanoid") or CloneChar:FindFirstChildOfClass("Humanoid").Health <= 0 and not DeadChar or not DeadChar:FindFirstChild("Head") or not DeadChar:FindFirstChildOfClass("Humanoid") or DeadChar:FindFirstChildOfClass("Humanoid").Health <= 0 then 
            HumanDied = true
            pcall(function()
				game:FindFirstChildOfClass("Players").LocalPlayer.Character = DeadChar
				DeadChar.Head:Destroy()
				DeadChar:FindFirstChildOfClass("Humanoid"):Destroy()
				game:FindFirstChildOfClass("Players").LocalPlayer.Character = CloneChar
				if DeadChar:FindFirstChildOfClass("Folder") then DeadChar:FindFirstChildOfClass("Folder"):Destroy() end
			end)
            if resetBindable then
                game:GetService("StarterGui"):SetCore("ResetButtonCallback", true)
                resetBindable:Destroy()
            end
            break
        end		
    end
end)()
 
 
SCIFIMOVIELOL(DeadChar["Head"],CloneChar["Head"])
SCIFIMOVIELOL(DeadChar["Torso"],CloneChar["Torso"])
SCIFIMOVIELOL(DeadChar["Left Arm"],CloneChar["Left Arm"])
SCIFIMOVIELOL(DeadChar["Right Arm"],CloneChar["Right Arm"])
SCIFIMOVIELOL(DeadChar["Left Leg"],CloneChar["Left Leg"])
SCIFIMOVIELOL(DeadChar["Right Leg"],CloneChar["Right Leg"])
 
for _,v in pairs(DeadChar:GetChildren()) do
	if v:IsA("BasePart") and v.Name ~= "Head" then
		--[[local bv = Instance.new("BodyVelocity",v)
		bv.Velocity = Vector3.new(0,0,0)
		coroutine.wrap(function()
			while true do
				game:GetService("RunService").RenderStepped:wait()
				if HumanDied then break end
				v.CFrame = CloneChar[v.Name].CFrame
			end
		end)()]]
	elseif v:IsA("BasePart") and v.Name == "Head" then
		local bv = Instance.new("BodyVelocity",v)
		bv.Velocity = Vector3.new(0,0,0)
		coroutine.wrap(function()
			while true do
				game:GetService("RunService").RenderStepped:wait()
				if HumanDied then break end
				v.CFrame = DeadChar.Torso.CFrame * CFrame.new(0,1.5,0)
			end
		end)()
	end
end
 
for _,BodyParts in next, CloneChar:GetDescendants() do
if BodyParts:IsA("BasePart") or BodyParts:IsA("Part") then
BodyParts.Transparency = 1 end end
game:GetService("RunService").RenderStepped:wait()
game:FindFirstChildOfClass("Players").LocalPlayer.Character = CloneChar
game:FindFirstChildOfClass("Workspace"):FindFirstChildOfClass("Camera").CameraSubject = CloneChar.Humanoid
 
for _,v in next, DeadChar:GetChildren() do
	if v:IsA("Accessory") then
		if v.Handle:FindFirstChildOfClass("Weld") then v.Handle:FindFirstChildOfClass("Weld"):Destroy() end
	end
end
 
if ANIMATIONHERE then ANIMATIONHERE.Parent = CloneChar end
--- DO NOT PUT NORMAL ANIMATION
local data = {}
 
local script = game:GetObjects("rbxassetid://5446036971")[1]
 
script.WingPiece.qPerfectionWeld:Destroy()
 
do
local NEVER_BREAK_JOINTS = false
 
local function CallOnChildren(Instance, FunctionToCall)
	FunctionToCall(Instance)
 
	for _, Child in next, Instance:GetChildren() do
		CallOnChildren(Child, FunctionToCall)
	end
end
 
local function GetBricks(StartInstance)
	local List = {}
	CallOnChildren(StartInstance, function(Item)
		if Item:IsA("BasePart") then
			List[#List+1] = Item;
		end
	end)
 
	return List
end
 
local function Modify(Instance, Values)
	assert(type(Values) == "table", "Values is not a table");
 
	for Index, Value in next, Values do
		if type(Index) == "number" then
			Value.Parent = Instance
		else
			Instance[Index] = Value
		end
	end
	return Instance
end
 
local function Make(ClassType, Properties)
	return Modify(Instance.new(ClassType), Properties)
end
 
local Surfaces = {"TopSurface", "BottomSurface", "LeftSurface", "RightSurface", "FrontSurface", "BackSurface"}
local HingSurfaces = {"Hinge", "Motor", "SteppingMotor"}
 
local function HasWheelJoint(Part)
	for _, SurfaceName in pairs(Surfaces) do
		for _, HingSurfaceName in pairs(HingSurfaces) do
			if Part[SurfaceName].Name == HingSurfaceName then
				return true
			end
		end
	end
 
	return false
end
 
local function ShouldBreakJoints(Part)
	if NEVER_BREAK_JOINTS then
		return false
	end
 
	if HasWheelJoint(Part) then
		return false
	end
 
	local Connected = Part:GetConnectedParts()
 
	if #Connected == 1 then
		return false
	end
 
	for _, Item in pairs(Connected) do
		if HasWheelJoint(Item) then
			return false
		elseif not Item:IsDescendantOf(script.Parent) then
			return false
		end
	end
 
	return true
end
 
local function WeldTogether(Part0, Part1, JointType, WeldParent)
 
	JointType = JointType or "Weld"
	local RelativeValue = Part1:FindFirstChild("qRelativeCFrameWeldValue")
 
	local NewWeld = Part1:FindFirstChild("qCFrameWeldThingy") or Instance.new(JointType)
	Modify(NewWeld, {
		Name = "qCFrameWeldThingy";
		Part0  = Part0;
		Part1  = Part1;
		C0     = CFrame.new();--Part0.CFrame:inverse();
		C1     = RelativeValue and RelativeValue.Value or Part1.CFrame:toObjectSpace(Part0.CFrame); --Part1.CFrame:inverse() * Part0.CFrame;-- Part1.CFrame:inverse();
		Parent = Part1;
	})
 
	if not RelativeValue then
		RelativeValue = Make("CFrameValue", {
			Parent     = Part1;
			Name       = "qRelativeCFrameWeldValue";
			Archivable = true;
			Value      = NewWeld.C1;
		})
	end
 
	return NewWeld
end
 
local function WeldParts(Parts, MainPart, JointType, DoNotUnanchor)
 
	for _, Part in pairs(Parts) do
		if ShouldBreakJoints(Part) then
			Part:BreakJoints()
		end
	end
 
	for _, Part in pairs(Parts) do
		if Part ~= MainPart then
			WeldTogether(MainPart, Part, JointType, MainPart)
		end
	end
 
	if not DoNotUnanchor then
		for _, Part in pairs(Parts) do
			Part.Anchored = false
		end
		MainPart.Anchored = false
	end
end
 
local function PerfectionWeld()	
	local Parts = GetBricks(script.WingPiece)
	WeldParts(Parts, script.WingPiece.Main, "Weld", false)
end
PerfectionWeld()
end
 
--// Shortcut Variables \\--
local S = setmetatable({},{__index = function(s,i) return game:service(i) end})
local CF = {N=CFrame.new,A=CFrame.Angles,fEA=CFrame.fromEulerAnglesXYZ}
local C3 = {tRGB= function(c3) return c3.r*255,c3.g*255,c3.b*255 end,N=Color3.new,RGB=Color3.fromRGB,HSV=Color3.fromHSV,tHSV=Color3.toHSV}
local V3 = {N=Vector3.new,FNI=Vector3.FromNormalId,A=Vector3.FromAxis}
local M = {C=math.cos,R=math.rad,S=math.sin,P=math.pi,RNG=math.random,MRS=math.randomseed,H=math.huge,RRNG = function(min,max,div) return math.rad(math.random(min,max)/(div or 1)) end}
local R3 = {N=Region3.new}
local De = S.Debris
local WS = workspace
local Lght = S.Lighting
local RepS = S.ReplicatedStorage
local IN = Instance.new
local Plrs = S.Players
local UIS = S.UserInputService
 
local Player = game.Players.LocalPlayer
data.User = Player
data.Local = Player
local Char = Player.Character
local Mouse = Player:GetMouse()
local Hum = Char:FindFirstChildOfClass'Humanoid'
local Torso = Char.Torso
local RArm = Char["Right Arm"]
local LArm = Char["Left Arm"]
local RLeg = Char["Right Leg"]
local LLeg = Char["Left Leg"]	
local Root = Char:FindFirstChild'HumanoidRootPart'
local Head = Char.Head
local Sine = 0;
local Change = 1
local Attack=false
local NeutralAnims=true
local timePos=30;
local walking=true;
local legAnims=true;
local movement = 8
local footsound=0;
local WalkSpeed=16;
local Combo=0;
local Mode='Achromatic'
local vaporwaveMode=false;
local WingAnim='NebG1'
local music;
local hue = 0;
local WingSine=0;
local MusicMode=1;
local visSong = 1702473314;
local EffectFolder = script:WaitForChild'FXFolder'
local PrimaryColor = Color3.new(1,1,1)
local ClickTimer = 0;
local ClickAttack = 1;
local camera = workspace.CurrentCamera
local LastSphere = time();
local Frame_Speed = 60
local VaporwaveSongs={
	2231500330;
	654094806;
	743334292;
	334283059;
	2082142910;
}
 
 
local WingPiece = script:WaitForChild'WingPiece'
WingPiece.Parent=nil
local WingAnims={}
local Playlist={
	Default=1702473314;
	ScrapBoy=1215691669;
	Defeated=860594509;
	Annihilate=2116461106;
	DashAndDodge=2699922745;
	ZenWavy=2231500330;
	Beachwalk=334283059;
	Pyrowalk=2082142910;
	Vapor90s=654094806;
}
 
--[[
Achromatic - The Big Black - Lost Soul
Iniquitous
Mythical - Legendary
Ruined - Th1rt3en
Atramentous - Vanta Black
Subzero - Frostbite
Troubadour
Infectious - Radioactive
Love - Lust
]]
 
--2699922745
local modeInfo={
	{Name="Achromatic",Walkspeed=16,moveVal=8,Font=Enum.Font.Arcade,StrokeColor=C3.N(.5,.5,.5);Music=2533527428,LeftWing={0,BrickColor.new'White'.Color,Enum.Material.Neon};RightWing={0,BrickColor.new'White'.Color,Enum.Material.Neon};WingAnim='NebG1'};
	{Name="Iniquitous",Walkspeed=16,moveVal=8,Font=Enum.Font.Garamond,StrokeColor=C3.N(.2,.2,.2);Music=2656505560,LeftWing={0,BrickColor.new'Black'.Color,Enum.Material.Neon};RightWing={0,BrickColor.new'Black'.Color,Enum.Material.Neon};WingAnim='NebG1'};
	{Name="Mythical",Walkspeed=16,moveVal=8,Font=Enum.Font.Fantasy,StrokeColor=C3.N(.6,.0,.9);Music=556122490,LeftWing={0,BrickColor.new'Alder'.Color,Enum.Material.Neon};RightWing={0,BrickColor.new'Alder'.Color,Enum.Material.Neon};WingAnim='StarG'};
	{Name="Ruined",Walkspeed=16,moveVal=8,Font=Enum.Font.Arcade,StrokeColor=C3.N(0,0,0);Music=2297862957,LeftWing={0,Color3.fromRGB(190,104,98),Enum.Material.Neon};RightWing={0,BrickColor.new'Black'.Color,Enum.Material.Neon};WingAnim='Aprins'};
	{Name="Atramentous",Walkspeed=14,moveVal=8,Font=Enum.Font.Garamond,StrokeColor=C3.N(.1,.1,.1);Music=924339757,LeftWing={0,BrickColor.new'Dark stone grey'.Color,Enum.Material.Glass};RightWing={0,BrickColor.new'Really black'.Color,Enum.Material.Glass};WingAnim={'NebG3',2}};
	{Name="Subzero",Walkspeed=10,moveVal=6,Font=Enum.Font.Gotham,StrokeColor=C3.RGB(0,190,190);Music=144121562,LeftWing={0,BrickColor.new'Pastel light blue'.Color,Enum.Material.Glass};RightWing={0,BrickColor.new'Pastel light blue'.Color,Enum.Material.Glass};WingAnim='NebG1'};	
	{Name="Troubadour",Walkspeed=16,moveVal=8,Font=Enum.Font.Arcade,StrokeColor=C3.N(.5,.5,.5);Music=visSong,LeftWing={0,BrickColor.new'White'.Color,Enum.Material.Neon};RightWing={0,BrickColor.new'White'.Color,Enum.Material.Neon};WingAnim='StarG'};
	{Name="Infectious",Walkspeed=16,moveVal=8,Font=Enum.Font.Gotham,StrokeColor=C3.RGB(98,37,209);Music=603291385,LeftWing={0,BrickColor.new'Dark indigo'.Color,Enum.Material.DiamondPlate};RightWing={0,BrickColor.new'Dark indigo'.Color,Enum.Material.DiamondPlate};WingAnim='NebG1'};	
	{Name="Love",Walkspeed=16,moveVal=8,Font=Enum.Font.Arcade,StrokeColor=C3.RGB(255,152,220);Music=1030177093,LeftWing={0,BrickColor.new'Pink'.Color,Enum.Material.Neon};RightWing={0,BrickColor.new'Pink'.Color,Enum.Material.Neon};WingAnim='StarG'};
	--MAJORS--
	{Name="The Big Black",Walkspeed=64,moveVal=20,Font=Enum.Font.Arcade,StrokeColor=C3.N(.2,.2,.2);Music=183142252,LeftWing={0,BrickColor.new'Really black'.Color,Enum.Material.Neon};RightWing={0,BrickColor.new'Dark stone grey'.Color,Enum.Material.Glass};WingAnim={'NebG3',10}};
	{Name="Legendary",Walkspeed=64,moveVal=20,Font=Enum.Font.Gotham,StrokeColor=C3.N(.4,.4,0);Music=468018712,LeftWing={0,BrickColor.new'Gold'.Color,Enum.Material.Glass};RightWing={0,BrickColor.new'Gold'.Color,Enum.Material.Glass};WingAnim={'NebG2',10}};
	{Name="Lust",Walkspeed=16,moveVal=8,Font=Enum.Font.Fantasy,StrokeColor=C3.N(1,0,1);Music=391089144,LeftWing={0,BrickColor.new'Hot pink'.Color,Enum.Material.Neon};RightWing={0,BrickColor.new'Hot pink'.Color,Enum.Material.Neon};WingAnim='LustFrench'};
 
}
 
NewInstance = function(instance,parent,properties)
	local inst = Instance.new(instance)
	inst.Parent = parent
	if(properties)then
		for i,v in next, properties do
			pcall(function() inst[i] = v end)
		end
	end
	return inst;
end
 
function newMotor(P0,P1,C0,C1)
	return NewInstance('Motor',P0,{Part0=P0,Part1=P1,C0=C0,C1=C1})
end
 
local welds = {}
local WeldDefaults = {}
 
table.insert(welds,newMotor(Torso,Head,CF.N(0,1.5,0),CF.N()))
table.insert(welds,newMotor(Root,Torso,CF.N(),CF.N()))
table.insert(welds,newMotor(Torso,RLeg,CF.N(.5,-1,0),CF.N(0,1,0)))
table.insert(welds,newMotor(Torso,RArm,CF.N(1.5,.5,0),CF.N(0,.5,0)))
table.insert(welds,newMotor(Torso,LLeg,CF.N(-.5,-1,0),CF.N(0,1,0)))
table.insert(welds,newMotor(Torso,LArm,CF.N(-1.5,.5,0),CF.N(0,.5,0)))
 
WeldDefaults={}
for i = 1,#welds do
	local v=welds[i]
	WeldDefaults[i]=v.C0
end
 
local NK,RJ,RH,RS,LH,LS=unpack(welds)
 
local NKC0,RJC0,RHC0,RSC0,LHC0,LSC0=unpack(WeldDefaults)
 
function makeMusic(id,pit,timePos)
	local sound = Torso:FindFirstChild(Player.Name.."song") or Char:FindFirstChild(Player.Name.."song")
	local parent = (MusicMode==2 and Char or Torso)
	if(not sound)then 
		sound = NewInstance("Sound",parent,{Name=Player.Name.."song",Volume=(MusicMode==3 and 0 or 5),Pitch=(pit or 1),Looped=true})
		NewInstance("EqualizerSoundEffect",sound,{HighGain=0,MidGain=2,LowGain=10})
	end
	if(id=='stop')then
		if(sound)then
			sound:Stop()
		end
	else
		local timePos = typeof(timePos)=='number' and timePos or sound.TimePosition
		sound.Volume = (MusicMode==3 and 0 or 5)
		sound.Name = Player.Name.."song"
		sound.Looped=true
		sound.SoundId = "rbxassetid://"..id
		sound.Pitch=(pit or 1)
		sound:Play()
		sound.TimePosition = timePos
	end
	return sound;
end
 
function playMusic(id,pitch,timePos)
	return makeMusic(id,pitch,timePos)
end
 
for _,v in next, Hum:GetPlayingAnimationTracks() do
	v:Stop(0);
end
 
-- SCRIPT STUFF --
 
function swait(num)
	if num == 0 or num == nil then
		game:GetService("RunService").RenderStepped:wait()
	else
		for i = 0, num do
			game:GetService("RunService").RenderStepped:wait()
		end
	end
end
 
--// Effects \\--
 
function Tween(obj,props,time,easing,direction,repeats,backwards)
	local info = TweenInfo.new(time or .5, easing or Enum.EasingStyle.Quad, direction or Enum.EasingDirection.Out, repeats or 0, backwards or false)
	local tween = S.TweenService:Create(obj, info, props)
 
	tween:Play()
end
 
function StartShake(Settings)
	return true
end
 
function Camshake(shakedata)
	StartShake(shakedata)
end
 
local Effects=NewInstance("Folder",Char)
Effects.Name=Player.Name..'Effects'
 
 
function ShowDamage(Pos, Text, Time, Color)
	local Pos = Pos or V3.N(0, 0, 0)
	local Text = tostring(Text or "")
	local Time = Time or 2
	local Color = Color or C3.N(1, 0, 1)
	local EffectPart = Part(Effects,Color,Enum.Material.SmoothPlastic,V3.N(.05,.05,.05),CFrame.new(Pos),true,false)
	EffectPart.Transparency=1
	local BillboardGui = NewInstance("BillboardGui",EffectPart,{
		Size = UDim2.new(3,0,3,0),
		Adornee = EffectPart,
	})
 
	local TextLabel = NewInstance("TextLabel",BillboardGui,{
		BackgroundTransparency = 1,
		Size = UDim2.new(1, 0, 1, 0),
		Text = Text,
		TextColor3 = Color,
		TextScaled = true,
		Font = Enum.Font.ArialBold, 
	})
	S.Debris:AddItem(EffectPart, Time+.5)
	delay(0, function()
		local rot=math.random(-10,10)/15
		local raise=.2
		local Frames = Time/Frame_Speed
		for i=0,1.1,.02 do
			swait()
			TextLabel.Rotation=TextLabel.Rotation+rot
			raise=raise-.008
			EffectPart.Position = EffectPart.Position + Vector3.new(0, raise, 0)
			TextLabel.TextTransparency=i
			TextLabel.TextStrokeTransparency=i
		end
		if EffectPart and EffectPart.Parent then
			EffectPart:Destroy()
		end
	end)
end
 
 
local baseSound = IN("Sound")
 
function Soond(parent,id,pitch,volume,looped,effect,autoPlay)
	local Sound = baseSound:Clone()
	Sound.SoundId = "rbxassetid://".. tostring(id or 0)
	Sound.Pitch = pitch or 1
	Sound.Volume = volume or 1
	Sound.Looped = looped or false
	if(autoPlay)then
		coroutine.wrap(function()
			repeat wait() until Sound.IsLoaded
			Sound.Playing = autoPlay or false
		end)()
	end
	if(not looped and effect)then
		Sound.Stopped:connect(function()
			Sound.Volume = 0
			Sound:destroy()
		end)
	elseif(effect)then
		warn("Sound can't be looped and a sound effect!")
	end
	Sound.Parent =parent or Torso
	return Sound
end
 
function SoondPart(id,pitch,volume,looped,effect,autoPlay,cf)
	local soundPart = NewInstance("Part",Effects,{Transparency=1,CFrame=cf or Torso.CFrame,Anchored=true,CanCollide=false,Size=V3.N()})
	local Sound = IN("Sound")
	Sound.SoundId = "rbxassetid://".. tostring(id or 0)
	Sound.Pitch = pitch or 1
	Sound.Volume = volume or 1
	Sound.Looped = looped or false
	if(autoPlay)then
		coroutine.wrap(function()
			repeat wait() until Sound.IsLoaded
			Sound.Playing = autoPlay or false
		end)()
	end
	if(not looped and effect)then
		Sound.Stopped:connect(function()
			Sound.Volume = 0
			soundPart:destroy()
		end)
	elseif(effect)then
		warn("Sound can't be looped and a sound effect!")
	end
	Sound.Parent = soundPart
	return Sound,soundPart
end
 
function SoundPart(...)
	return SoondPart(...)
end
 
function Sound(...)
	return Soond(...)
end
 
function Part(parent,color,material,size,cframe,anchored,cancollide)
	local part = IN("Part")
	part.Parent = parent or Char
	part[typeof(color) == 'BrickColor' and 'BrickColor' or 'Color'] = color or C3.N(0,0,0)
	part.Material = material or Enum.Material.SmoothPlastic
	part.TopSurface,part.BottomSurface=10,10
	part.Size = size or V3.N(1,1,1)
	part.CFrame = cframe or CF.N(0,0,0)
	part.CanCollide = cancollide or false
	part.Anchored = anchored or false
	return part
end
 
function Weld(part0,part1,c0,c1)
	local weld = IN("Weld")
	weld.Parent = part0
	weld.Part0 = part0
	weld.Part1 = part1
	weld.C0 = c0 or CF.N()
	weld.C1 = c1 or CF.N()
	return weld
end
 
function Mesh(parent,meshtype,meshid,textid,scale,offset)
	local part = IN("SpecialMesh")
	part.MeshId = meshid or ""
	part.TextureId = textid or ""
	part.Scale = scale or V3.N(1,1,1)
	part.Offset = offset or V3.N(0,0,0)
	part.MeshType = meshtype or Enum.MeshType.Sphere
	part.Parent = parent
	return part
end
 
function GotEffect(data)
	-- just for easy reference
	local color = data.Color or Color3.new(.7,.7,.7);
	local endcolor = data.EndColor or nil;
	local mat = data.Material or Enum.Material.SmoothPlastic;
	local cframe = data.CFrame or CFrame.new();
	local endpos = data.EndPos or nil;
	local meshdata = data.Mesh or {}
	local sounddata = data.Sound or {}
	local size = data.Size or Vector3.new(1,1,1)
	local endsize = data.EndSize or Vector3.new(6,6,6)
	local rotinc = data.RotInc or {0,0,0} -- ONLY FOR LEGACY SYSTEM
	local transparency = data.Transparency or NumberRange.new(0,1)
	local acceleration = data.Acceleration or nil; -- ONLY FOR LEGACY SYSTEM
	local endrot = data.EndRotation or {0,0,0} -- ONLY FOR EXPERIMENTAL SYSTEM
	local style = data.Style or false; -- ONLY FOR EXPERIMENTAL SYSTEM
	local lifetime = data.Lifetime or 1;
	local system = data.FXSystem;
	local setpart = typeof(data.Part)=='string' and EffectFolder:FindFirstChild(tostring(data.Part)):Clone() or typeof(data.Part)=='Instance' and data.Part or nil
 
	local S,PM;
 
	local P = setpart or Part(Effects,color,mat,Vector3.new(1,1,1),cframe,true,false)
 
	if(not P:IsA'MeshPart' and not P:IsA'UnionOperation')then
		if(meshdata == "Blast")then
			PM = Mesh(P,Enum.MeshType.FileMesh,'rbxassetid://20329976','',size,Vector3.new(0,0,-size.X/8))
		elseif(meshdata == 'Ring')then
			PM = Mesh(P,Enum.MeshType.FileMesh,'rbxassetid://559831844','',size,Vector3.new(0,0,0))
		elseif(meshdata == 'Slash1')then
			PM = Mesh(P,Enum.MeshType.FileMesh,'rbxassetid://662586858','',Vector3.new(size.X/10,.001,size.Z/10),Vector3.new(0,0,0))
		elseif(meshdata == 'Slash2')then
			PM = Mesh(P,Enum.MeshType.FileMesh,'rbxassetid://448386996','',Vector3.new(size.X/1000,size.Y/100,size.Z/100),Vector3.new(0,0,0))
		elseif(meshdata == 'Tornado1')then
			PM = Mesh(P,Enum.MeshType.FileMesh,'rbxassetid://443529437','',size/10,Vector3.new(0,0,0))
		elseif(meshdata == 'Tornado2')then
			PM = Mesh(P,Enum.MeshType.FileMesh,'rbxassetid://168892432','',size/4,Vector3.new(0,0,0))
		elseif(meshdata == 'Skull')then
			PM = Mesh(P,Enum.MeshType.FileMesh,'rbxassetid://4770583','',size*2,Vector3.new(0,0,0))
		elseif(meshdata == 'Crystal')then
			PM = Mesh(P,Enum.MeshType.FileMesh,'rbxassetid://9756362','',size,Vector3.new(0,0,0))
		elseif(meshdata == 'Cloud')then
			PM = Mesh(P,Enum.MeshType.FileMesh,'rbxassetid://1095708','',size,Vector3.new(0,0,0))
		elseif(typeof(meshdata) == 'table')then
			local Type = meshdata.Type or Enum.MeshType.Brick
			local ID = meshdata.ID or '';
			local Tex = meshdata.Texture or '';
			local Offset = meshdata.Offset or Vector3.new(0,0,0)
			PM = Mesh(P,Type,ID,Tex,size,Offset)
		else
			PM = Mesh(P,Enum.MeshType.Brick,'','',size)
		end
	end
	local startTrans = typeof(transparency) == 'number' and transparency or typeof(transparency) == 'NumberRange' and transparency.Min or typeof(transparency) == 'table' and transparency[1] or 0
	local endTrans = typeof(transparency) == 'NumberRange' and transparency.Max or typeof(transparency) == 'table' and transparency[2] or 1
 
	P.Material = mat
	P.CFrame = cframe
	P.Color = (typeof(color)=='BrickColor' and color.Color or color)
	P.Anchored = true
	P.CanCollide = false
	P.Transparency = startTrans
	P.Parent = Effects
	local random = Random.new();
	game:service'Debris':AddItem(P,lifetime+3)
 
 
	-- actual effect stuff
	local mult = 1;
	if(PM)then
		if(PM.MeshId == 'rbxassetid://20329976')then
			PM.Offset = Vector3.new(0,0,-PM.Scale.Z/8)
		elseif(PM.MeshId == 'rbxassetid://4770583')then
			mult = 2
		elseif(PM.MeshId == 'rbxassetid://168892432')then
			mult = .25
		elseif(PM.MeshId == 'rbxassetid://443529437')then
			mult = .1
		elseif(PM.MeshId == 'rbxassetid://443529437')then
			mult = .1
		end
	end	
	coroutine.wrap(function()
		if(system == 'Legacy' or system == 1 or system == nil)then
			local frames = (typeof(lifetime) == 'NumberRange' and random:NextNumber(lifetime.Min,lifetime.Max) or typeof(lifetime) == 'number' and lifetime or 1)*Frame_Speed
			for i = 0, frames do
				local div = (i/frames)
				P.Transparency=(startTrans+(endTrans-startTrans)*div)
 
				if(PM)then PM.Scale = size:lerp(endsize*mult,div) else P.Size = size:lerp(endsize*mult,div) end
 
				local RotCF=CFrame.Angles(0,0,0)
 
				if(rotinc == 'random')then
					RotCF=CFrame.Angles(math.rad(random:NextNumber(-180,180)),math.rad(random:NextNumber(-180,180)),math.rad(random:NextNumber(-180,180)))
				elseif(typeof(rotinc) == 'table')then
					RotCF=CFrame.Angles(unpack(rotinc))
				end
 
				if(PM and PM.MeshId == 'rbxassetid://20329976')then
					PM.Offset = Vector3.new(0,0,-PM.Scale.Z/8)
				end
 
				if(endpos and typeof(endpos) == 'CFrame')then
					P.CFrame=cframe:lerp(endpos,div)*RotCF
				elseif(acceleration and typeof(acceleration) == 'table' and acceleration.Force)then
					local force = acceleration.Force;
					if(typeof(force)=='CFrame')then
						force=force.p;
					end
					if(typeof(force)=='Vector3')then
						if(acceleration.LookAt)then
							P.CFrame=(CFrame.new(P.Position,force)+force)*RotCF
						else
							P.CFrame=(P.CFrame+force)*RotCF
						end
					end
				else
					P.CFrame=P.CFrame*RotCF
				end
 
				if(endcolor and typeof(endcolor) == 'Color3')then
					P.Color = color:lerp(endcolor,div)
				end
				swait()
			end
			P:destroy()
		elseif(system == 'Experimental' or system == 2)then
			local info = TweenInfo.new(lifetime,style,Enum.EasingDirection.InOut,0,false,0)
			local info2 = TweenInfo.new(lifetime,Enum.EasingStyle.Linear,Enum.EasingDirection.InOut,0,false,0)
			if(style == Enum.EasingStyle.Elastic)then
				info = TweenInfo.new(lifetime*2,style,Enum.EasingDirection.Out,0,false,0)
			elseif(style == Enum.EasingStyle.Bounce)then
				info = TweenInfo.new(lifetime,style,Enum.EasingDirection.Out,0,false,0)
			end
			local tweenPart = game:service'TweenService':Create(P,info2,{
				CFrame=(typeof(endpos) == 'CFrame' and endpos or P.CFrame)*CFrame.Angles(unpack(endrot)),
				Color=typeof(endcolor) == 'Color3' and endcolor or color,
				Transparency=endTrans,
			})
			local off = Vector3.new(0,0,0)
			if(PM.MeshId == 'rbxassetid://20329976')then off=Vector3.new(0,0,(endsize*mult).Z/8) end
 
			local tweenMesh = game:service'TweenService':Create(PM,info,{
				Scale=endsize*mult,
				Offset=off,
			})
			tweenPart:Play()
			tweenMesh:Play()
		end
	end)()
end
 
function Effect(edata)
	GotEffect(edata)
end
 
function Trail(data)
	coroutine.wrap(function()
		data.Frames = typeof(data.Frames)=='number' and data.Frames or 60
		data.CFrame = typeof(data.CFrame)=='CFrame' and data.CFrame or Root.CFrame
		local ep = typeof(data.EndPos)=='CFrame' and data.EndPos or data.CFrame*CFrame.new(0,5,0);
		data.EndPos=nil
		local trailPart = Part(Effects,BrickColor.new'White',Enum.Material.SmoothPlastic,V3.N(.05,.05,.05),data.CFrame,true,false)
		trailPart.Transparency=1
		local start = data.CFrame
		for i = 1, data.Frames do
			trailPart.CFrame = start:lerp(ep,i/data.Frames)
			data.CFrame = trailPart.CFrame
			Effect(data)
			swait()
		end	
	end)()
end
 
function ClientTrail(data)
	coroutine.wrap(function()
		data.Frames = typeof(data.Frames)=='number' and data.Frames or 60
		data.CFrame = typeof(data.CFrame)=='CFrame' and data.CFrame or Root.CFrame
		local ep = typeof(data.EndPos)=='CFrame' and data.EndPos or data.CFrame*CFrame.new(0,5,0);
		data.EndPos=nil
		local trailPart = Part(Effects,BrickColor.new'White',Enum.Material.SmoothPlastic,V3.N(.05,.05,.05),data.CFrame,true,false)
		trailPart.Transparency=1
		local start = data.CFrame
		for i = 1, data.Frames do
			trailPart.CFrame = start:lerp(ep,i/data.Frames)
			data.CFrame = trailPart.CFrame
			GotEffect(data)
			swait()
		end	
	end)()
end
 
 
if(Char:FindFirstChild('NGRWings'..Player.Name))then
	Char['NGRWings'..Player.Name]:destroy()
end
 
for _,v in next, Char:children() do
	if(v.Name:lower():find'wings')then 
		v:destroy()
	end
end
 
local wingModel = Instance.new("Model",Char)
wingModel.Name="NGRWings"..Player.Name
local rightWing = NewInstance("Model",wingModel,{Name='Right'})
local leftWing = NewInstance("Model",wingModel,{Name='Left'})
 
local MPASword = {}
for _,v in pairs(Char:GetChildren()) do
	if v:IsA("Accessory") and v.Name:find("MeshPartAccessory") then
		table.insert(MPASword,v)
	end
end

local International = {}
for _,v in pairs(Char:GetChildren()) do
	if v:IsA("Accessory") and v.Name:find("InternationalFedora") then
		table.insert(International,v)
	end
end
 
local LWP1 = WingPiece:Clone();
if MPASword[1] then
	for _,v in pairs(LWP1:GetChildren()) do
		if v:IsA("BasePart") then
			v.Transparency = 1
		end
	end
	local athp = Instance.new("Attachment",LWP1.PrimaryPart)
	local atho = Instance.new("Attachment",LWP1.PrimaryPart)
 
	local HatChoice = MPASword[1]
	print(MPASword[1].Handle.Name)
	HatChoice.Handle:FindFirstChildOfClass("AlignPosition").Attachment1 = athp
	HatChoice.Handle:FindFirstChildOfClass("AlignOrientation").Attachment1 = atho
 
	athp.Position = Vector3.new(0,-2,0)
	atho.Rotation = Vector3.new(0,0,45)
	table.remove(MPASword,1)
end
LWP1.Parent = leftWing
local LWP2 = WingPiece:Clone();
if MPASword[1] then
	for _,v in pairs(LWP2:GetChildren()) do
		if v:IsA("BasePart") then
			v.Transparency = 1
		end
	end
	local athp = Instance.new("Attachment",LWP2.PrimaryPart)
	local atho = Instance.new("Attachment",LWP2.PrimaryPart)
 
	local HatChoice = MPASword[1]
	HatChoice.Handle:FindFirstChildOfClass("AlignPosition").Attachment1 = athp
	HatChoice.Handle:FindFirstChildOfClass("AlignOrientation").Attachment1 = atho
 
	athp.Position = Vector3.new(0,-2,0)
	atho.Rotation = Vector3.new(0,0,45)
	table.remove(MPASword,1)
end
LWP2.Parent = leftWing
local LWP3 = WingPiece:Clone();
if MPASword[1] then
	for _,v in pairs(LWP3:GetChildren()) do
		if v:IsA("BasePart") then
			v.Transparency = 1
		end
	end
	local athp = Instance.new("Attachment",LWP3.PrimaryPart)
	local atho = Instance.new("Attachment",LWP3.PrimaryPart)
 
	local HatChoice = MPASword[1]
	HatChoice.Handle:FindFirstChildOfClass("AlignPosition").Attachment1 = athp
	HatChoice.Handle:FindFirstChildOfClass("AlignOrientation").Attachment1 = atho
 
	athp.Position = Vector3.new(0,-1.75,0)
	atho.Rotation = Vector3.new(0,0,48)
        table.remove(MPASword,1)
end
LWP3.Parent = leftWing
local RWP1 = WingPiece:Clone();
if International[1] then
	for _,v in pairs(RWP1:GetChildren()) do
		if v:IsA("BasePart") then
			v.Transparency = 1
		end
	end
	local athp = Instance.new("Attachment",RWP1.PrimaryPart)
	local atho = Instance.new("Attachment",RWP1.PrimaryPart)
 
	local HatChoice = International[1]
	print(International[1].Handle.Name)
	HatChoice.Handle:FindFirstChildOfClass("AlignPosition").Attachment1 = athp
	HatChoice.Handle:FindFirstChildOfClass("AlignOrientation").Attachment1 = atho
 
	athp.Position = Vector3.new(0,-2,0)
	atho.Rotation = Vector3.new(0,0,45)
        table.remove(International,1)
end
RWP1.Parent = rightWing
local RWP2 = WingPiece:Clone();
if International[1] then
	for _,v in pairs(RWP2:GetChildren()) do
		if v:IsA("BasePart") then
			v.Transparency = 1
		end
	end
	local athp = Instance.new("Attachment",RWP2.PrimaryPart)
	local atho = Instance.new("Attachment",RWP2.PrimaryPart)
 
	local HatChoice = International[1]
	HatChoice.Handle:FindFirstChildOfClass("AlignPosition").Attachment1 = athp
	HatChoice.Handle:FindFirstChildOfClass("AlignOrientation").Attachment1 = atho
 
	athp.Position = Vector3.new(0,-2,0)
	atho.Rotation = Vector3.new(0,0,45)
        table.remove(International,1)
end
RWP2.Parent = rightWing
local RWP3 = WingPiece:Clone();
if Char:FindFirstChild("International Fedora") then
	for _,v in pairs(RWP3:GetChildren()) do
		if v:IsA("BasePart") then
			v.Transparency = 1
		end
	end
	local athp = Instance.new("Attachment",RWP3.PrimaryPart)
	local atho = Instance.new("Attachment",RWP3.PrimaryPart)
 
	local HatChoice = Char:FindFirstChild("International Fedora")
	HatChoice.Handle:FindFirstChildOfClass("AlignPosition").Attachment1 = athp
	HatChoice.Handle:FindFirstChildOfClass("AlignOrientation").Attachment1 = atho
	athp.Position = Vector3.new(0,-1.75,0)
	atho.Rotation = Vector3.new(0,0,48)
end
RWP3.Parent = rightWing
local LWP1W=Weld(LWP1.PrimaryPart,Torso,CF.N(2,-2,-1)*CF.A(0,0,0))
local LWP2W=Weld(LWP2.PrimaryPart,Torso,CF.N(4.25,-1,-1)*CF.A(0,0,M.R(15)))
local LWP3W=Weld(LWP3.PrimaryPart,Torso,CF.N(6.5,.5,-1)*CF.A(0,0,M.R(30)))
local RWP1W=Weld(RWP1.PrimaryPart,Torso,CF.N(-2,-2,-1)*CF.A(0,0,0))
local RWP2W=Weld(RWP2.PrimaryPart,Torso,CF.N(-4.25,-1,-1)*CF.A(0,0,M.R(-15)))
local RWP3W=Weld(RWP3.PrimaryPart,Torso,CF.N(-6.5,.5,-1)*CF.A(0,0,M.R(-30)))
 
local bbg=Head:FindFirstChild'Nametag' or NewInstance("BillboardGui",Head,{
	Adornee=Head;
	Name='Nametag';
	Size=UDim2.new(4,0,1.2,0);
	StudsOffset=V3.N(-8,5.3,0);
})
local text=bbg:FindFirstChild'TextLabel' or NewInstance("TextLabel",bbg,{
	Size=UDim2.new(5,0,3.5,0);
	TextScaled=true;
	BackgroundTransparency=1;
	TextStrokeTransparency=0;
	Font=Enum.Font.Arcade;
	TextColor3=C3.N(1,1,1);
	Text='Achromatic'
})
 
function getMode(modeName)
	for i,v in next, modeInfo do
		if(v.Name==modeName)then
			return v
		end
	end
	return modeInfo[1]
end
 
function IsVaporwave(song)
	for i = 1,#VaporwaveSongs do
		if(VaporwaveSongs[i]==song)then
			return true
		end
	end
	return false
end
 
local blush = NewInstance('Decal',Head,{Transparency=1,Texture='rbxassetid://0',Color3=(Player.UserId==5719877 and C3.N(.45,0,1) or C3.N(1,0,0))})
 
function changeMudo(modeName)
	local info = getMode(modeName)
	Mode=info.Name
	WalkSpeed=info.Walkspeed
	movement=info.moveVal
	music=makeMusic(info.Music or 0,info.Pitch or 1,info.TimePos or music and music.TimePosition or 0)
	WingAnim=info.WingAnim or 'NebG1'
	text.Text = info.Name
	text.TextColor3 = info.LeftWing[2]
	text.TextStrokeColor3 = info.StrokeColor
	text.Font=info.Font;
	if(Mode=='Love' or Mode=='Lust')then
		blush.Transparency=0
		blush.Texture='rbxassetid://2664127437'
	else
		blush.Transparency=1
		blush.Texture='rbxassetid://0'
	end
	for _,v in next,leftWing:GetDescendants() do
		if(v:IsA'BasePart' and v.Name~='Main')then
			--v.Transparency=info.LeftWing[1]
			v.Color=info.LeftWing[2]
			v.Material=info.LeftWing[3]
		elseif(v:IsA'Trail')then
			--v.Transparency=NumberSequence.new(info.LeftWing[1],1)
			v.Color=ColorSequence.new(info.LeftWing[2])	
		end
	end
 
	for _,v in next,rightWing:GetDescendants() do
		if(v:IsA'BasePart' and v.Name~='Main')then
			--v.Transparency=info.RightWing[1]
			v.Color=info.RightWing[2]
			v.Material=info.RightWing[3]
		elseif(v:IsA'Trail')then
			--v.Transparency=NumberSequence.new(info.RightWing[1],1)
			v.Color=ColorSequence.new(info.RightWing[2])	
		end
	end
 
	PrimaryColor = info.PrimaryColor or info.LeftWing[2]
end
 
function changeMode(modeName)
	changeMudo(modeName)
end	
 
function syncStuff(data)
	local neut,legwelds,c0s,c1s,sine,mov,walk,inc,musicmode,tpos,pit,wingsin,visSett,mode,newhue=unpack(data)
	local head0,torso0,rleg0,rarm0,lleg0,larm0=unpack(c0s)
	local head1,torso1,rleg1,rarm1,lleg1,larm1=unpack(c1s)
	legAnims=legwelds
	NeutralAnims=neut
	if(not neut)then
		NK.C0=head0
		RJ.C0=torso0
		RH.C0=rleg0
		RS.C0=rarm0
		LH.C0=lleg0
		LS.C0=larm0
 
		NK.C1=head1
		RJ.C1=torso1
		RH.C1=rleg1
		RS.C1=rarm1
		LH.C1=lleg1
		LS.C1=larm1
	end
	if(Mode~=mode)then
		changeMudo(mode)
	end
	movement=mov
	walking=walk
	Change=inc
	print(MusicMode,musicmode)
	if(musicmode~=MusicMode and music)then
		MusicMode=musicmode
		if(MusicMode==1)then
			music:Pause()
			music.Volume=5
			music.Parent=Torso
			music:Resume()
		elseif(MusicMode==2)then
			music:Pause()
			music.Volume=5
			music.Parent=Char
			music:Resume()
		elseif(MusicMode==3)then
			music.Volume = 0
		end
	end
	if(Sine-sine>.8 or Sine-sine<-.8)then
		Sine=sine
	end
	if(hue-newhue>.8 or hue-newhue<-.8)then
		hue=newhue
	end
	if(WingSine-wingsin>.8 or WingSine-wingsin<-.8)then
		WingSine=wingsin
	end
	if(music and (music.TimePosition-tpos>.8 or music.TimePosition-tpos<-.8))then
		music.TimePosition=tpos
	end
	if(music and pit)then
		music.Pitch = pit
	end
	if(Mode=='Troubadour' and music.SoundId~='rbxassetid://'..visSett.Music)then
		music.SoundId='rbxassetid://'..visSett.Music
	end
	getMode('Troubadour').Music = visSett.Music
	getMode('Troubadour').Pitch = visSett.Pitch
end
 
 
local footstepSounds = {
	[Enum.Material.Grass]=510933218;
	[Enum.Material.Metal]=1263161138;
	[Enum.Material.CorrodedMetal]=1263161138;
	[Enum.Material.DiamondPlate]=1263161138;
	[Enum.Material.Wood]=2452053757;
	[Enum.Material.WoodPlanks]=2452053757;
	[Enum.Material.Sand]=134456884;
	[Enum.Material.Snow]=2452051182;
}
 
 
function Vaporwaveify(s)
	local function wide(a)
		if a<'!' or a>'~' then return a end
		if a==' ' then return '  ' end 
		a = a:byte()+160
		if a<256 then return string.char(239,188,a-64) end
		return string.char(239,189,a-128)
	end
	return(s:gsub(".",wide))
end
 
 
 
function Choot(text)
	--if(game.PlaceId ~= 843468296)then
		coroutine.wrap(function()
			if(Char:FindFirstChild'ChatGUI')then Char.ChatGUI:destroy() end
			local BBG = NewInstance("BillboardGui",Char,{Name='ChatGUI',Size=UDim2.new(0,100,0,40),StudsOffset=V3.N(0,2,0),Adornee=Head})
			local Txt = NewInstance("TextLabel",BBG,{Text = "",BackgroundTransparency=1,TextColor3=PrimaryColor,BorderSizePixel=0,Font=Enum.Font.Antique,TextSize=50,TextStrokeTransparency=1,Size=UDim2.new(1,0,.5,0)})
			for i = 1, #text do
				--Txt.Text = Vaporwaveify(text:sub(1,i))
				Txt.TextColor3=(Mode=='Troubadour' and Color3.fromHSV(hue/360,1,math.clamp(music.PlaybackLoudness/475,0,1)) or PrimaryColor)
				if(vaporwaveMode and Mode=='Troubadour')then
					Txt.Text = Vaporwaveify(text:sub(1,i))
				else
					Txt.Text = text:sub(1,i)
				end
				wait((vaporwaveMode) and .1 or .025)
			end
			for i = 0, 60 do
				Txt.TextColor3=(Mode=='Troubadour' and Color3.fromHSV(hue/360,1,math.clamp(music.PlaybackLoudness/475,0,1)) or PrimaryColor)
				swait()
			end
			for i = 0, 1, .025 do
				Txt.TextTransparency=i
				swait()
			end
			BBG:destroy()
		end)()
	--else
	--	Chat2(text)
	--end
end
 
function Chat(text)
	Choot(text)
end
 
function DealDamage(...)
	return true
end
 
function getRegion(point,range,ignore)
    return workspace:FindPartsInRegion3WithIgnoreList(R3.N(point-V3.N(1,1,1)*range/2,point+V3.N(1,1,1)*range/2),ignore,100)
end
function AOEDamage(where,range,options)
	local hit = {}
	for _,v in next, getRegion(where,range,{Char}) do
		if(v.Parent and v.Parent:FindFirstChildOfClass'Humanoid' and not hit[v.Parent:FindFirstChildOfClass'Humanoid'])then
			local callTable = {Who=v.Parent}
			hit[v.Parent:FindFirstChildOfClass'Humanoid'] = true
			for _,v in next, options do callTable[_] = v end
			DealDamage(callTable)
		end
	end
	return hit
end
 
 
function Click1()
	Attack=true
	NeutralAnims=false
	legAnims=false
	local orig = WalkSpeed
	WalkSpeed=4
	for i = 0, 1, 0.1 do
		swait()
		local Alpha = .3
		RJ.C0 = RJ.C0:lerp(CF.N(0,0,0)*CF.A(M.R(0),M.R(-44.6),M.R(0)),Alpha)
		LH.C0 = LH.C0:lerp(CF.N(-0.8,-1,-0.3)*CF.A(M.R(-17.4),M.R(44.4),M.R(7.1)),Alpha)
		RH.C0 = RH.C0:lerp(CF.N(0.4,-1,0)*CF.A(M.R(1.6),M.R(-13.1),M.R(7)),Alpha)
		LS.C0 = LS.C0:lerp(CF.N(-1.3,0.5,-0.3)*CF.A(M.R(90),M.R(0),M.R(-44.6)),Alpha)
		RS.C0 = RS.C0:lerp(CF.N(1.4,0.5,-0.1)*CF.A(M.R(90),M.R(0),M.R(-44.6)),Alpha)
		NK.C0 = NK.C0:lerp(CF.N(0,1.5,0)*CF.A(M.R(0),M.R(44.6),M.R(0)),Alpha)
	end
	for i = 0, 1, 0.1 do
		swait()
		AOEDamage(RArm.CFrame.p,2,{
			DamageColor=(Mode=='Troubadour' and C3.HSV(hue/360,1,math.clamp(music.PlaybackLoudness/475,0,1)) or PrimaryColor);
			MinimumDamage=5;
			MaximumDamage=15;
		})
		local Alpha = .3
		RJ.C0 = RJ.C0:lerp(CF.N(0,0,-0.7)*CF.A(M.R(0),M.R(50.5),M.R(0)),Alpha)
		LH.C0 = LH.C0:lerp(CF.N(-0.5,-0.7,-0.6)*CF.A(M.R(-26),M.R(0),M.R(0)),Alpha)
		RH.C0 = RH.C0:lerp(CF.N(0.6,-1.1,-0.1)*CF.A(M.R(20.2),M.R(-47.6),M.R(15.2)),Alpha)
		LS.C0 = LS.C0:lerp(CF.N(-1.3,0.5,0)*CF.A(M.R(0),M.R(0),M.R(-20.4)),Alpha)
		RS.C0 = RS.C0:lerp(CF.N(1.4,0.5,-0.5)*CF.A(M.R(90),M.R(0),M.R(50.5)),Alpha)
		NK.C0 = NK.C0:lerp(CF.N(0,1.5,0)*CF.A(M.R(0),M.R(-50.5),M.R(0)),Alpha)
	end
	WalkSpeed=orig
	legAnims=true
	Attack=false
	NeutralAnims=true
end
 
function SwordSummon()
	Attack = true
	NeutralAnims = false
	local orig=WalkSpeed
	WalkSpeed=4
	legAnims=false
	for i = 0, 1, 0.1 do
		swait()
		local Alpha = .3
		Effect{
			Lifetime=.25;
			Mesh={Type=Enum.MeshType.Sphere};
			CFrame=RArm.CFrame*CF.N(0,-1,0)*CF.A(M.RRNG(0,360),M.RRNG(0,360),M.RRNG(0,360));
			Color=PrimaryColor;
			Transparency={.5,1};
			Material=Enum.Material.Neon;
			Size=Vector3.new(.6,1,.6);
			EndSize=Vector3.new(.1,3,.1);
		}
		RJ.C0 = RJ.C0:lerp(CF.N(0,-0.2,-0.1)*CF.A(M.R(-12.4),M.R(-15.7),M.R(0)),Alpha)
		LH.C0 = LH.C0:lerp(CF.N(-0.5,-0.7,-0.5)*CF.A(M.R(16.2),M.R(15.2),M.R(-0.8)),Alpha)
		RH.C0 = RH.C0:lerp(CF.N(0.5,-1,0)*CF.A(M.R(-28.5),M.R(0),M.R(0)),Alpha)
		LS.C0 = LS.C0:lerp(CF.N(-1.4,0.5,0)*CF.A(M.R(27.2),M.R(-3.8),M.R(-5)),Alpha)
		RS.C0 = RS.C0:lerp(CF.N(1.3,0.6,0)*CF.A(M.R(-33.8),M.R(-18.1),M.R(24.8)),Alpha)
		NK.C0 = NK.C0:lerp(CF.N(0,1.5,0)*CF.A(M.R(13.4),M.R(15.3),M.R(-3.6)),Alpha)
	end
	for i = 0, 5 do
		delay(.05*i,function()
			local pos = Root.CFrame*CF.N(0,-2,-2-i*4)*CF.A(M.R(80),0,0)
			local pos2 = Root.CFrame*CF.N(0,-3,-2-i*4)
			Camshake({
			    Duration=.2;
				FadeOut=.2;
			    Intensity=1.5;
			    Position=Vector3.new(.5,.5,.5);
			    Rotation=Vector3.new(.5,.5,3);
			    DropDist=15;
			    IneffectiveDist=40;
			    Origin=pos2;
			})
			AOEDamage(pos.p,5,{
				DamageColor=(Mode=='Troubadour' and C3.HSV(hue/360,1,math.clamp(music.PlaybackLoudness/475,0,1)) or PrimaryColor);
				MinimumDamage=(Mode=='Troubadour' and music.PlaybackLoudness/10 or 10);
				MaximumDamage=(Mode=='Troubadour' and music.PlaybackLoudness/8 or 35);
			})
			SoundPart(178452221,1,2,false,true,true,pos)
			Effect{
				Lifetime=.4;
				Part='Sword',
				--Mesh={Type=Enum.MeshType.Sphere};
				CFrame=pos;
				Color=PrimaryColor;
				Transparency={0,1};
				Material=Enum.Material.Neon;
				Size=V3.N(0.8,2.5,6.8);
				EndSize=V3.N(0.8,2.5,16);
			}
			Effect{
				Lifetime=.4;
				Mesh={Type=Enum.MeshType.Sphere};
				CFrame=pos2;
				Color=PrimaryColor;
				Transparency={0,1};
				Material=Enum.Material.Neon;
				Size=V3.N(4,.1,4);
				EndSize=V3.N(6,.1,6);
			}
			Effect{
				Lifetime=.1;
				Mesh={Type=Enum.MeshType.Sphere};
				CFrame=pos;
				Color=PrimaryColor;
				Transparency={0,1};
				Material=Enum.Material.Neon;
				Size=V3.N(7,7,7);
				EndSize=V3.N(12,12,12);
			}
			for i = 1, 5 do
				Effect{
					Lifetime=.5;
					Mesh={Type=Enum.MeshType.Sphere};
					CFrame=pos;
					Color=PrimaryColor;
					Transparency={0,1};
					Material=Enum.Material.Neon;
					Size=V3.N(1,1,1);
					EndSize=V3.N(1,1,1);
					Acceleration={Force=V3.N(M.RNG(-75,75)/100,M.RNG(-75,75)/100,M.RNG(-75,75)/100)};
				}
			end
		end)
	end
	for i = 0, 1, 0.1 do
		swait()
		local Alpha = .3
		RJ.C0 = RJ.C0:lerp(CF.N(0,0,0)*CF.A(M.R(0),M.R(70.7),M.R(0)),Alpha)
		LH.C0 = LH.C0:lerp(CF.N(-0.5,-1,0)*CF.A(M.R(0),M.R(0),M.R(-14.4)),Alpha)
		RH.C0 = RH.C0:lerp(CF.N(0.6,-1,0)*CF.A(M.R(15.1),M.R(-63.2),M.R(13.5)),Alpha)
		LS.C0 = LS.C0:lerp(CF.N(-1.3,0.6,-0.1)*CF.A(M.R(0),M.R(15.9),M.R(-25.4)),Alpha)
		RS.C0 = RS.C0:lerp(CF.N(1.4,0.3,-0.2)*CF.A(M.R(0),M.R(19.3),M.R(157.1)),Alpha)
		NK.C0 = NK.C0:lerp(CF.N(0,1.5,0)*CF.A(M.R(0),M.R(-70.7),M.R(0)),Alpha)
	end
	legAnims=true
	WalkSpeed=orig
	Attack = false
	NeutralAnims = true
end
 
function Bombs()
	Attack=true
	NeutralAnims=false
	legAnims=false
	local orig = WalkSpeed
	WalkSpeed=0
	for i = 0, 1, 0.1 do
		swait()
		local Alpha = .3
		RJ.C0 = RJ.C0:lerp(CF.N(0,0,0)*CF.A(M.R(0),M.R(0),M.R(0)),Alpha)
		LH.C0 = LH.C0:lerp(CF.N(-0.5,-1,0)*CF.A(M.R(0),M.R(0),M.R(0)),Alpha)
		RH.C0 = RH.C0:lerp(CF.N(0.5,-1,0)*CF.A(M.R(0),M.R(0),M.R(0)),Alpha)
		LS.C0 = LS.C0:lerp(CF.N(-1.3,0.5,-0.5)*CF.A(M.R(90),M.R(0),M.R(19.1)),Alpha)
		RS.C0 = RS.C0:lerp(CF.N(1.3,0.5,-0.5)*CF.A(M.R(90),M.R(0),M.R(-21.3)),Alpha)
		NK.C0 = NK.C0:lerp(CF.N(0,1.5,0)*CF.A(M.R(0),M.R(0),M.R(0)),Alpha)
	end
	coroutine.wrap(function()
		for i = 0, 2 do
			Camshake({
			    Duration=.2;
				FadeOut=.2;
			    Intensity=1.5;
			    Position=Vector3.new(.5,.5,.5);
			    Rotation=Vector3.new(.5,.5,3);
			    DropDist=15;
			    IneffectiveDist=40;
			    Origin=Root.CFrame*CF.N(0,0,-4-i*4);
			})
			SoundPart(206083252,.8,4,false,true,true,Root.CFrame*CF.N(0,0,-4-i*4))
			AOEDamage(Root.CFrame*CF.N(0,0,-4-i*4).p,5,{
				DamageColor=PrimaryColor;
				MinimumDamage=25;
				MaximumDamage=45;
			})
			Effect{
				Lifetime=.4;
				Mesh={Type=Enum.MeshType.Sphere};
				Color=PrimaryColor;
				Material=Enum.Material.Neon;
				CFrame=Root.CFrame*CF.N(0,0,-4-i*4);
				Size=V3.N(1,1,1);
				EndSize=V3.N(10,10,10);
			}
			Effect{
				Lifetime=.4;
				Part='Ring';
				Color=PrimaryColor;
				Material=Enum.Material.Neon;
				CFrame=Root.CFrame*CF.N(0,0,-4-i*4)*CF.A(M.RRNG(0,360),M.RRNG(0,360),M.RRNG(0,360));
				RotInc={M.RNG(-25,25)/100,M.RNG(-25,25)/100,M.RNG(-25,25)/100};
				Size=V3.N(4,4,.2);
				EndSize=V3.N(13,13,.2);
			}
			Effect{
				Lifetime=.4;
				Part='Ring';
				Color=PrimaryColor;
				Material=Enum.Material.Neon;
				CFrame=Root.CFrame*CF.N(0,0,-4-i*4)*CF.A(M.RRNG(0,360),M.RRNG(0,360),M.RRNG(0,360));
				RotInc={M.RNG(-25,25)/100,M.RNG(-25,25)/100,M.RNG(-25,25)/100};
				Size=V3.N(4,4,.2);
				EndSize=V3.N(13,13,.2);
			}
			swait(4)
		end
	end)()
	for i = 0, 1, 0.1 do
		swait()
		local Alpha = .3
		RJ.C0 = RJ.C0:lerp(CF.N(0,-0.2,0.7)*CF.A(M.R(18.2),M.R(0),M.R(0)),Alpha)
		LH.C0 = LH.C0:lerp(CF.N(-0.5,-1.1,-0.4)*CF.A(M.R(-33.4),M.R(0),M.R(0)),Alpha)
		RH.C0 = RH.C0:lerp(CF.N(0.5,-0.9,-0.2)*CF.A(M.R(-6.7),M.R(0),M.R(0)),Alpha)
		LS.C0 = LS.C0:lerp(CF.N(-1.4,0.4,0.1)*CF.A(M.R(90.7),M.R(-2.5),M.R(-50)),Alpha)
		RS.C0 = RS.C0:lerp(CF.N(1.4,0.5,0.2)*CF.A(M.R(89.5),M.R(2.6),M.R(50)),Alpha)
		NK.C0 = NK.C0:lerp(CF.N(0,1.5,0)*CF.A(M.R(0),M.R(0),M.R(0)),Alpha)
	end
	WalkSpeed=orig
	legAnims=true
	Attack=false
	NeutralAnims=true
end
 
 
function ClickCombo()
	ClickTimer=180
	if(Combo==1)then
		Click1()
		Combo=2
	elseif(Combo==2)then
		SwordSummon()
		Combo=3
	elseif(Combo==3)then
		Bombs()
		Combo=1
	end
end
 
function VaporTaunt()
	Attack = true
	NeutralAnims = false
	local orig=WalkSpeed
	WalkSpeed=0
	legAnims=false
	Chat"You need to chill out.."
	for i = 0, 14, 0.1 do
		swait()
		local Alpha = .1
		RJ.C0 = RJ.C0:lerp(CF.N(-0.1,-0.1-.1*M.S(Sine/36),0.6)*CF.A(M.R(55.3+2.5*M.C(Sine/36)),M.R(0),M.R(0)),Alpha)
		LH.C0 = LH.C0:lerp(CF.N(-0.6,-1.2,-0.1)*CF.A(M.R(56.3+10*M.C(Sine/36)),M.R(0),M.R(24)),Alpha)
		RH.C0 = RH.C0:lerp(CF.N(0.9,-1.2,-0.2)*CF.A(M.R(25+5*M.C(Sine/36)),M.R(3.5),M.R(-43.9)),Alpha)
		LS.C0 = LS.C0:lerp(CF.N(-1,0.8,0)*CF.A(M.R(11.4-5*M.C(Sine/42)),M.R(-3.3),M.R(137.5)),Alpha)
		RS.C0 = RS.C0:lerp(CF.N(1.4,0.5,-0.2)*CF.A(M.R(61-5*M.C(Sine/42)),M.R(0),M.R(0)),Alpha)
		NK.C0 = NK.C0:lerp(CF.N(0,1.4,-0.3)*CF.A(M.R(-38.9-5*M.C(Sine/42)),M.R(0),M.R(0)),Alpha)
	end
	legAnims=true
	WalkSpeed=orig
	Attack = false
	NeutralAnims = true
end
 
 
 
UIS.InputBegan:connect(function(io,gpe)
	if(gpe or Attack or data.User~=data.Local)then return end
	--MODES
	if(io.KeyCode == Enum.KeyCode.One and Mode~='Achromatic')then 
		changeMode'Achromatic'
	elseif(io.KeyCode == Enum.KeyCode.Two and Mode~='Iniquitous')then 
		changeMode'Iniquitous'
	elseif(io.KeyCode == Enum.KeyCode.Three and Mode~='Mythical')then 
		changeMode'Mythical'
	elseif(io.KeyCode == Enum.KeyCode.Four and Mode~='Ruined')then 
		changeMode'Ruined'
	elseif(io.KeyCode == Enum.KeyCode.Five and Mode~='Atramentous')then 
		changeMode'Atramentous'
	elseif(io.KeyCode == Enum.KeyCode.Six and Mode~='Subzero')then 
		changeMode'Subzero'
	elseif(io.KeyCode == Enum.KeyCode.Seven and Mode~='Troubadour')then 
		changeMode'Troubadour'
	elseif(io.KeyCode == Enum.KeyCode.Eight and Mode~='Infectious')then 
		changeMode'Infectious'
	elseif(io.KeyCode == Enum.KeyCode.Nine and Mode~='Love')then 
		changeMode'Love'
	elseif(io.KeyCode == Enum.KeyCode.Y and Mode=='Achromatic')then 
		changeMode'The Big Black'
	elseif(io.KeyCode == Enum.KeyCode.Y and Mode=='Mythical')then 
		changeMode'Legendary'
 
	elseif(io.KeyCode == Enum.KeyCode.Y and Mode=='Love')then 
		changeMode'Lust'
	--TOGGLE MUSIC
	elseif(io.KeyCode == Enum.KeyCode.M and getMode(Mode))then 
		MusicMode=MusicMode+1
		if(MusicMode>3)then MusicMode=1 end
		if(MusicMode==1)then
			music:Pause()
			music.Volume=5
			music.Parent=Torso
			music:Resume()
		elseif(MusicMode==2)then
			music:Pause()
			music.Volume=5
			music.Parent=Char
			music:Resume()
		elseif(MusicMode==3)then
			music.Volume = 0
		end
	elseif(io.KeyCode==Enum.KeyCode.B)then
		--TAUNTS
		if(vaporwaveMode and Mode=='Troubadour')then
			VaporTaunt()
		end
	end
	if(vaporwaveMode)then return end
	--ATTACKS
	if(io.UserInputType==Enum.UserInputType.MouseButton1)then
		ClickCombo()
	end
end)
 
WingAnims.StarG=function()
	LWP1W.C0 = LWP1W.C0:lerp(CF.N(2,-2,-1)*CF.A(M.R(5+10*M.C(WingSine/32)),0,M.R(0+5*M.C(WingSine/32))),.2)
	LWP2W.C0 = LWP2W.C0:lerp(CF.N(4.25,-1,-1)*CF.A(M.R(10+15*M.C(WingSine/32)),0,M.R(15+7.5*M.C(WingSine/32))),.2)
	LWP3W.C0 = LWP3W.C0:lerp(CF.N(6.5,.5,-1)*CF.A(M.R(15+20*M.C(WingSine/32)),0,M.R(30+9*M.C(WingSine/32))),.2)
 
	RWP1W.C0 = RWP1W.C0:lerp(CF.N(-2,-2,-1)*CF.A(M.R(5+10*M.C(WingSine/32)),0,M.R(0-5*M.C(WingSine/32))),.2)
	RWP2W.C0 = RWP2W.C0:lerp(CF.N(-4.25,-1,-1+.05*M.S(WingSine/35))*CF.A(M.R(10+15*M.C(WingSine/32)),0,M.R(-15-7.5*M.C(WingSine/32))),.2)
	RWP3W.C0 = RWP3W.C0:lerp(CF.N(-6.5,.5,-1)*CF.A(M.R(15+20*M.C(WingSine/32)),0,M.R(-30-9*M.C(WingSine/32))),.2)
end
 
WingAnims.Cytus=function()
	LWP1W.C0 = LWP1W.C0:lerp(CF.N(.15*M.C(WingSine/32),1.5+.35*M.S(WingSine/32),-1)*CF.A(0,0,M.R(60+5*M.C(WingSine/32))),.2)
	LWP2W.C0 = LWP2W.C0:lerp(CF.N(.1*M.C(WingSine/32),1.5+.25*M.C(WingSine/32),-1)*CF.A(0,0,M.R(90+2.5*M.C(WingSine/32))),.2)
	LWP3W.C0 = LWP3W.C0:lerp(CF.N(.25*M.C(WingSine/32),1.5-.05*M.S(WingSine/32),-1)*CF.A(0,0,M.R(120-5*M.C(WingSine/32))),.2)
 
	RWP1W.C0 = RWP1W.C0:lerp(CF.N(-.15*M.C(WingSine/32),1.5-.15*M.C(WingSine/32),-1)*CF.A(0,0,M.R(-60-5*M.C(WingSine/32))),.2)
	RWP2W.C0 = RWP2W.C0:lerp(CF.N(-.1*M.C(WingSine/32),1.5+.3*M.S(WingSine/32),-1)*CF.A(0,0,M.R(-90-2.5*M.C(WingSine/32))),.2)
	RWP3W.C0 = RWP3W.C0:lerp(CF.N(-.25*M.C(WingSine/32),1.5+.15*M.S(WingSine/32),-1)*CF.A(0,0,M.R(-120+5*M.C(WingSine/32))),.2)
end
 
WingAnims.Aprins=function()
	LWP1W.C0 = LWP1W.C0:lerp(CF.N(0,1.5,-1)*CF.A(0,M.R(0+2.5*M.C(WingSine/36)),M.R(60+5000*M.C(WingSine/400))),.2)
	LWP2W.C0 = LWP2W.C0:lerp(CF.N(0,1.5,-1)*CF.A(0,M.R(0+7.5*M.C(WingSine/32)),M.R(90+5000*M.C(WingSine/400))),.2)
	LWP3W.C0 = LWP3W.C0:lerp(CF.N(0,1.5,-1)*CF.A(0,M.R(0+5*M.C(WingSine/39)),M.R(120+5000*M.C(WingSine/400))),.2)
 
	RWP1W.C0 = RWP1W.C0:lerp(CF.N(0,1.5,-1)*CF.A(0,M.R(0+2.5*M.C(WingSine/36)),M.R(-60+5000*M.C(WingSine/400))),.2)
	RWP2W.C0 = RWP2W.C0:lerp(CF.N(0,1.5,-1)*CF.A(0,M.R(0+7.5*M.C(WingSine/32)),M.R(-90+5000*M.C(WingSine/400))),.2)
	RWP3W.C0 = RWP3W.C0:lerp(CF.N(0,1.5,-1)*CF.A(0,M.R(0+5*M.C(WingSine/39)),M.R(-120+5000*M.C(WingSine/400))),.2)
end
 
WingAnims.NebG1=function()
	LWP1W.C0 = LWP1W.C0:lerp(CF.N(.15,1.5,-1)*CF.A(M.R(5+10*M.C(WingSine/32)),0,M.R(60)),.2)
	LWP2W.C0 = LWP2W.C0:lerp(CF.N(.1,1.5,-1)*CF.A(M.R(10+15*M.C(WingSine/32)),0,M.R(90)),.2)
	LWP3W.C0 = LWP3W.C0:lerp(CF.N(.25,1.5,-1)*CF.A(M.R(15+20*M.C(WingSine/32)),0,M.R(120)),.2)
 
	RWP1W.C0 = RWP1W.C0:lerp(CF.N(-.15,1.5,-1)*CF.A(M.R(5+10*M.C(WingSine/32)),0,M.R(-60)),.2)
	RWP2W.C0 = RWP2W.C0:lerp(CF.N(-.1,1.5,-1)*CF.A(M.R(10+15*M.C(WingSine/32)),0,M.R(-90)),.2)
	RWP3W.C0 = RWP3W.C0:lerp(CF.N(-.25,1.5,-1)*CF.A(M.R(15+20*M.C(WingSine/32)),0,M.R(-120)),.2)
end
 
WingAnims.NebG2=function(div)
	div=div or 25
	LWP1W.C0 = LWP1W.C0:lerp(CF.N(0,1.5,-1)*CF.A(0,M.R(0+2.5*M.C(WingSine/36)),M.R(0+2000*M.R(WingSine/div))),.2)
	LWP2W.C0 = LWP2W.C0:lerp(CF.N(0,1.5,-1)*CF.A(0,M.R(0+7.5*M.C(WingSine/32)),M.R(120+2000*M.R(WingSine/div))),.2)
	LWP3W.C0 = LWP3W.C0:lerp(CF.N(0,1.5,-1)*CF.A(0,M.R(0+5*M.C(WingSine/39)),M.R(-120+2000*M.R(WingSine/div))),.2)
 
	RWP1W.C0 = RWP1W.C0:lerp(CF.N(0,4.5,-1)*CF.A(0,M.R(0+2.5*M.C(WingSine/36)),M.R(0-2000*M.R(WingSine/div))),.2)
	RWP2W.C0 = RWP2W.C0:lerp(CF.N(0,4.5,-1)*CF.A(0,M.R(0+7.5*M.C(WingSine/32)),M.R(120-2000*M.R(WingSine/div))),.2)
	RWP3W.C0 = RWP3W.C0:lerp(CF.N(0,4.5,-1)*CF.A(0,M.R(0+5*M.C(WingSine/39)),M.R(-120-2000*M.R(WingSine/div))),.2)
end
 
WingAnims.NebG3=function(mult)
	mult=mult or 1
	LWP1W.C0 = LWP1W.C0:lerp(CF.N(0,1.5,-1)*CF.A(0,M.R(0+2.5*M.C(WingSine/36)),M.R(0+WingSine*mult)),.2)
	LWP2W.C0 = LWP2W.C0:lerp(CF.N(0,1.5,-1)*CF.A(0,M.R(0+7.5*M.C(WingSine/32)),M.R(135+WingSine*mult)),.2)
	LWP3W.C0 = LWP3W.C0:lerp(CF.N(0,1.5,-1)*CF.A(0,M.R(0+5*M.C(WingSine/39)),M.R(225+WingSine*mult)),.2)
 
	RWP1W.C0 = RWP1W.C0:lerp(CF.N(0,1.5,-1.5)*CF.A(0,M.R(0+2.5*M.C(WingSine/36)),M.R(0-WingSine*mult)),.2)
	RWP2W.C0 = RWP2W.C0:lerp(CF.N(0,1.5,-1.5)*CF.A(0,M.R(0+7.5*M.C(WingSine/32)),M.R(135-WingSine*mult)),.2)
	RWP3W.C0 = RWP3W.C0:lerp(CF.N(0,1.5,-1.5)*CF.A(0,M.R(0+5*M.C(WingSine/39)),M.R(225-WingSine*mult)),.2)
end
 
WingAnims.LustFrench=function()
	LWP1W.C0 = LWP1W.C0:lerp(CF.N(0,1.5,0)*CF.A(0,M.R(0+2.5*M.C(WingSine/36)),M.R(0+WingSine))*CF.A(0,M.R(90),0)*CF.N(-2,0,0),.2)
	LWP2W.C0 = LWP2W.C0:lerp(CF.N(0,1.5,0)*CF.A(0,M.R(0+7.5*M.C(WingSine/32)),M.R(135+WingSine))*CF.A(0,M.R(90),0)*CF.N(-2,0,0),.2)
	LWP3W.C0 = LWP3W.C0:lerp(CF.N(0,1.5,0)*CF.A(0,M.R(0+5*M.C(WingSine/39)),M.R(225+WingSine))*CF.A(0,M.R(90),0)*CF.N(-2,0,0),.2)
 
	RWP1W.C0 = RWP1W.C0:lerp(CF.N(0,1.5,0)*CF.A(0,M.R(0+2.5*M.C(WingSine/36)),M.R(0-WingSine))*CF.A(0,M.R(90),0)*CF.N(-2,0,0),.2)
	RWP2W.C0 = RWP2W.C0:lerp(CF.N(0,1.5,0)*CF.A(0,M.R(0+7.5*M.C(WingSine/32)),M.R(135-WingSine))*CF.A(0,M.R(90),0)*CF.N(-2,0,0),.2)
	RWP3W.C0 = RWP3W.C0:lerp(CF.N(0,1.5,0)*CF.A(0,M.R(0+5*M.C(WingSine/39)),M.R(225-WingSine))*CF.A(0,M.R(90),0)*CF.N(-2,0,0),.2)
end
 
if(data.User==data.Local)then
	Player.Chatted:connect(function(m)
		if(m:sub(1,3) == "/e")then m=m:sub(4) end
		if(m:sub(1,5) == "play/")then
			getMode('Troubadour').Music=Playlist[m:sub(6)] or tonumber(m:sub(6)) or 0
			music.SoundId="rbxassetid://"..getMode('Troubadour').Music;
		elseif(m:sub(1,5) == "tpos/")then
			music.TimePosition = tonumber(m:sub(6)) or 0
		elseif(m:sub(1,6) == "pitch/")then
			music.Pitch = tonumber(m:sub(7)) or 0
			getMode('Troubadour').Pitch=music.Pitch
		end
	end)
end
 
 
while true do
	swait()
	ClickTimer=math.max(ClickTimer-1,0)
	if(ClickTimer<=0 and Combo~=1)then
		print('reset')
		Combo=1
	end
	Sine=Sine+Change
	hue=hue+1
	if(hue>360)then hue=1 end
	local hitfloor,posfloor = workspace:FindPartOnRayWithIgnoreList(Ray.new(Root.CFrame.p,((CFrame.new(Root.Position,Root.Position - Vector3.new(0,1,0))).lookVector).unit * (4)), {Effects,Char,workspace[Player.Name]})
	local Walking = (math.abs(Root.Velocity.x) > 1 or math.abs(Root.Velocity.z) > 1)
	local State = (Hum.PlatformStand and 'Paralyzed' or Hum.Sit and 'Sit' or (not hitfloor or hitfloor.CanCollide==false) and Root.Velocity.y < -1 and "Fall" or (not hitfloor or hitfloor.CanCollide==false) and Root.Velocity.y > 1 and "Jump" or hitfloor and Walking and "Walk" or hitfloor and "Idle")
	Hum.WalkSpeed = WalkSpeed
	local sidevec = math.clamp((Torso.Velocity*Torso.CFrame.rightVector).X+(Torso.Velocity*Torso.CFrame.rightVector).Z,-Hum.WalkSpeed,Hum.WalkSpeed)
	local forwardvec =  math.clamp((Torso.Velocity*Torso.CFrame.lookVector).X+(Torso.Velocity*Torso.CFrame.lookVector).Z,-Hum.WalkSpeed,Hum.WalkSpeed)
	local sidevelocity = sidevec/Hum.WalkSpeed
	local forwardvelocity = forwardvec/Hum.WalkSpeed
 
	local lhit,lpos = workspace:FindPartOnRayWithIgnoreList(Ray.new(LLeg.CFrame.p,((CFrame.new(LLeg.Position,LLeg.Position - Vector3.new(0,1,0))).lookVector).unit * (2)), {Effects,Char,workspace[Player.Name]})
	local rhit,rpos = workspace:FindPartOnRayWithIgnoreList(Ray.new(RLeg.CFrame.p,((CFrame.new(RLeg.Position,RLeg.Position - Vector3.new(0,1,0))).lookVector).unit * (2)), {Effects,Char,workspace[Player.Name]})
	if(Mode=='Troubadour' and IsVaporwave(getMode'Troubadour'.Music))then
		vaporwaveMode=true
		text.Text='Ｖａｐｏｒｗａｖｅ'
		WingAnim='NebG3'
	else
		if(Mode=='Troubadour')then
			text.Text='Troubadour'
			WingAnim=getMode'Troubadour'.WingAnim
		end
		vaporwaveMode=false
	end
 
	if(Mode~='Lust' and WingAnim and WingAnims[WingAnim])then
		WingAnims[WingAnim]()
	elseif(Mode=='Lust')then
		if(State=='Idle')then
			WingAnims.LustFrench()
		else
			WingAnims.NebG3(1)	
		end
	elseif(WingAnim and typeof(WingAnim)=='table' and WingAnims[WingAnim[1]])then
		local gay={unpack(WingAnim)};
		table.remove(gay,1)
		WingAnims[WingAnim[1]](unpack(gay))
	else
		WingAnims.NebG1()
	end
 
	if(Mode=='Troubadour' and NeutralAnims)then
		WingSine=WingSine+(0.1+music.PlaybackLoudness/300)
	else
		WingSine=WingSine+1
	end
 
	if(music)then
		if(Mode=='Troubadour')then
			local clr = Color3.fromHSV(hue/360,1,math.clamp(music.PlaybackLoudness/475,0,1))
			local clr2 = Color3.fromHSV(hue/360,1,math.clamp(music.PlaybackLoudness/950,0,1))
			text.TextColor3 = clr
			PrimaryColor = clr2
			for _,v in next, wingModel:GetDescendants() do
				if(v:IsA'BasePart')then
					v.Color = clr2
				elseif(v:IsA'Trail')then
					v.Color = ColorSequence.new(clr2)
				end
			end
		end
	end
 
	if(Mode=='The Big Black')then
		local pos = Head.Position
		local dist = (camera.CFrame.p-pos).magnitude
		local DropDist = 1
		local IneffectiveDist = 15
		local modifier = dist < DropDist and 1 or dist < IneffectiveDist and (0 - 1) / (IneffectiveDist - DropDist) * (dist - DropDist) + 1 or 0
	end
 
	if(Mode=='Troubadour' and data.User==data.Local)then
		Tween(camera,{FieldOfView=70-(music.PlaybackLoudness/20)},.2,Enum.EasingStyle.Linear,Enum.EasingDirection.Out)
	else
		Tween(camera,{FieldOfView=70},.2,Enum.EasingStyle.Linear,Enum.EasingDirection.Out)
	end
 
	if(State == 'Idle')then
		if(Mode=='Troubadour' and NeutralAnims and not vaporwaveMode)then Change = 0.1+music.PlaybackLoudness/200 else Change = 1 end
		if(Mode=='Achromatic')then
			local Alpha = .1
			if(NeutralAnims)then	
				RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,0+.05*M.C(Sine/32),0)*CF.A(M.R(0+1*M.S(Sine/64)),M.R(5),0),Alpha)
				NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(-5),0),Alpha)
				LS.C0 = LS.C0:lerp(LSC0*CF.N(0,0+.05*M.S(Sine/32),0)*CF.A(0,M.R(5+5*M.C(Sine/32)),M.R(-10-5*M.C(Sine/32))),Alpha)
				RS.C0 = RS.C0:lerp(RSC0*CF.N(0,0+.05*M.S(Sine/32),0)*CF.A(0,M.R(5-5*M.C(Sine/32)),M.R(10+5*M.C(Sine/32))),Alpha)
			end
			if(legAnims)then 
				if(NeutralAnims)then
					LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0-.05*M.C(Sine/32),0),Alpha)
					RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(0,M.R(-5),0),Alpha)
				else
					LH.C0 = LH.C0:lerp(LHC0,Alpha)
					RH.C0 = RH.C0:lerp(RHC0,Alpha)
				end
			end
		elseif(Mode=='Iniquitous')then
			local Alpha = .1
			if(NeutralAnims)then	
				RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,0+.05*M.C(Sine/32),0)*CF.A(M.R(0+3*M.S(Sine/64)),0,0),Alpha)
				if(M.RNG(1,45)==1)then
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.RRNG(-25,25),M.RRNG(-25,25),M.RRNG(-25,25)),.8)
				else
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),0,0),Alpha)
				end
				LS.C0 = LS.C0:lerp(LSC0*CF.N(.3,0+.05*M.S(Sine/32),.1)*CF.A(M.R(-35),M.R(5+2.5*M.C(Sine/32)),M.R(35-1.5*M.C(Sine/32))),Alpha)
				RS.C0 = RS.C0:lerp(RSC0*CF.N(-.3,0+.05*M.S(Sine/32),.1)*CF.A(M.R(-25),M.R(5-2.5*M.C(Sine/32)),M.R(-35+1.5*M.C(Sine/32))),Alpha)
			end
			if(legAnims)then 
				if(NeutralAnims)then
					LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(0,0,M.R(-2.5)),Alpha)
					RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(0,0,M.R(2.5)),Alpha)
				else
					LH.C0 = LH.C0:lerp(LHC0*CF.A(0,0,M.R(-2.5)),Alpha)
					RH.C0 = RH.C0:lerp(RHC0*CF.A(0,0,M.R(2.5)),Alpha)
				end
			end
		elseif(Mode=='Mythical')then
			local Alpha = .1
			if(NeutralAnims)then	
				GotEffect{
					Lifetime=.5;
					Mesh={Type=Enum.MeshType.Sphere};
					CFrame=LArm.CFrame*CF.N(0,-1,0)*CF.A(M.RRNG(0,360),M.RRNG(0,360),M.RRNG(0,360));
					Color=BrickColor.new'Alder'.Color;
					Transparency={.5,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(.3,2,.3);
					EndSize=Vector3.new(.1,1,.1);
				}
				RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,0+.05*M.C(Sine/32),0)*CF.A(M.R(0+1*M.S(Sine/64)),M.R(-15),0),Alpha)
				NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(15),0),Alpha)
				LS.C0 = LS.C0:lerp(LSC0*CF.N(.5,0+.05*M.S(Sine/32),-.5)*CF.A(M.R(15+1.5*M.C(Sine/51)),M.R(5+5*M.C(Sine/57)),M.R(85-5*M.C(Sine/46))),Alpha)
				RS.C0 = RS.C0:lerp(RSC0*CF.N(-.3,0+.05*M.S(Sine/32),.1)*CF.A(M.R(-25),M.R(5-2.5*M.C(Sine/32)),M.R(-35+1.5*M.C(Sine/32))),Alpha)
			end
			if(legAnims)then 
				if(NeutralAnims)then
					LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(0,M.R(15),0),Alpha)
					RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0-.05*M.C(Sine/32),0),Alpha)
				else
					LH.C0 = LH.C0:lerp(LHC0,Alpha)
					RH.C0 = RH.C0:lerp(RHC0,Alpha)
				end
			end
		elseif(Mode=='Ruined')then
			local Alpha = .1
			if(NeutralAnims)then	
				RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,0+.05*M.C(Sine/32),0)*CF.A(M.R(-5+1*M.S(Sine/64)),M.R(-25),0),Alpha)
				if(M.RNG(1,25)==1)then
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.RRNG(-25,25),M.RRNG(-25,25),M.RRNG(-25,25)),.8)
				else
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(35),M.R(-10))*CF.A(M.RRNG(-5,5),M.RRNG(-5,5),M.RRNG(-5,5)),Alpha)
				end
				LS.C0 = LS.C0:lerp(LSC0*CF.N(0,0+.05*M.S(Sine/32),0)*CF.A(0,M.R(5+5*M.C(Sine/32)),M.R(-10-5*M.C(Sine/32))),Alpha)
				RS.C0 = RS.C0:lerp(RSC0*CF.N(-.1,0+.05*M.S(Sine/32),0)*CF.A(M.R(175),M.R(5-2.5*M.C(Sine/32)),M.R(-25-1.5*M.C(Sine/32))),Alpha)
			end
			if(legAnims)then 
				if(NeutralAnims)then
					LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(M.R(-10),M.R(25),0),Alpha)
					RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(M.R(5),0,0),Alpha)
				else
					LH.C0 = LH.C0:lerp(LHC0,Alpha)
					RH.C0 = RH.C0:lerp(RHC0,Alpha)
				end
			end
		--[[elseif(Mode=='Atramentous')then
			local Alpha = .1
			if(NeutralAnims)then	
				RJ.C0 = RJ.C0:lerp(RJC0*CF.N(-.2+.4*M.C(Sine/39),.5+.2*M.C(Sine/32),0)*CF.A(M.R(-2+5*M.S(Sine/58)),M.R(-15+5*M.C(Sine/42)),0),Alpha)
				NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-7-2.5*M.S(Sine/32)),M.R(15),0),Alpha)
				LS.C0 = LS.C0:lerp(LSC0*CF.N(0,0+.05*M.S(Sine/32),0)*CF.A(0,0,M.R(-15+5*M.S(Sine/32))),Alpha)
				RS.C0 = RS.C0:lerp(RSC0*CF.N(0,0+.05*M.S(Sine/32),0)*CF.A(0,0,M.R(15-5*M.S(Sine/32))),Alpha)
			end
			if(legAnims)then 
				if(NeutralAnims)then
					LH.C0 = LH.C0:lerp(LHC0*CF.N(0,.5,-.2)*CF.A(0,0,M.R(-5)),Alpha)
					RH.C0 = RH.C0:lerp(RHC0*CF.A(0,0,M.R(5)),Alpha)
				else
					LH.C0 = LH.C0:lerp(LHC0,Alpha)
					RH.C0 = RH.C0:lerp(RHC0,Alpha)
				end
			end]]
		elseif(Mode=='Atramentous')then
			local Alpha = .1
			if(NeutralAnims)then	
				RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,0+.05*M.C(Sine/32),0)*CF.A(M.R(-25+1*M.S(Sine/64)),0,0),Alpha)
				NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(-5),0),Alpha)
				LS.C0 = LS.C0:lerp(LSC0*CF.N(0,0+.05*M.S(Sine/32),0)*CF.A(M.R(25),M.R(5+5*M.C(Sine/32)),M.R(-10-5*M.C(Sine/32))),Alpha)
				RS.C0 = RS.C0:lerp(RSC0*CF.N(0,0+.05*M.S(Sine/32),0)*CF.A(M.R(25),M.R(5-5*M.C(Sine/32)),M.R(10+5*M.C(Sine/32))),Alpha)
			end
			if(legAnims)then 
				if(NeutralAnims)then
					LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(M.R(25),0,M.R(-3)),Alpha)
					RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(M.R(25),0,M.R(3)),Alpha)
				else
					LH.C0 = LH.C0:lerp(LHC0,Alpha)
					RH.C0 = RH.C0:lerp(RHC0,Alpha)
				end
			end
		elseif(Mode=='Subzero')then
			local Alpha = .1
			if(NeutralAnims)then	
				RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,0+.05*M.C(Sine/32),0)*CF.A(0,M.R(28),0),Alpha)
				NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-7-2.5*M.S(Sine/32)),M.R(-28),0),Alpha)
				LS.C0 = LS.C0:lerp(LSC0*CF.N(.5,-.1+.05*M.S(Sine/32),-.8)*CF.A(M.R(13),M.R(-12),M.R(104-2*M.S(Sine/36))),Alpha)
				RS.C0 = RS.C0:lerp(RSC0*CF.N(-.5,0+.05*M.S(Sine/32),-.6)*CF.A(M.R(-17),M.R(-20),M.R(-79+1*M.S(Sine/36))),Alpha)
			end
			if(legAnims)then 
				if(NeutralAnims)then
					LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(0,0,M.R(-1)),Alpha)
					RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(M.R(4),M.R(-28),M.R(8)),Alpha)
				else
					LH.C0 = LH.C0:lerp(LHC0,Alpha)
					RH.C0 = RH.C0:lerp(RHC0,Alpha)
				end
			end
		elseif(Mode=='Troubadour')then
			if(vaporwaveMode)then
			  	local Alpha = .1
				if(NeutralAnims)then
					RJ.C0 = RJ.C0:lerp(CF.N(0,-0.2-.1*M.S(Sine/36),0.6)*CF.A(M.R(74.3+2.5*M.C(Sine/36)),M.R(0),M.R(0)),Alpha)
					LS.C0 = LS.C0:lerp(CF.N(-1,0.8,0)*CF.A(M.R(11.4-5*M.C(Sine/42)),M.R(-3.3),M.R(137.5)),Alpha)
					RS.C0 = RS.C0:lerp(CF.N(1,0.9,-0.1)*CF.A(M.R(13.7-5*M.C(Sine/42)),M.R(7.7),M.R(-136.2)),Alpha)
					NK.C0 = NK.C0:lerp(CF.N(0,1.4,-0.3)*CF.A(M.R(-16.6-5*M.C(Sine/42)),M.R(0),M.R(0)),Alpha)
					if(legAnims)then
						LH.C0 = LH.C0:lerp(CF.N(-0.7,-1,0)*CF.A(M.R(37.2+10*M.C(Sine/36)),M.R(0),M.R(24)),Alpha)
						RH.C0 = RH.C0:lerp(CF.N(0.8,-1.1,-0.1)*CF.A(M.R(5.9+5*M.C(Sine/36)),M.R(3.5),M.R(-43.9)),Alpha)
					end
				elseif(legAnims)then
					LH.C0 = LH.C0:lerp(LHC0,Alpha)
					RH.C0 = RH.C0:lerp(RHC0,Alpha)
				end
			else
				local Alpha = .3
				if(NeutralAnims)then	
					RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,0+.05*M.C(Sine/20)+(music.PlaybackLoudness/5000),0)*CF.A(M.R(0+1*M.S(Sine/64)),M.R(35),0),Alpha)
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(0+1*M.S(Sine/24)),M.R(-35),0),Alpha)
					LS.C0 = LS.C0:lerp(LSC0*CF.A(0,0,M.R(-15+10*M.C(Sine/20))),Alpha)
					RS.C0 = RS.C0:lerp(RSC0*CF.A(M.R(75-(music.PlaybackLoudness/7.5)),M.R(5),M.R(35)),Alpha)
				end
				if(legAnims)then 
					if(NeutralAnims)then
						LH.C0 = LH.C0:lerp(LHC0*CF.N(0,-.05*M.C(Sine/20)-(music.PlaybackLoudness/5000),0)*CF.A(0,M.R(25),0),Alpha)
						RH.C0 = RH.C0:lerp(RHC0*CF.N(0,-.05*M.C(Sine/20)-(music.PlaybackLoudness/5000),0),Alpha)
					else
						LH.C0 = LH.C0:lerp(LHC0,Alpha)
						RH.C0 = RH.C0:lerp(RHC0,Alpha)
					end
				end
			end
		elseif(Mode=='Infectious')then
			local Alpha = .1
			if(NeutralAnims)then	
				GotEffect{
					Lifetime=.2;
					Mesh={Type=Enum.MeshType.Sphere};
					CFrame=LArm.CFrame*CF.N(0,-1,0)*CF.A(M.RRNG(0,360),M.RRNG(0,360),M.RRNG(0,360));
					Color=BrickColor.new'Dark indigo'.Color;
					Transparency={0,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(.5,1,.5);
					EndSize=Vector3.new(.1,3,.1);
				}
				GotEffect{
					Lifetime=.2;
					Mesh={Type=Enum.MeshType.Sphere};
					CFrame=RArm.CFrame*CF.N(0,-1,0)*CF.A(M.RRNG(0,360),M.RRNG(0,360),M.RRNG(0,360));
					Color=BrickColor.new'Dark indigo'.Color;
					Transparency={0,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(.5,1,.5);
					EndSize=Vector3.new(.1,3,.1);
				}
				RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,0+.05*M.C(Sine/32),0)*CF.A(M.R(0+1*M.S(Sine/64)),M.R(-15),0),Alpha)
				NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-10-2.5*M.S(Sine/32)),M.R(15),0),Alpha)
				RS.C0 = RS.C0:lerp(RSC0*CF.N(-.5,0+.05*M.S(Sine/32),-.4)*CF.A(M.R(25),M.R(5-2.5*M.C(Sine/32)),M.R(-65+1.5*M.C(Sine/32))),Alpha)
				LS.C0 = LS.C0:lerp(LSC0*CF.N(0,0+.05*M.S(Sine/32),0)*CF.A(0,M.R(5-5*M.C(Sine/32)),M.R(-10-5*M.C(Sine/32))),Alpha)
			end
			if(legAnims)then 
				if(NeutralAnims)then
					LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0-.05*M.C(Sine/32),0)*CF.A(0,M.R(15),0),Alpha)
					RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0-.05*M.C(Sine/32),0),Alpha)
				else
					LH.C0 = LH.C0:lerp(LHC0,Alpha)
					RH.C0 = RH.C0:lerp(RHC0,Alpha)
				end
			end
		elseif(Mode=='Love')then
			local Alpha = .1
			if(NeutralAnims)then	
				RJ.C0 = RJ.C0:lerp(CF.N(0,0,0)*CF.A(0,0,M.R(0+5*M.C(Sine/16))),Alpha)
				NK.C0 = NK.C0:lerp(NKC0*CF.A(0,0,-M.R(0+5*M.C(Sine/16))),Alpha)
				LS.C0 = LS.C0:lerp(LSC0*CF.N(0,-.15,0)*CF.A(M.R(15),0,M.R(20)),Alpha)
				RS.C0 = RS.C0:lerp(RSC0*CF.A(0,0,M.R(5+5*M.S(Sine/16))),Alpha)
			end
			if(legAnims)then 
				if(NeutralAnims)then
					LH.C0 = LH.C0:lerp(LHC0*CF.A(0,0,-M.R(0+5*M.C(Sine/16)))*CF.A(M.R(-15),M.R(25),0),Alpha)
					RH.C0 = RH.C0:lerp(RHC0*CF.A(0,0,-M.R(0+5*M.C(Sine/16))),Alpha)
				else
					LH.C0 = LH.C0:lerp(LHC0,Alpha)
					RH.C0 = RH.C0:lerp(RHC0,Alpha)
				end
			end
		elseif(Mode=='The Big Black')then
			local Alpha = .1
			if(NeutralAnims)then
				GotEffect{
					Lifetime=.5;
					Mesh={Type=Enum.MeshType.Sphere};
					CFrame=RArm.CFrame*CF.N(0,-1,0)*CF.A(M.RRNG(0,360),M.RRNG(0,360),M.RRNG(0,360));
					Color=BrickColor.new'Black'.Color;
					Transparency={0,1};
					Material=Enum.Material.Neon;
					Size=Vector3.new(.5,1,.5);
					EndSize=Vector3.new(.1,3,.1);
				}
				RJ.C0 = RJ.C0:lerp(CF.N(0,0+.05*M.C(Sine/32),0.2)*CF.A(M.R(15.5),M.R(20.8),M.R(0)),Alpha)
				LS.C0 = LS.C0:lerp(CF.N(-0.9,0.4,-0.7)*CF.A(M.R(121.8),M.R(14.6),M.R(84.8))*CF.A(M.R(0+3*M.S(Sine/32)),0,0),Alpha)
				RS.C0 = RS.C0:lerp(CF.N(1.3,0.3,-0.1)*CF.A(M.R(40+5*M.C(Sine/44)),M.R(-11.6),M.R(65.5+2.5*M.C(Sine/36))),Alpha)
				if(M.RNG(1,45)==1)then
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.RRNG(-25,25),M.RRNG(-25,25),M.RRNG(-25,25)),.8)
				else
					NK.C0 = NK.C0:lerp(CF.N(0,1.5,-0.2)*CF.A(M.R(-15.6),M.R(-20.1),M.R(-5.5))*CF.A(M.R(0+1.5*M.S(Sine/32)),0,0),Alpha)
				end
				if(legAnims)then
					LH.C0 = LH.C0:lerp(CF.N(-0.6,-1-.05*M.C(Sine/32),0.1)*CF.A(M.R(-27.6),M.R(0),M.R(13.8)),Alpha)
					RH.C0 = RH.C0:lerp(CF.N(0.6,-1.1-.05*M.C(Sine/32),-0.1)*CF.A(M.R(-16.5),M.R(-20),M.R(-5.8)),Alpha)
				end
			elseif(legAnims)then
				LH.C0 = LH.C0:lerp(LHC0,Alpha)
				RH.C0 = RH.C0:lerp(RHC0,Alpha)
			end
		elseif(Mode=='Legendary')then
			local Alpha = .1
			if(NeutralAnims)then
				RJ.C0 = RJ.C0:lerp(CF.N(0,4.8+.2*M.C(Sine/24),0)*CF.A(M.R(30+5*M.S(Sine/24)),M.R(16.7),M.R(-9.4)),Alpha)
				LS.C0 = LS.C0:lerp(CF.N(-1.1,1,0.2)*CF.A(M.R(173.3+1*M.S(Sine/28)),M.R(19.9+2*M.S(Sine/28)),M.R(38.7)),Alpha)
				RS.C0 = RS.C0:lerp(CF.N(0.7,0.3,-0.6)*CF.A(M.R(46.8+1*M.S(Sine/28)),M.R(6.4+2*M.S(Sine/28)),M.R(-79.6)),Alpha)
				NK.C0 = NK.C0:lerp(CF.N(0,1.4,-0.5)*CF.A(M.R(-40-5*M.S(Sine/24)),M.R(-18.7),M.R(-3.7)),Alpha)
				if(legAnims)then
					LH.C0 = LH.C0:lerp(CF.N(-0.5,-1,0)*CF.A(M.R(1.9+7.5*M.S(Sine/24)),M.R(19.2),M.R(-5.7)),Alpha)
					RH.C0 = RH.C0:lerp(CF.N(0.4,-1,-0.8)*CF.A(M.R(-63.8+7.5*M.S(Sine/24)),M.R(-15),M.R(8.3)),Alpha)
				end
			elseif(legAnims)then
				LH.C0 = LH.C0:lerp(LHC0,Alpha)
				RH.C0 = RH.C0:lerp(RHC0,Alpha)
			end
			elseif(Mode=='Lust')then
				local Alpha = .1
				if(NeutralAnims)then
					RJ.C0 = RJ.C0:lerp(CF.N(0,0.7+.1*M.C(Sine/36),0)*CF.A(M.R(0),M.R(0),M.R(-90-2.5*M.S(Sine/36))),Alpha)
					LS.C0 = LS.C0:lerp(CF.N(-1.2,0.1,0.1)*CF.A(M.R(23),M.R(16.5),M.R(20.6)),Alpha)
					RS.C0 = RS.C0:lerp(CF.N(0.8,1,-0.4)*CF.A(M.R(-162),M.R(-11.2),M.R(-22.6)),Alpha)
					NK.C0 = NK.C0:lerp(CF.N(-0.2,1.4,0)*CF.A(M.R(0),M.R(0),M.R(48.9)),Alpha)
					if(legAnims)then
						LH.C0 = LH.C0:lerp(CF.N(-0.9,-1.1,-0.2)*CF.A(M.R(-19.3),M.R(6.5),M.R(54.3-7.5*M.S(Sine/36))),Alpha)
						RH.C0 = RH.C0:lerp(CF.N(0.4,-0.9,0)*CF.A(M.R(0),M.R(0),M.R(25.9-7.5*M.S(Sine/36))),Alpha)
					end
			elseif(legAnims)then
				LH.C0 = LH.C0:lerp(LHC0,Alpha)
				RH.C0 = RH.C0:lerp(RHC0,Alpha)
			end
		end
    elseif(State == 'Walk')then
		--[[if(Mode=='Atramentous')then
			local Alpha = .1
  			if(NeutralAnims)then
 				RJ.C0 = RJ.C0:lerp(RJC0*CF.N(-.2+.4*M.C(Sine/39),.5+.2*M.C(Sine/32),0)*CF.A(M.R(-85+5*M.S(Sine/58)),M.R(0+5*M.C(Sine/42)),0),Alpha)
 				LS.C0 = LS.C0:lerp(CFrame.new(-1.50198829, 0.580981374, 0.000380858371, 0.963434994, 0.267942399, 1.75953949e-06, -0.267942399, 0.963434994, 5.1856041e-06, -3.05473804e-07, -5.48362732e-06, 1)*CF.A(0,0,M.R(0+5*M.S(Sine/32))),Alpha)
  				RS.C0 = RS.C0:lerp(CFrame.new(1.54895508, 0.519735038, 0.000380946265, 0.98034811, -0.197275475, -1.24170782e-07, 0.19727549, 0.980348051, 9.53674316e-07, -5.96046448e-08, -9.23871994e-07, 1)*CF.A(0,0,M.R(0-5*M.S(Sine/32))),Alpha)
  				NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(65-5*M.S(Sine/58)),0,0),Alpha)
			end
			if(legAnims)then
				LH.C0 = LH.C0:lerp(CFrame.new(-0.49666214, -0.990924835, 0.00763010979, 1, 0, 0, 0, 1, 0, 0, 0, 1),Alpha)
				RH.C0 = RH.C0:lerp(CFrame.new(0.498336792, -0.303280592, -0.883536756, 1, 0, 0, 0, 0.886996508, 0.461776346, 0, -0.461776316, 0.886996448),Alpha)
			end
		else]]
 
			local wsVal = 4
			local Alpha = .2
			if(Mode=='Subzero')then Change=.3 elseif(Mode=='The Big Black' or Mode=='Legendary')then Change=1 else Change=.5 end
			if(NeutralAnims)then
				RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,.05+Change/4*M.C(Sine/(wsVal/2)),0)*CF.A(M.R(-(Change*20)-movement/20*M.C(Sine/(wsVal/2)))*forwardvelocity,M.R(0+5*M.C(Sine/wsVal)),M.R(-(Change*20)-movement/20*M.C(Sine/(wsVal/2)))*sidevelocity+M.R(0-1*M.C(Sine/wsVal))),Alpha)
				NK.C0 = NK.C0:lerp(NKC0,Alpha)
				LS.C0 = LS.C0:lerp(LSC0*CF.N(0,0,0)*CF.A(M.R(0+55*(movement/8)*M.S(Sine/wsVal))*forwardvelocity,0,0),Alpha)
				RS.C0 = RS.C0:lerp(RSC0*CF.N(0,0,0)*CF.A(M.R(0-55*(movement/8)*M.S(Sine/wsVal))*forwardvelocity,0,0),Alpha)
			end
			if(legAnims)then 
				LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0-movement/15*M.C(Sine/wsVal)/2,(-.1+movement/15*M.C(Sine/wsVal))*(.5+.5*forwardvelocity))*CF.A((M.R(-10*forwardvelocity+Change*5-movement*M.C(Sine/wsVal))+-(movement/10)*M.S(Sine/wsVal))*forwardvelocity,0,(M.R(Change*5-movement*M.C(Sine/wsVal))+-(movement/10)*M.S(Sine/wsVal))*(sidevec/(Hum.WalkSpeed*2))),Alpha)
				RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0+movement/15*M.C(Sine/wsVal)/2,(-.1-movement/15*M.C(Sine/wsVal))*(.5+.5*forwardvelocity))*CF.A((M.R(-10*forwardvelocity+Change*5+movement*M.C(Sine/wsVal))+(movement/10)*M.S(Sine/wsVal))*forwardvelocity,0,(M.R(Change*5+movement*M.C(Sine/wsVal))+(movement/10)*M.S(Sine/wsVal))*(sidevec/(Hum.WalkSpeed*2))),Alpha)
				local footstepIds = {141491460,141491460}
				if(lhit and lhit.CanCollide and footstepSounds[lhit.Material])then
					if(lhit.Material==Enum.Material.Sand and lhit.Color.r*255>=160 and lhit.Color.g*255>=160 and lhit.Color.b*255>=160)then
						footstepIds[1] = footstepSounds[Enum.Material.Snow]
					else
						footstepIds[1] = footstepSounds[lhit.Material]
					end
				end
 
				if(rhit and rhit.CanCollide and footstepSounds[rhit.Material])then
					if(rhit.Material==Enum.Material.Sand and rhit.Color.r*255>=160 and rhit.Color.g*255>=160 and rhit.Color.b*255>=160)then
						footstepIds[2] = footstepSounds[Enum.Material.Snow]
					else
						footstepIds[2] = footstepSounds[rhit.Material]
					end
				end
 
 
				if(M.C(Sine/wsVal)/2>=.2 and footsound==0 and lhit)then
					local step = Part(Effects,lhit.Color,lhit.Material,V3.N(1,.1,1),CF.N(lpos),true,false)
					step.Transparency=(footstepIds[1]==footstepSounds[Enum.Material.Snow] and 0 or 1)
					local snd = Soond(step,footstepIds[1],M.RNG(80,100)/100,3,false,true,true)
					footsound=1
					S.Debris:AddItem(step,snd.TimeLength+2)
				elseif(M.C(Sine/wsVal)/2<=-.2 and footsound==1 and rhit)then
					local step = Part(Effects,rhit.Color,rhit.Material,V3.N(1,.1,1),CF.N(rpos),true,false)
					step.Transparency=(footstepIds[2]==footstepSounds[Enum.Material.Snow] and 0 or 1)
					local snd = Soond(step,footstepIds[2],M.RNG(80,100)/100,3,false,true,true)
					footsound=0
					S.Debris:AddItem(step,snd.TimeLength+2)
				end
			end
        --end
	elseif(State == 'Jump')then
		local Alpha = .1
		local idk = math.min(math.max(Root.Velocity.Y/50,-M.R(90)),M.R(90))
		if(NeutralAnims)then
			LS.C0 = LS.C0:lerp(LSC0*CF.A(M.R(-5),0,M.R(-90)),Alpha)
			RS.C0 = RS.C0:lerp(RSC0*CF.A(M.R(-5),0,M.R(90)),Alpha)
			RJ.C0 = RJ.C0:lerp(RJC0*CF.A(math.min(math.max(Root.Velocity.Y/100,-M.R(45)),M.R(45)),0,0),Alpha)
			NK.C0 = NK.C0:lerp(NKC0*CF.A(math.min(math.max(Root.Velocity.Y/100,-M.R(45)),M.R(45)),0,0),Alpha)
		end
		if(legAnims)then 
			LH.C0 = LH.C0:lerp(LHC0*CF.A(0,0,M.R(-5)),Alpha)
			RH.C0 = RH.C0:lerp(RHC0*CF.N(0,1,-1)*CF.A(M.R(-5),0,M.R(5)),Alpha)
		end
	elseif(State == 'Fall')then
		local Alpha = .1
		local idk = math.min(math.max(Root.Velocity.Y/50,-M.R(90)),M.R(90))
		if(NeutralAnims)then
			LS.C0 = LS.C0:lerp(LSC0*CF.A(M.R(-5),0,M.R(-90)+idk),Alpha)
			RS.C0 = RS.C0:lerp(RSC0*CF.A(M.R(-5),0,M.R(90)-idk),Alpha)
			RJ.C0 = RJ.C0:lerp(RJC0*CF.A(math.min(math.max(Root.Velocity.Y/100,-M.R(45)),M.R(45)),0,0),Alpha)
			NK.C0 = NK.C0:lerp(NKC0*CF.A(math.min(math.max(Root.Velocity.Y/100,-M.R(45)),M.R(45)),0,0),Alpha)
		end
		if(legAnims)then 
			LH.C0 = LH.C0:lerp(LHC0*CF.A(0,0,M.R(-5)),Alpha)
			RH.C0 = RH.C0:lerp(RHC0*CF.N(0,1,-1)*CF.A(M.R(-5),0,M.R(5)),Alpha)
		end
	elseif(State == 'Paralyzed')then
		local Alpha = .1
		if(NeutralAnims)then
			LS.C0 = LS.C0:lerp(LSC0,Alpha)
			RS.C0 = RS.C0:lerp(RSC0,Alpha)
			RJ.C0 = RJ.C0:lerp(RJC0,Alpha)
			NK.C0 = NK.C0:lerp(NKC0,Alpha)
		end
		if(legAnims)then 
			LH.C0 = LH.C0:lerp(LHC0,Alpha)
			RH.C0 = RH.C0:lerp(RHC0,Alpha)
		end
	elseif(State == 'Sit')then
 
	end
	if(data.User==data.Local)then
		local syncStuff={
			NeutralAnims;
			legAnims;
			{NK.C0,RJ.C0,RH.C0,RS.C0,LH.C0,LS.C0};
			{NK.C1,RJ.C1,RH.C1,RS.C1,LH.C1,LS.C1};
			Sine;
			movement;
			walking;	
			Change;
			--// OPTIONAL SYNC \\--
			MusicMode;
			(music and music.TimePosition or 0);
			(music and music.Pitch or 1);
			WingSine;
			getMode('Troubadour');
			Mode;
			hue;
		}
	end
end

end)

--Mr Scripter White Hub v2.6 Beta Made By Me